commit 43e65147c07b1400ae0dbb6694882eceb2363713
Author: H.J. Lu <hjl.tools@gmail.com>
Date:   Wed Aug 12 04:45:07 2015 -0700

    Remove trailing spaces in opcodes

--- a/opcodes/ChangeLog-2006
+++ b/opcodes/ChangeLog-2006
@@ -193,11 +193,11 @@
 
 2006-10-23  Dwarakanath Rajagopal  <dwarak.rajagopal@amd.com>
 
-	* i386-dis.c (dis386): Add support for the change in POPCNT opcode in 
+	* i386-dis.c (dis386): Add support for the change in POPCNT opcode in
 	amdfam10 architecture.
 	(PREGRP37): NEW.
 	(print_insn): Disallow REP prefix for POPCNT.
-	 
+
 2006-10-20  Andrew Stubbs  <andrew.stubbs@st.com>
 
 	* sh-dis.c (print_insn_sh): Remove 0x from output to prevent GDB
@@ -274,9 +274,9 @@
 	* i386-dis.c (MXC,EMC): Define.
 	(OP_MXC): New function to handle cvt* (convert instructions) between
 	%xmm and %mm register correctly.
-	(OP_EMC): ditto.	
-	(prefix_user_table): Modified cvtpi2pd,cvtpd2pi and cvttpd2pi 
-	instruction operands in PREGRP2,PREGRP3,PREGRP4 appropriately 
+	(OP_EMC): ditto.
+	(prefix_user_table): Modified cvtpi2pd,cvtpd2pi and cvttpd2pi
+	instruction operands in PREGRP2,PREGRP3,PREGRP4 appropriately
 	with EMC/MXC.
 
 2006-07-29  Richard Sandiford  <richard@codesourcery.com>
@@ -689,7 +689,7 @@
 	New cases '$' and '%' for read/write hyperprivileged register.
 	* sparc-opc.c (sparc_opcodes): Add new entries for UA2005
 	window handling and rdhpr/wrhpr instructions.
-	
+
 2006-02-24  DJ Delorie  <dj@redhat.com>
 
 	* m32c-desc.c: Regenerate with linker relaxation attributes.
@@ -742,13 +742,13 @@
 
 	* xc16x-desc.h: New file
 	* xc16x-desc.c: New file
-	* xc16x-opc.h: New file	
+	* xc16x-opc.h: New file
 	* xc16x-opc.c: New file
 	* xc16x-ibld.c: New file
 	* xc16x-asm.c: New file
 	* xc16x-dis.c: New file
-	* Makefile.am: Entries for xc16x 
-	* Makefile.in: Regenerate 
+	* Makefile.am: Entries for xc16x
+	* Makefile.in: Regenerate
 	* cofigure.in: Add xc16x target information.
 	* configure: Regenerate.
 	* disassemble.c: Add xc16x target information.
@@ -783,7 +783,7 @@
 
 	* z80-dis.c (struct buffer, prt_d, prt_d_n, arit_d, ld_r_d,
 	ld_d_r, pref_xd_cb): Use signed char to hold data to be
-	disassembled.	
+	disassembled.
 	* z80-dis.c (TXTSIZ): Increase buffer size to 24, this fixes
 	buffer overflows when disassembling instructions like
 	ld (ix+123),0x23
--- a/opcodes/ChangeLog-2007
+++ b/opcodes/ChangeLog-2007
@@ -1071,7 +1071,7 @@
 	* s390-mkopc.c (struct s390_cond_ext_format): New global struct.
 	(s390_cond_ext_format): New global variable.
 	(expandConditionalJump): New function.
-	(main): Invoke expandConditionalJump for mnemonics containing '*'.	
+	(main): Invoke expandConditionalJump for mnemonics containing '*'.
 	* s390-opc.txt: Replace mnemonics with conditional
 	mask extensions with instructions using the newly introduced '*' tag.
 
@@ -1096,7 +1096,7 @@
 	* ia64-gen.c: (main): Add missing newline to copyright message.
 	* ia64-ic.tbl (fp-non-arith): Add xmpy.
 	* ia64-asmtab.c: Regenerate.
-	
+
 2007-08-01  Michael Snyder  <msnyder@access-company.com>
 
 	* i386-dis.c (print_insn): Guard against NULL.
#--- a/opcodes/Makefile.am
#+++ b/opcodes/Makefile.am
#@@ -6,12 +6,12 @@
# # it under the terms of the GNU General Public License as published by
# # the Free Software Foundation; either version 3 of the License, or
# # (at your option) any later version.
#-# 
#+#
# # This program is distributed in the hope that it will be useful,
# # but WITHOUT ANY WARRANTY; without even the implied warranty of
# # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# # GNU General Public License for more details.
#-# 
#+#
# # You should have received a copy of the GNU General Public License
# # along with this program; see the file COPYING3.  If not see
# # <http://www.gnu.org/licenses/>.
#@@ -392,15 +392,15 @@ EPIPHANY_DEPS =
# FR30_DEPS =
# FRV_DEPS =
# IP2K_DEPS =
#-IQ2000_DEPS = 
#-LM32_DEPS = 
#+IQ2000_DEPS =
#+LM32_DEPS =
# M32C_DEPS =
# M32R_DEPS =
# MEP_DEPS =
# MT_DEPS =
#-OR1K_DEPS = 
#-XC16X_DEPS = 
#-XSTORMY16_DEPS = 
#+OR1K_DEPS =
#+XC16X_DEPS =
#+XSTORMY16_DEPS =
# endif
# 
# run-cgen:
#@@ -546,7 +546,7 @@ i386-gen.o: i386-gen.c i386-opc.h $(srcdir)/../include/opcode/i386.h \
# 	config.h i386-opc.h sysdep.h
# 	$(COMPILE_FOR_BUILD) -c $(srcdir)/i386-gen.c
# 
#-$(srcdir)/i386-tbl.h: $(srcdir)/i386-init.h 
#+$(srcdir)/i386-tbl.h: $(srcdir)/i386-init.h
# 	@echo $@
# 
# $(srcdir)/i386-init.h: @MAINT@ i386-gen$(EXEEXT_FOR_BUILD) i386-opc.tbl i386-reg.tbl
--- a/opcodes/Makefile.in
+++ b/opcodes/Makefile.in
@@ -22,12 +22,12 @@
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 3 of the License, or
 # (at your option) any later version.
-# 
+#
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
-# 
+#
 # You should have received a copy of the GNU General Public License
 # along with this program; see the file COPYING3.  If not see
 # <http://www.gnu.org/licenses/>.
@@ -1416,7 +1416,7 @@ i386-gen.o: i386-gen.c i386-opc.h $(srcdir)/../include/opcode/i386.h \
 	config.h i386-opc.h sysdep.h
 	$(COMPILE_FOR_BUILD) -c $(srcdir)/i386-gen.c
 
-$(srcdir)/i386-tbl.h: $(srcdir)/i386-init.h 
+$(srcdir)/i386-tbl.h: $(srcdir)/i386-init.h
 	@echo $@
 
 $(srcdir)/i386-init.h: @MAINT@ i386-gen$(EXEEXT_FOR_BUILD) i386-opc.tbl i386-reg.tbl
--- a/opcodes/aarch64-gen.c
+++ b/opcodes/aarch64-gen.c
@@ -209,7 +209,7 @@ static int max_num_opcodes_at_leaf_node = 0;
    is decided to be undividable and OPCODE will be assigned to BITTREE->LIST.
 
    The function recursively call itself until OPCODE is undividable.
-   
+
    N.B. the nature of this algrithm determines that given any value in the
    32-bit space, the computed decision tree will always be able to find one or
    more opcodes entries for it, regardless whether there is a valid instruction
--- a/opcodes/alpha-opc.c
+++ b/opcodes/alpha-opc.c
@@ -274,7 +274,7 @@ const struct alpha_operand alpha_operands[] =
 
   /* The signed "23-bit" aligned displacement of Branch format insns.  */
 #define BDISP		(MDISP + 1)
-  { 21, 0, BFD_RELOC_23_PCREL_S2, 
+  { 21, 0, BFD_RELOC_23_PCREL_S2,
     AXP_OPERAND_RELATIVE, insert_bdisp, extract_bdisp },
 
   /* The 26-bit PALcode function */
--- a/opcodes/arc-dis.c
+++ b/opcodes/arc-dis.c
@@ -35,18 +35,18 @@
 #define dbg (0)
 #endif
 
-/* Classification of the opcodes for the decoder to print 
+/* Classification of the opcodes for the decoder to print
    the instructions.  */
 
 typedef enum
 {
-  CLASS_A4_ARITH,	     
+  CLASS_A4_ARITH,
   CLASS_A4_OP3_GENERAL,
   CLASS_A4_FLAG,
   /* All branches other than JC.  */
   CLASS_A4_BRANCH,
   CLASS_A4_JC ,
-  /* All loads other than immediate 
+  /* All loads other than immediate
      indexed loads.  */
   CLASS_A4_LD0,
   CLASS_A4_LD1,
--- a/opcodes/arc-dis.h
+++ b/opcodes/arc-dis.h
@@ -21,14 +21,14 @@
 #ifndef ARCDIS_H
 #define ARCDIS_H
 
-enum 
+enum
 {
   BR_exec_when_no_jump,
   BR_exec_always,
   BR_exec_when_jump
 };
 
-enum Flow 
+enum Flow
 {
   noflow,
   direct_jump,
@@ -41,7 +41,7 @@ enum Flow
 enum { no_reg = 99 };
 enum { allOperandsSize = 256 };
 
-struct arcDisState 
+struct arcDisState
 {
   void *_this;
   int instructionLen;
@@ -50,7 +50,7 @@ struct arcDisState
   const char *(*auxRegName)(void*, int);
   const char *(*condCodeName)(void*, int);
   const char *(*instName)(void*, int, int, int*);
-  
+
   unsigned char* instruction;
   unsigned index;
   const char *comm[6]; /* instr name, cond, NOP, 3 operands  */
--- a/opcodes/arc-ext.h
+++ b/opcodes/arc-ext.h
@@ -30,20 +30,20 @@ enum {NUM_EXT_INST = (0x1f-0x10+1) + (0x3f-0x09+1)};
 enum {NUM_EXT_CORE = 59-32+1};
 enum {NUM_EXT_COND = 0x1f-0x10+1};
 
-struct ExtInstruction 
+struct ExtInstruction
 {
   char flags;
   char *name;
-}; 
+};
 
-struct ExtAuxRegister 
+struct ExtAuxRegister
 {
   long address;
   char *name;
-  struct ExtAuxRegister *next; 
+  struct ExtAuxRegister *next;
 };
 
-struct arcExtMap 
+struct arcExtMap
 {
   struct ExtAuxRegister *auxRegisters;
   struct ExtInstruction *instructions[NUM_EXT_INST];
--- a/opcodes/arm-dis.c
+++ b/opcodes/arm-dis.c
@@ -125,7 +125,7 @@ struct opcode16
    %<bitfield>'c	print specified char iff bitfield is all ones
    %<bitfield>`c	print specified char iff bitfield is all zeroes
    %<bitfield>?ab...    select from array of values in big endian order
-   
+
    %L			print as an iWMMXt N/M width field.
    %Z			print the Immediate of a WSHUFH instruction.
    %l			like 'A' except use byte offsets for 'B' & 'H'
@@ -920,7 +920,7 @@ static const struct opcode32 coprocessor_opcodes[] =
    %<bitfield>Sn	print byte scaled width limited by n
    %<bitfield>Tn	print short scaled width limited by n
    %<bitfield>Un	print long scaled width limited by n
-   
+
    %<bitfield>'c	print specified char iff bitfield is all ones
    %<bitfield>`c	print specified char iff bitfield is all zeroes
    %<bitfield>?ab...    select from array of values in big endian order.  */
@@ -1539,10 +1539,10 @@ static const struct opcode32 neon_opcodes[] =
    %<bitfield>{r|R}u    as %{r|R} but if matches the other %u field then is UNPREDICTABLE
    %<bitfield>{r|R}U    as %{r|R} but if matches the other %U field then is UNPREDICTABLE
    %<bitfield>d		print the bitfield in decimal
-   %<bitfield>W         print the bitfield plus one in decimal 
+   %<bitfield>W         print the bitfield plus one in decimal
    %<bitfield>x		print the bitfield in hex
    %<bitfield>X		print the bitfield as 1 hex digit without leading "0x"
-   
+
    %<bitfield>'c	print specified char iff bitfield is all ones
    %<bitfield>`c	print specified char iff bitfield is all zeroes
    %<bitfield>?ab...    select from array of values in big endian order
@@ -3084,8 +3084,8 @@ arm_decode_bitfield (const char *ptr,
 {
   unsigned long value = 0;
   int width = 0;
-  
-  do 
+
+  do
     {
       int start, end;
       int bits;
@@ -3310,7 +3310,7 @@ print_insn_coprocessor (bfd_vma pc,
 			func (stream, "\t; ");
 			/* For unaligned PCs, apply off-by-alignment
 			   correction.  */
-			info->print_address_func (offset + pc 
+			info->print_address_func (offset + pc
 						  + info->bytes_per_chunk * 2
 						  - (pc & 3),
 				 		  info);
@@ -3897,7 +3897,7 @@ print_insn_neon (struct disassemble_info *info, long given, bfd_boolean thumb)
       else
 	return FALSE;
     }
-  
+
   for (insn = neon_opcodes; insn->assembler; insn++)
     {
       if ((given & insn->mask) == insn->value)
@@ -3928,7 +3928,7 @@ print_insn_neon (struct disassemble_info *info, long given, bfd_boolean thumb)
 
 		    case 'A':
 		      {
-			static const unsigned char enc[16] = 
+			static const unsigned char enc[16] =
 			{
 			  0x4, 0x14, /* st4 0,1 */
 			  0x4, /* st1 2 */
@@ -3950,7 +3950,7 @@ print_insn_neon (struct disassemble_info *info, long given, bfd_boolean thumb)
 			int n = enc[type] & 0xf;
 			int stride = (enc[type] >> 4) + 1;
 			int ix;
-			
+
 			func (stream, "{");
 			if (stride > 1)
 			  for (ix = 0; ix != n; ix++)
@@ -3969,7 +3969,7 @@ print_insn_neon (struct disassemble_info *info, long given, bfd_boolean thumb)
 			  func (stream, ", %s", arm_regnames[rm]);
 		      }
 		      break;
-		      
+
 		    case 'B':
 		      {
 			int rd = ((given >> 12) & 0xf) | (((given >> 22) & 1) << 4);
@@ -3985,7 +3985,7 @@ print_insn_neon (struct disassemble_info *info, long given, bfd_boolean thumb)
 
                         if (length > 1 && size > 0)
                           stride = (idx_align & (1 << size)) ? 2 : 1;
-			
+
                         switch (length)
                           {
                           case 1:
@@ -4002,19 +4002,19 @@ print_insn_neon (struct disassemble_info *info, long given, bfd_boolean thumb)
                                 }
                               }
                             break;
-                          
+
                           case 2:
                             if (size == 2 && (idx_align & 2) != 0)
                               return FALSE;
                             align = (idx_align & 1) ? 16 << size : 0;
                             break;
-                          
+
                           case 3:
                             if ((size == 2 && (idx_align & 3) != 0)
                                 || (idx_align & 1) != 0)
                               return FALSE;
                             break;
-                          
+
                           case 4:
                             if (size == 2)
                               {
@@ -4025,11 +4025,11 @@ print_insn_neon (struct disassemble_info *info, long given, bfd_boolean thumb)
                             else
                               align = (idx_align & 1) ? 32 << size : 0;
                             break;
-                          
+
                           default:
                             abort ();
                           }
-                                
+
 			func (stream, "{");
                         for (i = 0; i < length; i++)
                           func (stream, "%sd%d[%d]", (i == 0) ? "" : ",",
@@ -4044,7 +4044,7 @@ print_insn_neon (struct disassemble_info *info, long given, bfd_boolean thumb)
 			  func (stream, ", %s", arm_regnames[rm]);
 		      }
 		      break;
-		      
+
 		    case 'C':
 		      {
 			int rd = ((given >> 12) & 0xf) | (((given >> 22) & 1) << 4);
@@ -4056,12 +4056,12 @@ print_insn_neon (struct disassemble_info *info, long given, bfd_boolean thumb)
 			int n = type + 1;
 			int stride = ((given >> 5) & 0x1);
 			int ix;
-			
+
 			if (stride && (n == 1))
 			  n++;
 			else
 			  stride++;
-			
+
 			func (stream, "{");
 			if (stride > 1)
 			  for (ix = 0; ix != n; ix++)
@@ -4088,18 +4088,18 @@ print_insn_neon (struct disassemble_info *info, long given, bfd_boolean thumb)
 			  func (stream, ", %s", arm_regnames[rm]);
 		      }
 		      break;
-		      
+
 		    case 'D':
 		      {
 			int raw_reg = (given & 0xf) | ((given >> 1) & 0x10);
 			int size = (given >> 20) & 3;
 			int reg = raw_reg & ((4 << size) - 1);
 			int ix = raw_reg >> size >> 2;
-			
+
 			func (stream, "d%d[%d]", reg, ix);
 		      }
 		      break;
-		      
+
 		    case 'E':
 		      /* Neon encoded constant for mov, mvn, vorr, vbic.  */
 		      {
@@ -4110,11 +4110,11 @@ print_insn_neon (struct disassemble_info *info, long given, bfd_boolean thumb)
 			unsigned shift;
                         int size = 0;
                         int isfloat = 0;
-			
+
 			bits |= ((given >> 24) & 1) << 7;
 			bits |= ((given >> 16) & 7) << 4;
 			bits |= ((given >> 0) & 15) << 0;
-			
+
 			if (cmode < 8)
 			  {
 			    shift = (cmode >> 1) & 3;
@@ -4141,7 +4141,7 @@ print_insn_neon (struct disassemble_info *info, long given, bfd_boolean thumb)
 				/* Bit replication into bytes.  */
 				int ix;
 				unsigned long mask;
-				
+
 				value = 0;
                                 hival = 0;
 				for (ix = 7; ix >= 0; ix--)
@@ -4165,7 +4165,7 @@ print_insn_neon (struct disassemble_info *info, long given, bfd_boolean thumb)
 			  {
 			    /* Floating point encoding.  */
 			    int tmp;
-			    
+
 			    value = (unsigned long)  (bits & 0x7f) << 19;
 			    value |= (unsigned long) (bits & 0x80) << 24;
 			    tmp = bits & 0x40 ? 0x3c : 0x40;
@@ -4185,7 +4185,7 @@ print_insn_neon (struct disassemble_info *info, long given, bfd_boolean thumb)
                           case 8:
 			    func (stream, "#%ld\t; 0x%.2lx", value, value);
                             break;
-                          
+
                           case 16:
                             func (stream, "#%ld\t; 0x%.4lx", value, value);
                             break;
@@ -4195,24 +4195,24 @@ print_insn_neon (struct disassemble_info *info, long given, bfd_boolean thumb)
                               {
                                 unsigned char valbytes[4];
                                 double fvalue;
-                                
+
                                 /* Do this a byte at a time so we don't have to
                                    worry about the host's endianness.  */
                                 valbytes[0] = value & 0xff;
                                 valbytes[1] = (value >> 8) & 0xff;
                                 valbytes[2] = (value >> 16) & 0xff;
                                 valbytes[3] = (value >> 24) & 0xff;
-                                
-                                floatformat_to_double 
+
+                                floatformat_to_double
                                   (& floatformat_ieee_single_little, valbytes,
                                   & fvalue);
-                                                                
+
                                 func (stream, "#%.7g\t; 0x%.8lx", fvalue,
                                       value);
                               }
                             else
                               func (stream, "#%ld\t; 0x%.8lx",
-				    (long) (((value & 0x80000000L) != 0) 
+				    (long) (((value & 0x80000000L) != 0)
 					    ? value | ~0xffffffffL : value),
 				    value);
                             break;
@@ -4220,18 +4220,18 @@ print_insn_neon (struct disassemble_info *info, long given, bfd_boolean thumb)
                           case 64:
                             func (stream, "#0x%.8lx%.8lx", hival, value);
                             break;
-                          
+
                           default:
                             abort ();
                           }
 		      }
 		      break;
-		      
+
 		    case 'F':
 		      {
 			int regno = ((given >> 16) & 0xf) | ((given >> (7 - 4)) & 0x10);
 			int num = (given >> 8) & 0x3;
-			
+
 			if (!num)
 			  func (stream, "{d%d}", regno);
 			else if (num + regno >= 32)
@@ -4249,7 +4249,7 @@ print_insn_neon (struct disassemble_info *info, long given, bfd_boolean thumb)
 			unsigned long value;
 
 			c = arm_decode_bitfield (c, given, &value, &width);
-			
+
 			switch (*c)
 			  {
 			  case 'r':
@@ -4262,7 +4262,7 @@ print_insn_neon (struct disassemble_info *info, long given, bfd_boolean thumb)
 			  case 'e':
 			    func (stream, "%ld", (1ul << width) - value);
 			    break;
-			    
+
 			  case 'S':
 			  case 'T':
 			  case 'U':
@@ -4302,7 +4302,7 @@ print_insn_neon (struct disassemble_info *info, long given, bfd_boolean thumb)
 			    else
 			      func (stream, "q%ld", value >> 1);
 			    break;
-			    
+
 			  case '`':
 			    c++;
 			    if (value == 0)
@@ -4345,20 +4345,20 @@ print_insn_neon (struct disassemble_info *info, long given, bfd_boolean thumb)
 
 /* Return the name of a v7A special register.  */
 
-static const char * 
+static const char *
 banked_regname (unsigned reg)
 {
   switch (reg)
     {
       case 15: return "CPSR";
-      case 32: return "R8_usr"; 
+      case 32: return "R8_usr";
       case 33: return "R9_usr";
       case 34: return "R10_usr";
       case 35: return "R11_usr";
       case 36: return "R12_usr";
       case 37: return "SP_usr";
       case 38: return "LR_usr";
-      case 40: return "R8_fiq"; 
+      case 40: return "R8_fiq";
       case 41: return "R9_fiq";
       case 42: return "R10_fiq";
       case 43: return "R11_fiq";
@@ -4739,7 +4739,7 @@ print_insn_arm (bfd_vma pc, struct disassemble_info *info, long given)
 			}
 		      else
 			{
-			  func (stream, "%cPSR_", 
+			  func (stream, "%cPSR_",
 				(given & 0x00400000) ? 'S' : 'C');
 			  if (given & 0x80000)
 			    func (stream, "f");
@@ -4753,7 +4753,7 @@ print_insn_arm (bfd_vma pc, struct disassemble_info *info, long given)
 		      break;
 
 		    case 'U':
-		      if ((given & 0xf0) == 0x60) 
+		      if ((given & 0xf0) == 0x60)
 			{
 			  switch (given & 0xf)
 			    {
@@ -4762,8 +4762,8 @@ print_insn_arm (bfd_vma pc, struct disassemble_info *info, long given)
 			      func (stream, "#%d", (int) given & 0xf);
 			      break;
 			    }
-			} 
-		      else 
+			}
+		      else
 			{
 			  const char * opt = data_barrier_option (given & 0xf);
 			  if (opt != NULL)
@@ -4780,7 +4780,7 @@ print_insn_arm (bfd_vma pc, struct disassemble_info *info, long given)
 			unsigned long value;
 
 			c = arm_decode_bitfield (c, given, &value, &width);
-			
+
 			switch (*c)
 			  {
 			  case 'R':
@@ -5317,7 +5317,7 @@ print_insn_thumb32 (bfd_vma pc, struct disassemble_info *info, long given)
 		  value_in_comment = imm;
 		}
 		break;
-		  
+
 	      case 'J':
 		{
 		  unsigned int imm = 0;
@@ -5647,7 +5647,7 @@ print_insn_thumb32 (bfd_vma pc, struct disassemble_info *info, long given)
 		break;
 
 	      case 'U':
-		if ((given & 0xf0) == 0x60) 
+		if ((given & 0xf0) == 0x60)
 		  {
 		    switch (given & 0xf)
 		      {
@@ -5657,7 +5657,7 @@ print_insn_thumb32 (bfd_vma pc, struct disassemble_info *info, long given)
 			      break;
 		      }
 		  }
-		else 
+		else
 		  {
 		    const char * opt = data_barrier_option (given & 0xf);
 		    if (opt != NULL)
@@ -5688,7 +5688,7 @@ print_insn_thumb32 (bfd_vma pc, struct disassemble_info *info, long given)
 		    sysm |= (given & 0x30);
 		    sysm |= (given & 0x00100000) >> 14;
 		    name = banked_regname (sysm);
-		    
+
 		    if (name != NULL)
 		      func (stream, "%s", name);
 		    else
@@ -5727,7 +5727,7 @@ print_insn_thumb32 (bfd_vma pc, struct disassemble_info *info, long given)
 		  unsigned long val;
 
 		  c = arm_decode_bitfield (c, given, &val, &width);
-			
+
 		  switch (*c)
 		    {
 		    case 'd':
@@ -5766,7 +5766,7 @@ print_insn_thumb32 (bfd_vma pc, struct disassemble_info *info, long given)
 		      if (val == ((1ul << width) - 1))
 			func (stream, "%c", *c);
 		      break;
-		      
+
 		    case '`':
 		      c++;
 		      if (val == 0)
@@ -5777,7 +5777,7 @@ print_insn_thumb32 (bfd_vma pc, struct disassemble_info *info, long given)
 		      func (stream, "%c", c[(1 << width) - (int) val]);
 		      c += 1 << width;
 		      break;
-		      
+
 		    case 'x':
 		      func (stream, "0x%lx", val & 0xffffffffUL);
 		      break;
@@ -5855,7 +5855,7 @@ arm_symbol_is_valid (asymbol * sym,
 		     struct disassemble_info * info ATTRIBUTE_UNUSED)
 {
   const char * name;
-  
+
   if (sym == NULL)
     return FALSE;
 
@@ -5918,7 +5918,7 @@ parse_disassembler_options (char *options)
 	++ options;
       /* Skip forward past seperators.  */
       while (ISSPACE (*options) || (*options == ','))
-	++ options;      
+	++ options;
     }
 }
 
@@ -6151,7 +6151,7 @@ print_insn (bfd_vma pc, struct disassemble_info *info, bfd_boolean little)
       if ((info->flags & USER_SPECIFIED_MACHINE_TYPE) == 0)
 	/* If the user did not use the -m command line switch then default to
 	   disassembling all types of ARM instruction.
-	   
+
 	   The info->mach value has to be ignored as this will be based on
 	   the default archictecture for the target and/or hints in the notes
 	   section, but it will never be greater than the current largest arm
#--- a/opcodes/avr-dis.c
#+++ b/opcodes/avr-dis.c
#@@ -62,7 +62,7 @@ avr_operand (unsigned int insn, unsigned int insn2, unsigned int pc, int constra
# 	insn = (insn & 0xf) | ((insn & 0x0200) >> 5); /* Source register.  */
#       else
# 	insn = (insn & 0x01f0) >> 4; /* Destination register.  */
#-      
#+
#       sprintf (buf, "r%d", insn);
#       break;
# 
#@@ -72,11 +72,11 @@ avr_operand (unsigned int insn, unsigned int insn2, unsigned int pc, int constra
#       else
# 	sprintf (buf, "r%d", 16 + ((insn & 0xf0) >> 4));
#       break;
#-      
#+
#     case 'w':
#       sprintf (buf, "r%d", 24 + ((insn & 0x30) >> 3));
#       break;
#-      
#+
#     case 'a':
#       if (regs)
# 	sprintf (buf, "r%d", 16 + (insn & 7));
#@@ -138,11 +138,11 @@ avr_operand (unsigned int insn, unsigned int insn2, unsigned int pc, int constra
#     case 'b':
#       {
# 	unsigned int x;
#-	
#+
# 	x = (insn & 7);
# 	x |= (insn >> 7) & (3 << 3);
# 	x |= (insn >> 8) & (1 << 5);
#-	
#+
# 	if (insn & 0x8)
# 	  *buf++ = 'Y';
# 	else
#@@ -151,17 +151,17 @@ avr_operand (unsigned int insn, unsigned int insn2, unsigned int pc, int constra
# 	sprintf (comment, "0x%02x", x);
#       }
#       break;
#-      
#+
#     case 'h':
#       *sym = 1;
#       *sym_addr = ((((insn & 1) | ((insn & 0x1f0) >> 3)) << 16) | insn2) * 2;
#       /* See PR binutils/2454.  Ideally we would like to display the hex
# 	 value of the address only once, but this would mean recoding
# 	 objdump_print_address() which would affect many targets.  */
#-      sprintf (buf, "%#lx", (unsigned long) *sym_addr);      
#+      sprintf (buf, "%#lx", (unsigned long) *sym_addr);
#       strcpy (comment, comment_start);
#       break;
#-      
#+
#     case 'L':
#       {
# 	int rel_addr = (((insn & 0xfff) ^ 0x800) - 0x800) * 2;
#@@ -197,7 +197,7 @@ avr_operand (unsigned int insn, unsigned int insn2, unsigned int pc, int constra
#         sprintf (buf, "%d", val);
#       }
#       break;
#-      
#+
#     case 'M':
#       sprintf (buf, "0x%02X", ((insn & 0xf00) >> 4) | (insn & 0xf));
#       sprintf (comment, "%d", ((insn & 0xf00) >> 4) | (insn & 0xf));
#@@ -208,7 +208,7 @@ avr_operand (unsigned int insn, unsigned int insn2, unsigned int pc, int constra
#       fprintf (stderr, _("Internal disassembler error"));
#       ok = 0;
#       break;
#-      
#+
#     case 'K':
#       {
# 	unsigned int x;
#@@ -218,15 +218,15 @@ avr_operand (unsigned int insn, unsigned int insn2, unsigned int pc, int constra
# 	sprintf (comment, "%d", x);
#       }
#       break;
#-      
#+
#     case 's':
#       sprintf (buf, "%d", insn & 7);
#       break;
#-      
#+
#     case 'S':
#       sprintf (buf, "%d", (insn >> 4) & 7);
#       break;
#-      
#+
#     case 'P':
#       {
# 	unsigned int x;
#@@ -241,21 +241,21 @@ avr_operand (unsigned int insn, unsigned int insn2, unsigned int pc, int constra
#     case 'p':
#       {
# 	unsigned int x;
#-	
#+
# 	x = (insn >> 3) & 0x1f;
# 	sprintf (buf, "0x%02x", x);
# 	sprintf (comment, "%d", x);
#       }
#       break;
#-      
#+
#     case 'E':
#       sprintf (buf, "%d", (insn >> 4) & 15);
#       break;
#-      
#+
#     case '?':
#       *buf = '\0';
#       break;
#-      
#+
#     default:
#       sprintf (buf, "??");
#       fprintf (stderr, _("unknown constraint `%c'"), constraint);
#@@ -309,7 +309,7 @@ print_insn_avr (bfd_vma addr, disassemble_info *info)
# 	comment_start = " ";
# 
#       nopcodes = sizeof (avr_opcodes) / sizeof (struct avr_opcodes_s);
#-      
#+
#       avr_bin_masks = xmalloc (nopcodes * sizeof (unsigned int));
# 
#       for (opcode = avr_opcodes, maskptr = avr_bin_masks;
#@@ -319,7 +319,7 @@ print_insn_avr (bfd_vma addr, disassemble_info *info)
# 	  char * s;
# 	  unsigned int bin = 0;
# 	  unsigned int mask = 0;
#-	
#+
# 	  for (s = opcode->opcode; *s; ++s)
# 	    {
# 	      bin <<= 1;
#@@ -336,7 +336,7 @@ print_insn_avr (bfd_vma addr, disassemble_info *info)
#     }
# 
#   insn = avrdis_opcode (addr, info);
#-  
#+
#   for (opcode = avr_opcodes, maskptr = avr_bin_masks;
#        opcode->name;
#        opcode++, maskptr++)
#@@ -346,7 +346,7 @@ print_insn_avr (bfd_vma addr, disassemble_info *info)
#       if ((insn & *maskptr) == opcode->bin_opcode)
#         break;
#     }
#-  
#+
#   /* Special case: disassemble `ldd r,b+0' as `ld r,b', and
#      `std b+0,r' as `st b,r' (next entry in the table).  */
# 
--- a/opcodes/cgen-asm.c
+++ b/opcodes/cgen-asm.c
@@ -212,7 +212,7 @@ cgen_parse_keyword (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
      character of the suffix ('.') is special.  */
   if (*p)
     ++p;
-  
+
   /* Allow letters, digits, and any special characters.  */
   while (((p - start) < (int) sizeof (buf))
 	 && *p
--- a/opcodes/cgen-asm.in
+++ b/opcodes/cgen-asm.in
@@ -60,9 +60,9 @@ static const char * parse_insn_normal
 
    Returns NULL for success, an error message for failure.  */
 
-char * 
+char *
 @arch@_cgen_build_insn_regex (CGEN_INSN *insn)
-{  
+{
   CGEN_OPCODE *opc = (CGEN_OPCODE *) CGEN_INSN_OPCODE (insn);
   const char *mnem = CGEN_INSN_MNEMONIC (insn);
   char rxbuf[CGEN_MAX_RX_ELEMENTS];
@@ -101,18 +101,18 @@ char *
   /* Copy any remaining literals from the syntax string into the rx.  */
   for(; * syn != 0 && rx <= rxbuf + (CGEN_MAX_RX_ELEMENTS - 7 - 4); ++syn)
     {
-      if (CGEN_SYNTAX_CHAR_P (* syn)) 
+      if (CGEN_SYNTAX_CHAR_P (* syn))
 	{
 	  char c = CGEN_SYNTAX_CHAR (* syn);
 
-	  switch (c) 
+	  switch (c)
 	    {
 	      /* Escape any regex metacharacters in the syntax.  */
-	    case '.': case '[': case '\\': 
-	    case '*': case '^': case '$': 
+	    case '.': case '[': case '\\':
+	    case '*': case '^': case '$':
 
 #ifdef CGEN_ESCAPE_EXTENDED_REGEX
-	    case '?': case '{': case '}': 
+	    case '?': case '{': case '}':
 	    case '(': case ')': case '*':
 	    case '|': case '+': case ']':
 #endif
@@ -142,20 +142,20 @@ char *
     }
 
   /* Trailing whitespace ok.  */
-  * rx++ = '['; 
-  * rx++ = ' '; 
-  * rx++ = '\t'; 
-  * rx++ = ']'; 
-  * rx++ = '*'; 
+  * rx++ = '[';
+  * rx++ = ' ';
+  * rx++ = '\t';
+  * rx++ = ']';
+  * rx++ = '*';
 
   /* But anchor it after that.  */
-  * rx++ = '$'; 
+  * rx++ = '$';
   * rx = '\0';
 
   CGEN_INSN_RX (insn) = xmalloc (sizeof (regex_t));
   reg_err = regcomp ((regex_t *) CGEN_INSN_RX (insn), rxbuf, REG_NOSUB);
 
-  if (reg_err == 0) 
+  if (reg_err == 0)
     return NULL;
   else
     {
@@ -354,7 +354,7 @@ const CGEN_INSN *
       const CGEN_INSN *insn = ilist->insn;
       recognized_mnemonic = 1;
 
-#ifdef CGEN_VALIDATE_INSN_SUPPORTED 
+#ifdef CGEN_VALIDATE_INSN_SUPPORTED
       /* Not usually needed as unsupported opcodes
 	 shouldn't be in the hash lists.  */
       /* Is this insn supported by the selected cpu?  */
@@ -414,7 +414,7 @@ const CGEN_INSN *
 	if (strlen (start) > 50)
 	  /* xgettext:c-format */
 	  sprintf (errbuf, "%s `%.50s...'", tmp_errmsg, start);
-	else 
+	else
 	  /* xgettext:c-format */
 	  sprintf (errbuf, "%s `%.50s'", tmp_errmsg, start);
       }
@@ -423,11 +423,11 @@ const CGEN_INSN *
 	if (strlen (start) > 50)
 	  /* xgettext:c-format */
 	  sprintf (errbuf, _("bad instruction `%.50s...'"), start);
-	else 
+	else
 	  /* xgettext:c-format */
 	  sprintf (errbuf, _("bad instruction `%.50s'"), start);
       }
-      
+
     *errmsg = errbuf;
     return NULL;
   }
--- a/opcodes/cgen-dis.c
+++ b/opcodes/cgen-dis.c
@@ -49,7 +49,7 @@ count_decodable_bits (const CGEN_INSN *insn)
   return bits;
 }
 
-/* Add an instruction to the hash chain.  */     
+/* Add an instruction to the hash chain.  */
 static void
 add_insn_to_hash_chain (CGEN_INSN_LIST *hentbuf,
 			const CGEN_INSN *insn,
--- a/opcodes/cgen-dis.in
+++ b/opcodes/cgen-dis.in
@@ -231,7 +231,7 @@ print_insn (CGEN_CPU_DESC cd,
       int length;
       unsigned long insn_value_cropped;
 
-#ifdef CGEN_VALIDATE_INSN_SUPPORTED 
+#ifdef CGEN_VALIDATE_INSN_SUPPORTED
       /* Not needed as insn shouldn't be in hash lists if not supported.  */
       /* Supported by this cpu?  */
       if (! @arch@_cgen_insn_supported (cd, insn))
@@ -249,7 +249,7 @@ print_insn (CGEN_CPU_DESC cd,
          relevant part from the buffer. */
       if ((unsigned) (CGEN_INSN_BITSIZE (insn) / 8) < buflen &&
 	  (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
-	insn_value_cropped = bfd_get_bits (buf, CGEN_INSN_BITSIZE (insn), 
+	insn_value_cropped = bfd_get_bits (buf, CGEN_INSN_BITSIZE (insn),
 					   info->endian == BFD_ENDIAN_BIG);
       else
 	insn_value_cropped = insn_value;
@@ -368,7 +368,7 @@ print_insn_@arch@ (bfd_vma pc, disassemble_info *info)
   arch = info->arch;
   if (arch == bfd_arch_unknown)
     arch = CGEN_BFD_ARCH;
-   
+
   /* There's no standard way to compute the machine or isa number
      so we leave it to the target.  */
 #ifdef CGEN_COMPUTE_MACH
@@ -409,7 +409,7 @@ print_insn_@arch@ (bfd_vma pc, disassemble_info *info)
 	      break;
 	    }
 	}
-    } 
+    }
 
   /* If we haven't initialized yet, initialize the opcode table.  */
   if (! cd)
--- a/opcodes/cgen-ibld.in
+++ b/opcodes/cgen-ibld.in
@@ -154,7 +154,7 @@ insert_normal (CGEN_CPU_DESC cd,
     {
       long minval = - (1L << (length - 1));
       unsigned long maxval = mask;
-      
+
       if ((value > 0 && (unsigned long) value > maxval)
 	  || value < minval)
 	{
@@ -192,7 +192,7 @@ insert_normal (CGEN_CPU_DESC cd,
 	{
 	  long minval = - (1L << (length - 1));
 	  long maxval =   (1L << (length - 1)) - 1;
-	  
+
 	  if (value < minval || value > maxval)
 	    {
 	      sprintf
--- a/opcodes/cgen-opc.c
+++ b/opcodes/cgen-opc.c
@@ -127,7 +127,7 @@ cgen_keyword_add (CGEN_KEYWORD *kt, CGEN_KEYWORD_ENTRY *ke)
 	&& ! strchr (kt->nonalpha_chars, ke->name[i]))
       {
 	size_t idx = strlen (kt->nonalpha_chars);
-	
+
 	/* If you hit this limit, please don't just
 	   increase the size of the field, instead
 	   look for a better algorithm.  */
@@ -369,7 +369,7 @@ cgen_get_insn_value (CGEN_CPU_DESC cd, unsigned char *buf, int length)
 	 segments, and endian-convert them, one at a time. */
       int i;
 
-      /* Enforce divisibility. */ 
+      /* Enforce divisibility. */
       if ((length % insn_chunk_bitsize) != 0)
 	abort ();
 
@@ -408,7 +408,7 @@ cgen_put_insn_value (CGEN_CPU_DESC cd,
 	 segments, and endian-convert them, one at a time. */
       int i;
 
-      /* Enforce divisibility. */ 
+      /* Enforce divisibility. */
       if ((length % insn_chunk_bitsize) != 0)
 	abort ();
 
--- a/opcodes/cgen.sh
+++ b/opcodes/cgen.sh
@@ -26,7 +26,7 @@
 # cgen.sh action srcdir cgen cgendir cgenflags arch prefix \
 #         arch-file opc-file options [extrafiles]
 #
-# ACTION is currently always "opcodes". It exists to be consistent with the 
+# ACTION is currently always "opcodes". It exists to be consistent with the
 # simulator.
 # ARCH is the name of the architecture.
 # It is substituted into @arch@ and @ARCH@ in the generated files.
#--- a/opcodes/configure.ac
#+++ b/opcodes/configure.ac
#@@ -6,12 +6,12 @@ dnl This file is free software; you can redistribute it and/or modify
# dnl it under the terms of the GNU General Public License as published by
# dnl the Free Software Foundation; either version 3 of the License, or
# dnl (at your option) any later version.
#-dnl 
#+dnl
# dnl This program is distributed in the hope that it will be useful,
# dnl but WITHOUT ANY WARRANTY; without even the implied warranty of
# dnl MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# dnl GNU General Public License for more details.
#-dnl 
#+dnl
# dnl You should have received a copy of the GNU General Public License
# dnl along with this program; see the file COPYING3.  If not see
# dnl <http://www.gnu.org/licenses/>.
#@@ -234,7 +234,7 @@ do
# 	. $srcdir/../bfd/config.bfd
# 	selarchs="$selarchs $targ_archs"
#     fi
#-done	
#+done
# 
# # Utility var, documents generic cgen support files.
# 
--- a/opcodes/configure.com
+++ b/opcodes/configure.com
@@ -12,12 +12,12 @@ $! This file is free software; you can redistribute it and/or modify
 $! it under the terms of the GNU General Public License as published by
 $! the Free Software Foundation; either version 3 of the License, or
 $! (at your option) any later version.
-$! 
+$!
 $! This program is distributed in the hope that it will be useful,
 $! but WITHOUT ANY WARRANTY; without even the implied warranty of
 $! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 $! GNU General Public License for more details.
-$! 
+$!
 $! You should have received a copy of the GNU General Public License
 $! along with this program; see the file COPYING3.  If not see
 $! <http://www.gnu.org/licenses/>.
--- a/opcodes/cr16-dis.c
+++ b/opcodes/cr16-dis.c
@@ -358,7 +358,7 @@ make_argument (argument * a, int start_bits)
   switch (a->type)
     {
     case arg_r:
-      p = makelongparameter (cr16_allWords, 
+      p = makelongparameter (cr16_allWords,
 			     inst_bit_size - (start_bits + a->size),
 			     inst_bit_size - start_bits);
       a->r = p.val;
@@ -386,7 +386,7 @@ make_argument (argument * a, int start_bits)
       break;
 
     case arg_ic:
-      p = makelongparameter (cr16_allWords, 
+      p = makelongparameter (cr16_allWords,
 			     inst_bit_size - (start_bits + a->size),
 			     inst_bit_size - start_bits);
       a->constant = p.val;
@@ -466,7 +466,7 @@ make_argument (argument * a, int start_bits)
 	}
       else if (instruction->size == 2)
 	{
-	  p = makelongparameter (cr16_allWords, inst_bit_size - 16, 
+	  p = makelongparameter (cr16_allWords, inst_bit_size - 16,
 				 inst_bit_size);
 	  a->constant = p.val;
 	}
@@ -795,7 +795,7 @@ get_words_at_PC (bfd_vma memaddr, struct disassemble_info *info)
   for (i = 0, mem = memaddr; i < 3; i++, mem += 2)
     cr16_words[i] = get_word_at_PC (mem, info);
 
-  cr16_allWords =  ((ULONGLONG) cr16_words[0] << 32) 
+  cr16_allWords =  ((ULONGLONG) cr16_words[0] << 32)
 		   + ((unsigned long) cr16_words[1] << 16) + cr16_words[2];
 }
 
--- a/opcodes/cris-dis.c
+++ b/opcodes/cris-dis.c
@@ -813,7 +813,7 @@ print_with_operands (const struct cris_opcode *opcodep,
 	*tp++ = 'c';
 	*tp++ = 'r';
 	break;
-	
+
       case '[':
       case ']':
       case ',':
--- a/opcodes/crx-dis.c
+++ b/opcodes/crx-dis.c
@@ -60,9 +60,9 @@ cinv_entry;
 /* CRX 'cinv' options.  */
 const cinv_entry crx_cinvs[] =
 {
-  {"[i]", 2}, {"[i,u]", 3}, {"[d]", 4}, {"[d,u]", 5}, 
-  {"[d,i]", 6}, {"[d,i,u]", 7}, {"[b]", 8}, 
-  {"[b,i]", 10}, {"[b,i,u]", 11}, {"[b,d]", 12}, 
+  {"[i]", 2}, {"[i,u]", 3}, {"[d]", 4}, {"[d,u]", 5},
+  {"[d,i]", 6}, {"[d,i,u]", 7}, {"[b]", 8},
+  {"[b,i]", 10}, {"[b,i,u]", 11}, {"[b,d]", 12},
   {"[b,d,u]", 13}, {"[b,d,i]", 14}, {"[b,d,i,u]", 15}
 };
 
@@ -76,7 +76,7 @@ typedef enum REG_ARG_TYPE
     /* CO-Processor register (c<N>).  */
     COP_ARG,
     /* CO-Processor special register (cs<N>).  */
-    COPS_ARG 
+    COPS_ARG
   }
 REG_ARG_TYPE;
 
@@ -534,8 +534,8 @@ print_arg (argument *a, bfd_vma memaddr, struct disassemble_info *info)
 
       else if (INST_HAS_REG_LIST)
         {
-	  REG_ARG_TYPE reg_arg_type = IS_INSN_TYPE (COP_REG_INS) ? 
-				 COP_ARG : IS_INSN_TYPE (COPS_REG_INS) ? 
+	  REG_ARG_TYPE reg_arg_type = IS_INSN_TYPE (COP_REG_INS) ?
+				 COP_ARG : IS_INSN_TYPE (COPS_REG_INS) ?
 				 COPS_ARG : (instruction->flags & USER_REG) ?
 				 USER_REG_ARG : REG_ARG;
 
#--- a/opcodes/d10v-opc.c
#+++ b/opcodes/d10v-opc.c
#@@ -89,7 +89,7 @@ const struct pd_reg d10v_predefined_registers[] =
#   { "sp", NULL, OPERAND_SP|(OPERAND_GPR+15) },
# };
# 
#-int 
#+int
# d10v_reg_name_cnt (void)
# {
#   return (sizeof(d10v_predefined_registers) / sizeof(struct pd_reg));
--- a/opcodes/d30v-opc.c
+++ b/opcodes/d30v-opc.c
@@ -194,7 +194,7 @@ const struct pd_reg pre_defined_registers[] =
   { "va", NULL, OPERAND_FLAG + 6 },
 };
 
-int 
+int
 reg_name_cnt (void)
 {
   return sizeof (pre_defined_registers) / sizeof (struct pd_reg);
--- a/opcodes/dis-buf.c
+++ b/opcodes/dis-buf.c
@@ -33,7 +33,7 @@ buffer_read_memory (bfd_vma memaddr,
 {
   unsigned int opb = info->octets_per_byte;
   unsigned int end_addr_offset = length / opb;
-  unsigned int max_addr_offset = info->buffer_length / opb; 
+  unsigned int max_addr_offset = info->buffer_length / opb;
   unsigned int octets = (memaddr - info->buffer_vma) * opb;
 
   if (memaddr < info->buffer_vma
--- a/opcodes/dlx-dis.c
+++ b/opcodes/dlx-dis.c
@@ -295,7 +295,7 @@ dlx_aluI_type (struct disassemble_info* info)
     { OPC(SGTUIOP),  "sgtui" },  /* Store word.      */
     { OPC(SLEUIOP),  "sleui" },  /* Store word.      */
     { OPC(SGEUIOP),  "sgeui" },  /* Store word.      */
-#if 0						       
+#if 0
     { OPC(MVTSOP),   "mvts"  },  /* Store word.      */
     { OPC(MVFSOP),   "mvfs"  },  /* Store word.      */
 #endif
--- a/opcodes/epiphany-asm.c
+++ b/opcodes/epiphany-asm.c
@@ -458,7 +458,7 @@ epiphany_cgen_parse_operand (CGEN_CPU_DESC cd,
   return errmsg;
 }
 
-cgen_parse_fn * const epiphany_cgen_parse_handlers[] = 
+cgen_parse_fn * const epiphany_cgen_parse_handlers[] =
 {
   parse_insn_normal,
 };
@@ -488,9 +488,9 @@ CGEN_ASM_INIT_HOOK
 
    Returns NULL for success, an error message for failure.  */
 
-char * 
+char *
 epiphany_cgen_build_insn_regex (CGEN_INSN *insn)
-{  
+{
   CGEN_OPCODE *opc = (CGEN_OPCODE *) CGEN_INSN_OPCODE (insn);
   const char *mnem = CGEN_INSN_MNEMONIC (insn);
   char rxbuf[CGEN_MAX_RX_ELEMENTS];
@@ -529,18 +529,18 @@ epiphany_cgen_build_insn_regex (CGEN_INSN *insn)
   /* Copy any remaining literals from the syntax string into the rx.  */
   for(; * syn != 0 && rx <= rxbuf + (CGEN_MAX_RX_ELEMENTS - 7 - 4); ++syn)
     {
-      if (CGEN_SYNTAX_CHAR_P (* syn)) 
+      if (CGEN_SYNTAX_CHAR_P (* syn))
 	{
 	  char c = CGEN_SYNTAX_CHAR (* syn);
 
-	  switch (c) 
+	  switch (c)
 	    {
 	      /* Escape any regex metacharacters in the syntax.  */
-	    case '.': case '[': case '\\': 
-	    case '*': case '^': case '$': 
+	    case '.': case '[': case '\\':
+	    case '*': case '^': case '$':
 
 #ifdef CGEN_ESCAPE_EXTENDED_REGEX
-	    case '?': case '{': case '}': 
+	    case '?': case '{': case '}':
 	    case '(': case ')': case '*':
 	    case '|': case '+': case ']':
 #endif
@@ -570,20 +570,20 @@ epiphany_cgen_build_insn_regex (CGEN_INSN *insn)
     }
 
   /* Trailing whitespace ok.  */
-  * rx++ = '['; 
-  * rx++ = ' '; 
-  * rx++ = '\t'; 
-  * rx++ = ']'; 
-  * rx++ = '*'; 
+  * rx++ = '[';
+  * rx++ = ' ';
+  * rx++ = '\t';
+  * rx++ = ']';
+  * rx++ = '*';
 
   /* But anchor it after that.  */
-  * rx++ = '$'; 
+  * rx++ = '$';
   * rx = '\0';
 
   CGEN_INSN_RX (insn) = xmalloc (sizeof (regex_t));
   reg_err = regcomp ((regex_t *) CGEN_INSN_RX (insn), rxbuf, REG_NOSUB);
 
-  if (reg_err == 0) 
+  if (reg_err == 0)
     return NULL;
   else
     {
@@ -782,7 +782,7 @@ epiphany_cgen_assemble_insn (CGEN_CPU_DESC cd,
       const CGEN_INSN *insn = ilist->insn;
       recognized_mnemonic = 1;
 
-#ifdef CGEN_VALIDATE_INSN_SUPPORTED 
+#ifdef CGEN_VALIDATE_INSN_SUPPORTED
       /* Not usually needed as unsupported opcodes
 	 shouldn't be in the hash lists.  */
       /* Is this insn supported by the selected cpu?  */
@@ -842,7 +842,7 @@ epiphany_cgen_assemble_insn (CGEN_CPU_DESC cd,
 	if (strlen (start) > 50)
 	  /* xgettext:c-format */
 	  sprintf (errbuf, "%s `%.50s...'", tmp_errmsg, start);
-	else 
+	else
 	  /* xgettext:c-format */
 	  sprintf (errbuf, "%s `%.50s'", tmp_errmsg, start);
       }
@@ -851,11 +851,11 @@ epiphany_cgen_assemble_insn (CGEN_CPU_DESC cd,
 	if (strlen (start) > 50)
 	  /* xgettext:c-format */
 	  sprintf (errbuf, _("bad instruction `%.50s...'"), start);
-	else 
+	else
 	  /* xgettext:c-format */
 	  sprintf (errbuf, _("bad instruction `%.50s'"), start);
       }
-      
+
     *errmsg = errbuf;
     return NULL;
   }
--- a/opcodes/epiphany-desc.c
+++ b/opcodes/epiphany-desc.c
@@ -534,367 +534,367 @@ const CGEN_OPERAND epiphany_cgen_operand_table[] =
 {
 /* pc: program counter */
   { "pc", EPIPHANY_OPERAND_PC, HW_H_PC, 0, 0,
-    { 0, { (const PTR) &epiphany_cgen_ifld_table[EPIPHANY_F_NIL] } }, 
+    { 0, { (const PTR) &epiphany_cgen_ifld_table[EPIPHANY_F_NIL] } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* zbit: integer zero bit */
   { "zbit", EPIPHANY_OPERAND_ZBIT, HW_H_ZBIT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* nbit: integer neg bit */
   { "nbit", EPIPHANY_OPERAND_NBIT, HW_H_NBIT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* cbit: integer carry bit */
   { "cbit", EPIPHANY_OPERAND_CBIT, HW_H_CBIT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* vbit: integer overflow bit */
   { "vbit", EPIPHANY_OPERAND_VBIT, HW_H_VBIT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* bzbit: floating point zero bit */
   { "bzbit", EPIPHANY_OPERAND_BZBIT, HW_H_BZBIT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* bnbit: floating point neg bit */
   { "bnbit", EPIPHANY_OPERAND_BNBIT, HW_H_BNBIT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* bvbit: floating point ovfl bit */
   { "bvbit", EPIPHANY_OPERAND_BVBIT, HW_H_BVBIT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* bcbit: floating point carry bit */
   { "bcbit", EPIPHANY_OPERAND_BCBIT, HW_H_BCBIT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* bubit: floating point underfl bit */
   { "bubit", EPIPHANY_OPERAND_BUBIT, HW_H_BUBIT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* bibit: floating point invalid bit */
   { "bibit", EPIPHANY_OPERAND_BIBIT, HW_H_BIBIT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* vsbit: integer overflow sticky */
   { "vsbit", EPIPHANY_OPERAND_VSBIT, HW_H_VSBIT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* bvsbit: floating point overflow sticky */
   { "bvsbit", EPIPHANY_OPERAND_BVSBIT, HW_H_BVSBIT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* bisbit: floating point invalid sticky */
   { "bisbit", EPIPHANY_OPERAND_BISBIT, HW_H_BISBIT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* busbit: floating point underflow sticky */
   { "busbit", EPIPHANY_OPERAND_BUSBIT, HW_H_BUSBIT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* expcause0bit: exceprion cause bit0 */
   { "expcause0bit", EPIPHANY_OPERAND_EXPCAUSE0BIT, HW_H_EXPCAUSE0BIT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* expcause1bit: exceprion cause bit1 */
   { "expcause1bit", EPIPHANY_OPERAND_EXPCAUSE1BIT, HW_H_EXPCAUSE1BIT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* expcause2bit: external load stalled bit */
   { "expcause2bit", EPIPHANY_OPERAND_EXPCAUSE2BIT, HW_H_EXPCAUSE2BIT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* extFstallbit: external fetch stalled bit */
   { "extFstallbit", EPIPHANY_OPERAND_EXTFSTALLBIT, HW_H_EXTFSTALLBIT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* trmbit: 0=round to nearest, 1=trunacte selct bit */
   { "trmbit", EPIPHANY_OPERAND_TRMBIT, HW_H_TRMBIT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* invExcEnbit: invalid exception enable bit */
   { "invExcEnbit", EPIPHANY_OPERAND_INVEXCENBIT, HW_H_INVEXCENBIT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* ovfExcEnbit: overflow exception enable bit */
   { "ovfExcEnbit", EPIPHANY_OPERAND_OVFEXCENBIT, HW_H_OVFEXCENBIT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* unExcEnbit: underflow exception enable bit */
   { "unExcEnbit", EPIPHANY_OPERAND_UNEXCENBIT, HW_H_UNEXCENBIT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* timer0bit0: timer 0 mode selection 0 */
   { "timer0bit0", EPIPHANY_OPERAND_TIMER0BIT0, HW_H_TIMER0BIT0, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* timer0bit1: timer 0 mode selection 1 */
   { "timer0bit1", EPIPHANY_OPERAND_TIMER0BIT1, HW_H_TIMER0BIT1, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* timer0bit2: timer 0 mode selection 2 */
   { "timer0bit2", EPIPHANY_OPERAND_TIMER0BIT2, HW_H_TIMER0BIT2, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* timer0bit3: timer 0 mode selection 3 */
   { "timer0bit3", EPIPHANY_OPERAND_TIMER0BIT3, HW_H_TIMER0BIT3, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* timer1bit0: timer 1 mode selection 0 */
   { "timer1bit0", EPIPHANY_OPERAND_TIMER1BIT0, HW_H_TIMER1BIT0, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* timer1bit1: timer 1 mode selection 1 */
   { "timer1bit1", EPIPHANY_OPERAND_TIMER1BIT1, HW_H_TIMER1BIT1, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* timer1bit2: timer 1 mode selection 2 */
   { "timer1bit2", EPIPHANY_OPERAND_TIMER1BIT2, HW_H_TIMER1BIT2, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* timer1bit3: timer 1 mode selection 3 */
   { "timer1bit3", EPIPHANY_OPERAND_TIMER1BIT3, HW_H_TIMER1BIT3, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* mbkptEnbit: multicore bkpt enable */
   { "mbkptEnbit", EPIPHANY_OPERAND_MBKPTENBIT, HW_H_MBKPTENBIT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* clockGateEnbit: clock gate enable enable */
   { "clockGateEnbit", EPIPHANY_OPERAND_CLOCKGATEENBIT, HW_H_CLOCKGATEENBIT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* arithmetic-modebit0: arithmetic mode bit0 */
   { "arithmetic-modebit0", EPIPHANY_OPERAND_ARITHMETIC_MODEBIT0, HW_H_ARITHMETIC_MODEBIT0, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* arithmetic-modebit1: arithmetic mode bit1 */
   { "arithmetic-modebit1", EPIPHANY_OPERAND_ARITHMETIC_MODEBIT1, HW_H_ARITHMETIC_MODEBIT1, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* arithmetic-modebit2: arithmetic mode bit2 */
   { "arithmetic-modebit2", EPIPHANY_OPERAND_ARITHMETIC_MODEBIT2, HW_H_ARITHMETIC_MODEBIT2, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* coreCfgResBit12: core config bit 12 */
   { "coreCfgResBit12", EPIPHANY_OPERAND_CORECFGRESBIT12, HW_H_CORECFGRESBIT12, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* coreCfgResBit13: core config bit 13 */
   { "coreCfgResBit13", EPIPHANY_OPERAND_CORECFGRESBIT13, HW_H_CORECFGRESBIT13, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* coreCfgResBit14: core config bit 14 */
   { "coreCfgResBit14", EPIPHANY_OPERAND_CORECFGRESBIT14, HW_H_CORECFGRESBIT14, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* coreCfgResBit15: core config bit 15 */
   { "coreCfgResBit15", EPIPHANY_OPERAND_CORECFGRESBIT15, HW_H_CORECFGRESBIT15, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* coreCfgResBit16: core config bit 16 */
   { "coreCfgResBit16", EPIPHANY_OPERAND_CORECFGRESBIT16, HW_H_CORECFGRESBIT16, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* coreCfgResBit20: core config bit 20 */
   { "coreCfgResBit20", EPIPHANY_OPERAND_CORECFGRESBIT20, HW_H_CORECFGRESBIT20, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* coreCfgResBit21: core config bit 21 */
   { "coreCfgResBit21", EPIPHANY_OPERAND_CORECFGRESBIT21, HW_H_CORECFGRESBIT21, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* coreCfgResBit24: core config bit 24 */
   { "coreCfgResBit24", EPIPHANY_OPERAND_CORECFGRESBIT24, HW_H_CORECFGRESBIT24, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* coreCfgResBit25: core config bit 25 */
   { "coreCfgResBit25", EPIPHANY_OPERAND_CORECFGRESBIT25, HW_H_CORECFGRESBIT25, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* coreCfgResBit26: core config bit 26 */
   { "coreCfgResBit26", EPIPHANY_OPERAND_CORECFGRESBIT26, HW_H_CORECFGRESBIT26, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* coreCfgResBit27: core config bit 27 */
   { "coreCfgResBit27", EPIPHANY_OPERAND_CORECFGRESBIT27, HW_H_CORECFGRESBIT27, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* coreCfgResBit28: core config bit 28 */
   { "coreCfgResBit28", EPIPHANY_OPERAND_CORECFGRESBIT28, HW_H_CORECFGRESBIT28, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* coreCfgResBit29: core config bit 29 */
   { "coreCfgResBit29", EPIPHANY_OPERAND_CORECFGRESBIT29, HW_H_CORECFGRESBIT29, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* coreCfgResBit30: core config bit 30 */
   { "coreCfgResBit30", EPIPHANY_OPERAND_CORECFGRESBIT30, HW_H_CORECFGRESBIT30, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* coreCfgResBit31: core config bit 31 */
   { "coreCfgResBit31", EPIPHANY_OPERAND_CORECFGRESBIT31, HW_H_CORECFGRESBIT31, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* gidisablebit: global interrupt disable bit */
   { "gidisablebit", EPIPHANY_OPERAND_GIDISABLEBIT, HW_H_GIDISABLEBIT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* kmbit: kernel mode bit */
   { "kmbit", EPIPHANY_OPERAND_KMBIT, HW_H_KMBIT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* caibit: core actibe indicator bit */
   { "caibit", EPIPHANY_OPERAND_CAIBIT, HW_H_CAIBIT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* sflagbit: sflag bit */
   { "sflagbit", EPIPHANY_OPERAND_SFLAGBIT, HW_H_SFLAGBIT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* memaddr: memory effective address */
   { "memaddr", EPIPHANY_OPERAND_MEMADDR, HW_H_MEMADDR, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* simm24: branch address pc-relative */
   { "simm24", EPIPHANY_OPERAND_SIMM24, HW_H_IADDR, 31, 24,
-    { 0, { (const PTR) &epiphany_cgen_ifld_table[EPIPHANY_F_SIMM24] } }, 
+    { 0, { (const PTR) &epiphany_cgen_ifld_table[EPIPHANY_F_SIMM24] } },
     { 0|A(RELAX)|A(RELOC)|A(PCREL_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
 /* simm8: branch address pc-relative */
   { "simm8", EPIPHANY_OPERAND_SIMM8, HW_H_IADDR, 15, 8,
-    { 0, { (const PTR) &epiphany_cgen_ifld_table[EPIPHANY_F_SIMM8] } }, 
+    { 0, { (const PTR) &epiphany_cgen_ifld_table[EPIPHANY_F_SIMM8] } },
     { 0|A(RELAX)|A(RELOC)|A(PCREL_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
 /* rd: destination register */
   { "rd", EPIPHANY_OPERAND_RD, HW_H_REGISTERS, 15, 3,
-    { 0, { (const PTR) &epiphany_cgen_ifld_table[EPIPHANY_F_RD] } }, 
+    { 0, { (const PTR) &epiphany_cgen_ifld_table[EPIPHANY_F_RD] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* rn: source register */
   { "rn", EPIPHANY_OPERAND_RN, HW_H_REGISTERS, 12, 3,
-    { 0, { (const PTR) &epiphany_cgen_ifld_table[EPIPHANY_F_RN] } }, 
+    { 0, { (const PTR) &epiphany_cgen_ifld_table[EPIPHANY_F_RN] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* rm: source register */
   { "rm", EPIPHANY_OPERAND_RM, HW_H_REGISTERS, 9, 3,
-    { 0, { (const PTR) &epiphany_cgen_ifld_table[EPIPHANY_F_RM] } }, 
+    { 0, { (const PTR) &epiphany_cgen_ifld_table[EPIPHANY_F_RM] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* frd: fp destination register */
   { "frd", EPIPHANY_OPERAND_FRD, HW_H_FPREGISTERS, 15, 3,
-    { 0, { (const PTR) &epiphany_cgen_ifld_table[EPIPHANY_F_RD] } }, 
+    { 0, { (const PTR) &epiphany_cgen_ifld_table[EPIPHANY_F_RD] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* frn: fp source register */
   { "frn", EPIPHANY_OPERAND_FRN, HW_H_FPREGISTERS, 12, 3,
-    { 0, { (const PTR) &epiphany_cgen_ifld_table[EPIPHANY_F_RN] } }, 
+    { 0, { (const PTR) &epiphany_cgen_ifld_table[EPIPHANY_F_RN] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* frm: fp source register */
   { "frm", EPIPHANY_OPERAND_FRM, HW_H_FPREGISTERS, 9, 3,
-    { 0, { (const PTR) &epiphany_cgen_ifld_table[EPIPHANY_F_RM] } }, 
+    { 0, { (const PTR) &epiphany_cgen_ifld_table[EPIPHANY_F_RM] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* rd6: destination register */
   { "rd6", EPIPHANY_OPERAND_RD6, HW_H_REGISTERS, 15, 6,
-    { 2, { (const PTR) &EPIPHANY_F_RD6_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &EPIPHANY_F_RD6_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } }  },
 /* rn6: source register */
   { "rn6", EPIPHANY_OPERAND_RN6, HW_H_REGISTERS, 12, 6,
-    { 2, { (const PTR) &EPIPHANY_F_RN6_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &EPIPHANY_F_RN6_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } }  },
 /* rm6: source register */
   { "rm6", EPIPHANY_OPERAND_RM6, HW_H_REGISTERS, 9, 6,
-    { 2, { (const PTR) &EPIPHANY_F_RM6_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &EPIPHANY_F_RM6_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } }  },
 /* frd6: fp destination register */
   { "frd6", EPIPHANY_OPERAND_FRD6, HW_H_FPREGISTERS, 15, 6,
-    { 2, { (const PTR) &EPIPHANY_F_RD6_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &EPIPHANY_F_RD6_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } }  },
 /* frn6: fp source register */
   { "frn6", EPIPHANY_OPERAND_FRN6, HW_H_FPREGISTERS, 12, 6,
-    { 2, { (const PTR) &EPIPHANY_F_RN6_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &EPIPHANY_F_RN6_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } }  },
 /* frm6: fp source register */
   { "frm6", EPIPHANY_OPERAND_FRM6, HW_H_FPREGISTERS, 9, 6,
-    { 2, { (const PTR) &EPIPHANY_F_RM6_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &EPIPHANY_F_RM6_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } }  },
 /* sd: special destination */
   { "sd", EPIPHANY_OPERAND_SD, HW_H_CORE_REGISTERS, 15, 3,
-    { 0, { (const PTR) &epiphany_cgen_ifld_table[EPIPHANY_F_SD] } }, 
+    { 0, { (const PTR) &epiphany_cgen_ifld_table[EPIPHANY_F_SD] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* sn: special source */
   { "sn", EPIPHANY_OPERAND_SN, HW_H_CORE_REGISTERS, 12, 3,
-    { 0, { (const PTR) &epiphany_cgen_ifld_table[EPIPHANY_F_SN] } }, 
+    { 0, { (const PTR) &epiphany_cgen_ifld_table[EPIPHANY_F_SN] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* sd6: special destination register */
   { "sd6", EPIPHANY_OPERAND_SD6, HW_H_CORE_REGISTERS, 15, 6,
-    { 2, { (const PTR) &EPIPHANY_F_SD6_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &EPIPHANY_F_SD6_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } }  },
 /* sn6: special source register */
   { "sn6", EPIPHANY_OPERAND_SN6, HW_H_CORE_REGISTERS, 12, 6,
-    { 2, { (const PTR) &EPIPHANY_F_SN6_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &EPIPHANY_F_SN6_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } }  },
 /* sddma: dma register */
   { "sddma", EPIPHANY_OPERAND_SDDMA, HW_H_COREDMA_REGISTERS, 15, 6,
-    { 2, { (const PTR) &EPIPHANY_F_SD6_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &EPIPHANY_F_SD6_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } }  },
 /* sndma: dma register */
   { "sndma", EPIPHANY_OPERAND_SNDMA, HW_H_COREDMA_REGISTERS, 12, 6,
-    { 2, { (const PTR) &EPIPHANY_F_SN6_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &EPIPHANY_F_SN6_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } }  },
 /* sdmem: mem register */
   { "sdmem", EPIPHANY_OPERAND_SDMEM, HW_H_COREMEM_REGISTERS, 15, 6,
-    { 2, { (const PTR) &EPIPHANY_F_SD6_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &EPIPHANY_F_SD6_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } }  },
 /* snmem: mem register */
   { "snmem", EPIPHANY_OPERAND_SNMEM, HW_H_COREMEM_REGISTERS, 12, 6,
-    { 2, { (const PTR) &EPIPHANY_F_SN6_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &EPIPHANY_F_SN6_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } }  },
 /* sdmesh: mesh register */
   { "sdmesh", EPIPHANY_OPERAND_SDMESH, HW_H_COREMESH_REGISTERS, 15, 6,
-    { 2, { (const PTR) &EPIPHANY_F_SD6_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &EPIPHANY_F_SD6_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } }  },
 /* snmesh: mesh register */
   { "snmesh", EPIPHANY_OPERAND_SNMESH, HW_H_COREMESH_REGISTERS, 12, 6,
-    { 2, { (const PTR) &EPIPHANY_F_SN6_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &EPIPHANY_F_SN6_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } }  },
 /* simm3: signed 3-bit literal */
   { "simm3", EPIPHANY_OPERAND_SIMM3, HW_H_SINT, 9, 3,
-    { 0, { (const PTR) &epiphany_cgen_ifld_table[EPIPHANY_F_SDISP3] } }, 
+    { 0, { (const PTR) &epiphany_cgen_ifld_table[EPIPHANY_F_SDISP3] } },
     { 0|A(RELAX), { { { (1<<MACH_BASE), 0 } } } }  },
 /* simm11: signed 11-bit literal */
   { "simm11", EPIPHANY_OPERAND_SIMM11, HW_H_SINT, 9, 11,
-    { 2, { (const PTR) &EPIPHANY_F_SDISP11_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &EPIPHANY_F_SDISP11_MULTI_IFIELD[0] } },
     { 0|A(RELAX)|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } }  },
 /* disp3: short data displacement */
   { "disp3", EPIPHANY_OPERAND_DISP3, HW_H_UINT, 9, 3,
-    { 0, { (const PTR) &epiphany_cgen_ifld_table[EPIPHANY_F_DISP3] } }, 
+    { 0, { (const PTR) &epiphany_cgen_ifld_table[EPIPHANY_F_DISP3] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* trapnum6: parameter for swi or trap */
   { "trapnum6", EPIPHANY_OPERAND_TRAPNUM6, HW_H_UINT, 15, 6,
-    { 0, { (const PTR) &epiphany_cgen_ifld_table[EPIPHANY_F_TRAP_NUM] } }, 
+    { 0, { (const PTR) &epiphany_cgen_ifld_table[EPIPHANY_F_TRAP_NUM] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* swi_num: unsigned 6-bit swi# */
   { "swi_num", EPIPHANY_OPERAND_SWI_NUM, HW_H_UINT, 15, 6,
-    { 0, { (const PTR) &epiphany_cgen_ifld_table[EPIPHANY_F_TRAP_NUM] } }, 
+    { 0, { (const PTR) &epiphany_cgen_ifld_table[EPIPHANY_F_TRAP_NUM] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* disp11: sign-magnitude data displacement */
   { "disp11", EPIPHANY_OPERAND_DISP11, HW_H_UINT, 9, 11,
-    { 2, { (const PTR) &EPIPHANY_F_DISP11_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &EPIPHANY_F_DISP11_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } }  },
 /* shift: immediate shift amount */
   { "shift", EPIPHANY_OPERAND_SHIFT, HW_H_UINT, 9, 5,
-    { 0, { (const PTR) &epiphany_cgen_ifld_table[EPIPHANY_F_SHIFT] } }, 
+    { 0, { (const PTR) &epiphany_cgen_ifld_table[EPIPHANY_F_SHIFT] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* imm16: 16-bit unsigned literal */
   { "imm16", EPIPHANY_OPERAND_IMM16, HW_H_ADDR, 12, 16,
-    { 2, { (const PTR) &EPIPHANY_F_IMM16_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &EPIPHANY_F_IMM16_MULTI_IFIELD[0] } },
     { 0|A(RELAX)|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } }  },
 /* imm8: 8-bit unsigned literal */
   { "imm8", EPIPHANY_OPERAND_IMM8, HW_H_ADDR, 12, 8,
-    { 0, { (const PTR) &epiphany_cgen_ifld_table[EPIPHANY_F_IMM8] } }, 
+    { 0, { (const PTR) &epiphany_cgen_ifld_table[EPIPHANY_F_IMM8] } },
     { 0|A(RELAX), { { { (1<<MACH_BASE), 0 } } } }  },
 /* direction: +/- indexing */
   { "direction", EPIPHANY_OPERAND_DIRECTION, HW_H_UINT, 20, 1,
-    { 0, { (const PTR) &epiphany_cgen_ifld_table[EPIPHANY_F_ADDSUBX] } }, 
+    { 0, { (const PTR) &epiphany_cgen_ifld_table[EPIPHANY_F_ADDSUBX] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* dpmi: +/- magnitude immediate displacement */
   { "dpmi", EPIPHANY_OPERAND_DPMI, HW_H_UINT, 24, 1,
-    { 0, { (const PTR) &epiphany_cgen_ifld_table[EPIPHANY_F_SUBD] } }, 
+    { 0, { (const PTR) &epiphany_cgen_ifld_table[EPIPHANY_F_SUBD] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* sentinel */
   { 0, 0, 0, 0, 0,
@@ -2212,7 +2212,7 @@ epiphany_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)
 
   /* Default to not allowing signed overflow.  */
   cd->signed_overflow_ok_p = 0;
-  
+
   return (CGEN_CPU_DESC) cd;
 }
 
@@ -2252,7 +2252,7 @@ epiphany_cgen_cpu_close (CGEN_CPU_DESC cd)
       for (i = 0; i < cd->insn_table.num_init_entries; ++i, ++insns)
 	if (CGEN_INSN_RX (insns))
 	  regfree (CGEN_INSN_RX (insns));
-    }  
+    }
 
   if (cd->macro_insn_table.init_entries)
     free ((CGEN_INSN *) cd->macro_insn_table.init_entries);
--- a/opcodes/epiphany-dis.c
+++ b/opcodes/epiphany-dis.c
@@ -279,7 +279,7 @@ epiphany_cgen_print_operand (CGEN_CPU_DESC cd,
   }
 }
 
-cgen_print_fn * const epiphany_cgen_print_handlers[] = 
+cgen_print_fn * const epiphany_cgen_print_handlers[] =
 {
   print_insn_normal,
 };
@@ -469,7 +469,7 @@ print_insn (CGEN_CPU_DESC cd,
       int length;
       unsigned long insn_value_cropped;
 
-#ifdef CGEN_VALIDATE_INSN_SUPPORTED 
+#ifdef CGEN_VALIDATE_INSN_SUPPORTED
       /* Not needed as insn shouldn't be in hash lists if not supported.  */
       /* Supported by this cpu?  */
       if (! epiphany_cgen_insn_supported (cd, insn))
@@ -487,7 +487,7 @@ print_insn (CGEN_CPU_DESC cd,
          relevant part from the buffer. */
       if ((unsigned) (CGEN_INSN_BITSIZE (insn) / 8) < buflen &&
 	  (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
-	insn_value_cropped = bfd_get_bits (buf, CGEN_INSN_BITSIZE (insn), 
+	insn_value_cropped = bfd_get_bits (buf, CGEN_INSN_BITSIZE (insn),
 					   info->endian == BFD_ENDIAN_BIG);
       else
 	insn_value_cropped = insn_value;
@@ -606,7 +606,7 @@ print_insn_epiphany (bfd_vma pc, disassemble_info *info)
   arch = info->arch;
   if (arch == bfd_arch_unknown)
     arch = CGEN_BFD_ARCH;
-   
+
   /* There's no standard way to compute the machine or isa number
      so we leave it to the target.  */
 #ifdef CGEN_COMPUTE_MACH
@@ -647,7 +647,7 @@ print_insn_epiphany (bfd_vma pc, disassemble_info *info)
 	      break;
 	    }
 	}
-    } 
+    }
 
   /* If we haven't initialized yet, initialize the opcode table.  */
   if (! cd)
--- a/opcodes/epiphany-ibld.c
+++ b/opcodes/epiphany-ibld.c
@@ -154,7 +154,7 @@ insert_normal (CGEN_CPU_DESC cd,
     {
       long minval = - (1L << (length - 1));
       unsigned long maxval = mask;
-      
+
       if ((value > 0 && (unsigned long) value > maxval)
 	  || value < minval)
 	{
@@ -192,7 +192,7 @@ insert_normal (CGEN_CPU_DESC cd,
 	{
 	  long minval = - (1L << (length - 1));
 	  long maxval =   (1L << (length - 1)) - 1;
-	  
+
 	  if (value < minval || value > maxval)
 	    {
 	      sprintf
@@ -1170,12 +1170,12 @@ epiphany_cgen_extract_operand (CGEN_CPU_DESC cd,
   return length;
 }
 
-cgen_insert_fn * const epiphany_cgen_insert_handlers[] = 
+cgen_insert_fn * const epiphany_cgen_insert_handlers[] =
 {
   insert_insn_normal,
 };
 
-cgen_extract_fn * const epiphany_cgen_extract_handlers[] = 
+cgen_extract_fn * const epiphany_cgen_extract_handlers[] =
 {
   extract_insn_normal,
 };
--- a/opcodes/fr30-asm.c
+++ b/opcodes/fr30-asm.c
@@ -313,7 +313,7 @@ fr30_cgen_parse_operand (CGEN_CPU_DESC cd,
   return errmsg;
 }
 
-cgen_parse_fn * const fr30_cgen_parse_handlers[] = 
+cgen_parse_fn * const fr30_cgen_parse_handlers[] =
 {
   parse_insn_normal,
 };
@@ -343,9 +343,9 @@ CGEN_ASM_INIT_HOOK
 
    Returns NULL for success, an error message for failure.  */
 
-char * 
+char *
 fr30_cgen_build_insn_regex (CGEN_INSN *insn)
-{  
+{
   CGEN_OPCODE *opc = (CGEN_OPCODE *) CGEN_INSN_OPCODE (insn);
   const char *mnem = CGEN_INSN_MNEMONIC (insn);
   char rxbuf[CGEN_MAX_RX_ELEMENTS];
@@ -384,18 +384,18 @@ fr30_cgen_build_insn_regex (CGEN_INSN *insn)
   /* Copy any remaining literals from the syntax string into the rx.  */
   for(; * syn != 0 && rx <= rxbuf + (CGEN_MAX_RX_ELEMENTS - 7 - 4); ++syn)
     {
-      if (CGEN_SYNTAX_CHAR_P (* syn)) 
+      if (CGEN_SYNTAX_CHAR_P (* syn))
 	{
 	  char c = CGEN_SYNTAX_CHAR (* syn);
 
-	  switch (c) 
+	  switch (c)
 	    {
 	      /* Escape any regex metacharacters in the syntax.  */
-	    case '.': case '[': case '\\': 
-	    case '*': case '^': case '$': 
+	    case '.': case '[': case '\\':
+	    case '*': case '^': case '$':
 
 #ifdef CGEN_ESCAPE_EXTENDED_REGEX
-	    case '?': case '{': case '}': 
+	    case '?': case '{': case '}':
 	    case '(': case ')': case '*':
 	    case '|': case '+': case ']':
 #endif
@@ -425,20 +425,20 @@ fr30_cgen_build_insn_regex (CGEN_INSN *insn)
     }
 
   /* Trailing whitespace ok.  */
-  * rx++ = '['; 
-  * rx++ = ' '; 
-  * rx++ = '\t'; 
-  * rx++ = ']'; 
-  * rx++ = '*'; 
+  * rx++ = '[';
+  * rx++ = ' ';
+  * rx++ = '\t';
+  * rx++ = ']';
+  * rx++ = '*';
 
   /* But anchor it after that.  */
-  * rx++ = '$'; 
+  * rx++ = '$';
   * rx = '\0';
 
   CGEN_INSN_RX (insn) = xmalloc (sizeof (regex_t));
   reg_err = regcomp ((regex_t *) CGEN_INSN_RX (insn), rxbuf, REG_NOSUB);
 
-  if (reg_err == 0) 
+  if (reg_err == 0)
     return NULL;
   else
     {
@@ -637,7 +637,7 @@ fr30_cgen_assemble_insn (CGEN_CPU_DESC cd,
       const CGEN_INSN *insn = ilist->insn;
       recognized_mnemonic = 1;
 
-#ifdef CGEN_VALIDATE_INSN_SUPPORTED 
+#ifdef CGEN_VALIDATE_INSN_SUPPORTED
       /* Not usually needed as unsupported opcodes
 	 shouldn't be in the hash lists.  */
       /* Is this insn supported by the selected cpu?  */
@@ -697,7 +697,7 @@ fr30_cgen_assemble_insn (CGEN_CPU_DESC cd,
 	if (strlen (start) > 50)
 	  /* xgettext:c-format */
 	  sprintf (errbuf, "%s `%.50s...'", tmp_errmsg, start);
-	else 
+	else
 	  /* xgettext:c-format */
 	  sprintf (errbuf, "%s `%.50s'", tmp_errmsg, start);
       }
@@ -706,11 +706,11 @@ fr30_cgen_assemble_insn (CGEN_CPU_DESC cd,
 	if (strlen (start) > 50)
 	  /* xgettext:c-format */
 	  sprintf (errbuf, _("bad instruction `%.50s...'"), start);
-	else 
+	else
 	  /* xgettext:c-format */
 	  sprintf (errbuf, _("bad instruction `%.50s'"), start);
       }
-      
+
     *errmsg = errbuf;
     return NULL;
   }
--- a/opcodes/fr30-desc.c
+++ b/opcodes/fr30-desc.c
@@ -364,199 +364,199 @@ const CGEN_OPERAND fr30_cgen_operand_table[] =
 {
 /* pc: program counter */
   { "pc", FR30_OPERAND_PC, HW_H_PC, 0, 0,
-    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_NIL] } }, 
+    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_NIL] } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* Ri: destination register */
   { "Ri", FR30_OPERAND_RI, HW_H_GR, 12, 4,
-    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_RI] } }, 
+    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_RI] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* Rj: source register */
   { "Rj", FR30_OPERAND_RJ, HW_H_GR, 8, 4,
-    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_RJ] } }, 
+    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_RJ] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* Ric: target register coproc insn */
   { "Ric", FR30_OPERAND_RIC, HW_H_GR, 12, 4,
-    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_RIC] } }, 
+    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_RIC] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* Rjc: source register coproc insn */
   { "Rjc", FR30_OPERAND_RJC, HW_H_GR, 8, 4,
-    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_RJC] } }, 
+    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_RJC] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* CRi: coprocessor register */
   { "CRi", FR30_OPERAND_CRI, HW_H_CR, 12, 4,
-    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_CRI] } }, 
+    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_CRI] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* CRj: coprocessor register */
   { "CRj", FR30_OPERAND_CRJ, HW_H_CR, 8, 4,
-    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_CRJ] } }, 
+    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_CRJ] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* Rs1: dedicated register */
   { "Rs1", FR30_OPERAND_RS1, HW_H_DR, 8, 4,
-    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_RS1] } }, 
+    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_RS1] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* Rs2: dedicated register */
   { "Rs2", FR30_OPERAND_RS2, HW_H_DR, 12, 4,
-    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_RS2] } }, 
+    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_RS2] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* R13: General Register 13 */
   { "R13", FR30_OPERAND_R13, HW_H_R13, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* R14: General Register 14 */
   { "R14", FR30_OPERAND_R14, HW_H_R14, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* R15: General Register 15 */
   { "R15", FR30_OPERAND_R15, HW_H_R15, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* ps: Program Status register */
   { "ps", FR30_OPERAND_PS, HW_H_PS, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* u4: 4  bit unsigned immediate */
   { "u4", FR30_OPERAND_U4, HW_H_UINT, 8, 4,
-    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_U4] } }, 
+    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_U4] } },
     { 0|A(HASH_PREFIX), { { { (1<<MACH_BASE), 0 } } } }  },
 /* u4c: 4  bit unsigned immediate */
   { "u4c", FR30_OPERAND_U4C, HW_H_UINT, 12, 4,
-    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_U4C] } }, 
+    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_U4C] } },
     { 0|A(HASH_PREFIX), { { { (1<<MACH_BASE), 0 } } } }  },
 /* u8: 8  bit unsigned immediate */
   { "u8", FR30_OPERAND_U8, HW_H_UINT, 8, 8,
-    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_U8] } }, 
+    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_U8] } },
     { 0|A(HASH_PREFIX), { { { (1<<MACH_BASE), 0 } } } }  },
 /* i8: 8  bit unsigned immediate */
   { "i8", FR30_OPERAND_I8, HW_H_UINT, 4, 8,
-    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_I8] } }, 
+    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_I8] } },
     { 0|A(HASH_PREFIX), { { { (1<<MACH_BASE), 0 } } } }  },
 /* udisp6: 6  bit unsigned immediate */
   { "udisp6", FR30_OPERAND_UDISP6, HW_H_UINT, 8, 4,
-    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_UDISP6] } }, 
+    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_UDISP6] } },
     { 0|A(HASH_PREFIX), { { { (1<<MACH_BASE), 0 } } } }  },
 /* disp8: 8  bit signed   immediate */
   { "disp8", FR30_OPERAND_DISP8, HW_H_SINT, 4, 8,
-    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_DISP8] } }, 
+    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_DISP8] } },
     { 0|A(HASH_PREFIX), { { { (1<<MACH_BASE), 0 } } } }  },
 /* disp9: 9  bit signed   immediate */
   { "disp9", FR30_OPERAND_DISP9, HW_H_SINT, 4, 8,
-    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_DISP9] } }, 
+    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_DISP9] } },
     { 0|A(HASH_PREFIX), { { { (1<<MACH_BASE), 0 } } } }  },
 /* disp10: 10 bit signed   immediate */
   { "disp10", FR30_OPERAND_DISP10, HW_H_SINT, 4, 8,
-    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_DISP10] } }, 
+    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_DISP10] } },
     { 0|A(HASH_PREFIX), { { { (1<<MACH_BASE), 0 } } } }  },
 /* s10: 10 bit signed   immediate */
   { "s10", FR30_OPERAND_S10, HW_H_SINT, 8, 8,
-    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_S10] } }, 
+    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_S10] } },
     { 0|A(HASH_PREFIX), { { { (1<<MACH_BASE), 0 } } } }  },
 /* u10: 10 bit unsigned immediate */
   { "u10", FR30_OPERAND_U10, HW_H_UINT, 8, 8,
-    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_U10] } }, 
+    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_U10] } },
     { 0|A(HASH_PREFIX), { { { (1<<MACH_BASE), 0 } } } }  },
 /* i32: 32 bit immediate */
   { "i32", FR30_OPERAND_I32, HW_H_UINT, 0, 32,
-    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_I32] } }, 
+    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_I32] } },
     { 0|A(HASH_PREFIX)|A(SIGN_OPT), { { { (1<<MACH_BASE), 0 } } } }  },
 /* m4: 4  bit negative immediate */
   { "m4", FR30_OPERAND_M4, HW_H_SINT, 8, 4,
-    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_M4] } }, 
+    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_M4] } },
     { 0|A(HASH_PREFIX), { { { (1<<MACH_BASE), 0 } } } }  },
 /* i20: 20 bit immediate */
   { "i20", FR30_OPERAND_I20, HW_H_UINT, 0, 20,
-    { 2, { (const PTR) &FR30_F_I20_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &FR30_F_I20_MULTI_IFIELD[0] } },
     { 0|A(HASH_PREFIX)|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } }  },
 /* dir8: 8  bit direct address */
   { "dir8", FR30_OPERAND_DIR8, HW_H_UINT, 8, 8,
-    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_DIR8] } }, 
+    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_DIR8] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* dir9: 9  bit direct address */
   { "dir9", FR30_OPERAND_DIR9, HW_H_UINT, 8, 8,
-    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_DIR9] } }, 
+    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_DIR9] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* dir10: 10 bit direct address */
   { "dir10", FR30_OPERAND_DIR10, HW_H_UINT, 8, 8,
-    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_DIR10] } }, 
+    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_DIR10] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* label9: 9  bit pc relative address */
   { "label9", FR30_OPERAND_LABEL9, HW_H_IADDR, 8, 8,
-    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_REL9] } }, 
+    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_REL9] } },
     { 0|A(PCREL_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
 /* label12: 12 bit pc relative address */
   { "label12", FR30_OPERAND_LABEL12, HW_H_IADDR, 5, 11,
-    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_REL12] } }, 
+    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_REL12] } },
     { 0|A(PCREL_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
 /* reglist_low_ld: 8 bit low register mask for ldm */
   { "reglist_low_ld", FR30_OPERAND_REGLIST_LOW_LD, HW_H_UINT, 8, 8,
-    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_REGLIST_LOW_LD] } }, 
+    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_REGLIST_LOW_LD] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* reglist_hi_ld: 8 bit high register mask for ldm */
   { "reglist_hi_ld", FR30_OPERAND_REGLIST_HI_LD, HW_H_UINT, 8, 8,
-    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_REGLIST_HI_LD] } }, 
+    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_REGLIST_HI_LD] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* reglist_low_st: 8 bit low register mask for stm */
   { "reglist_low_st", FR30_OPERAND_REGLIST_LOW_ST, HW_H_UINT, 8, 8,
-    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_REGLIST_LOW_ST] } }, 
+    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_REGLIST_LOW_ST] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* reglist_hi_st: 8 bit high register mask for stm */
   { "reglist_hi_st", FR30_OPERAND_REGLIST_HI_ST, HW_H_UINT, 8, 8,
-    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_REGLIST_HI_ST] } }, 
+    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_REGLIST_HI_ST] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* cc: condition codes */
   { "cc", FR30_OPERAND_CC, HW_H_UINT, 4, 4,
-    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_CC] } }, 
+    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_CC] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* ccc: coprocessor calc */
   { "ccc", FR30_OPERAND_CCC, HW_H_UINT, 0, 8,
-    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_CCC] } }, 
+    { 0, { (const PTR) &fr30_cgen_ifld_table[FR30_F_CCC] } },
     { 0|A(HASH_PREFIX), { { { (1<<MACH_BASE), 0 } } } }  },
 /* nbit: negative   bit */
   { "nbit", FR30_OPERAND_NBIT, HW_H_NBIT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* vbit: overflow   bit */
   { "vbit", FR30_OPERAND_VBIT, HW_H_VBIT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* zbit: zero       bit */
   { "zbit", FR30_OPERAND_ZBIT, HW_H_ZBIT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* cbit: carry      bit */
   { "cbit", FR30_OPERAND_CBIT, HW_H_CBIT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* ibit: interrupt  bit */
   { "ibit", FR30_OPERAND_IBIT, HW_H_IBIT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* sbit: stack      bit */
   { "sbit", FR30_OPERAND_SBIT, HW_H_SBIT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* tbit: trace trap bit */
   { "tbit", FR30_OPERAND_TBIT, HW_H_TBIT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* d0bit: division 0 bit */
   { "d0bit", FR30_OPERAND_D0BIT, HW_H_D0BIT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* d1bit: division 1 bit */
   { "d1bit", FR30_OPERAND_D1BIT, HW_H_D1BIT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* ccr: condition code bits */
   { "ccr", FR30_OPERAND_CCR, HW_H_CCR, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* scr: system condition bits */
   { "scr", FR30_OPERAND_SCR, HW_H_SCR, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* ilm: interrupt level mask */
   { "ilm", FR30_OPERAND_ILM, HW_H_ILM, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* sentinel */
   { 0, 0, 0, 0, 0,
@@ -1689,7 +1689,7 @@ fr30_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)
 
   /* Default to not allowing signed overflow.  */
   cd->signed_overflow_ok_p = 0;
-  
+
   return (CGEN_CPU_DESC) cd;
 }
 
@@ -1729,7 +1729,7 @@ fr30_cgen_cpu_close (CGEN_CPU_DESC cd)
       for (i = 0; i < cd->insn_table.num_init_entries; ++i, ++insns)
 	if (CGEN_INSN_RX (insns))
 	  regfree (CGEN_INSN_RX (insns));
-    }  
+    }
 
   if (cd->macro_insn_table.init_entries)
     free ((CGEN_INSN *) cd->macro_insn_table.init_entries);
--- a/opcodes/fr30-dis.c
+++ b/opcodes/fr30-dis.c
@@ -79,7 +79,7 @@ print_register_list (void * dis_info,
       (*info->fprintf_func) (info->stream, "r%li", reg_index + offset);
       comma = ",";
     }
-    
+
   for (reg_index = 1; reg_index <= 7; ++reg_index)
     {
       if (load_store)
@@ -301,7 +301,7 @@ fr30_cgen_print_operand (CGEN_CPU_DESC cd,
   }
 }
 
-cgen_print_fn * const fr30_cgen_print_handlers[] = 
+cgen_print_fn * const fr30_cgen_print_handlers[] =
 {
   print_insn_normal,
 };
@@ -491,7 +491,7 @@ print_insn (CGEN_CPU_DESC cd,
       int length;
       unsigned long insn_value_cropped;
 
-#ifdef CGEN_VALIDATE_INSN_SUPPORTED 
+#ifdef CGEN_VALIDATE_INSN_SUPPORTED
       /* Not needed as insn shouldn't be in hash lists if not supported.  */
       /* Supported by this cpu?  */
       if (! fr30_cgen_insn_supported (cd, insn))
@@ -509,7 +509,7 @@ print_insn (CGEN_CPU_DESC cd,
          relevant part from the buffer. */
       if ((unsigned) (CGEN_INSN_BITSIZE (insn) / 8) < buflen &&
 	  (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
-	insn_value_cropped = bfd_get_bits (buf, CGEN_INSN_BITSIZE (insn), 
+	insn_value_cropped = bfd_get_bits (buf, CGEN_INSN_BITSIZE (insn),
 					   info->endian == BFD_ENDIAN_BIG);
       else
 	insn_value_cropped = insn_value;
@@ -628,7 +628,7 @@ print_insn_fr30 (bfd_vma pc, disassemble_info *info)
   arch = info->arch;
   if (arch == bfd_arch_unknown)
     arch = CGEN_BFD_ARCH;
-   
+
   /* There's no standard way to compute the machine or isa number
      so we leave it to the target.  */
 #ifdef CGEN_COMPUTE_MACH
@@ -669,7 +669,7 @@ print_insn_fr30 (bfd_vma pc, disassemble_info *info)
 	      break;
 	    }
 	}
-    } 
+    }
 
   /* If we haven't initialized yet, initialize the opcode table.  */
   if (! cd)
--- a/opcodes/fr30-ibld.c
+++ b/opcodes/fr30-ibld.c
@@ -154,7 +154,7 @@ insert_normal (CGEN_CPU_DESC cd,
     {
       long minval = - (1L << (length - 1));
       unsigned long maxval = mask;
-      
+
       if ((value > 0 && (unsigned long) value > maxval)
 	  || value < minval)
 	{
@@ -192,7 +192,7 @@ insert_normal (CGEN_CPU_DESC cd,
 	{
 	  long minval = - (1L << (length - 1));
 	  long maxval =   (1L << (length - 1)) - 1;
-	  
+
 	  if (value < minval || value > maxval)
 	    {
 	      sprintf
@@ -936,12 +936,12 @@ fr30_cgen_extract_operand (CGEN_CPU_DESC cd,
   return length;
 }
 
-cgen_insert_fn * const fr30_cgen_insert_handlers[] = 
+cgen_insert_fn * const fr30_cgen_insert_handlers[] =
 {
   insert_insn_normal,
 };
 
-cgen_extract_fn * const fr30_cgen_extract_handlers[] = 
+cgen_extract_fn * const fr30_cgen_extract_handlers[] =
 {
   extract_insn_normal,
 };
--- a/opcodes/frv-asm.c
+++ b/opcodes/frv-asm.c
@@ -99,10 +99,10 @@ parse_ldd_annotation (CGEN_CPU_DESC cd,
 	    return errmsg;
 	}
     }
-  
+
   while (**strp == ' ' || **strp == '\t')
     ++*strp;
-  
+
   if (**strp != '@')
     return "missing `@'";
 
@@ -138,10 +138,10 @@ parse_call_annotation (CGEN_CPU_DESC cd,
 	    return errmsg;
 	}
     }
-  
+
   while (**strp == ' ' || **strp == '\t')
     ++*strp;
-  
+
   if (**strp != '@')
     return "missing `@'";
 
@@ -177,10 +177,10 @@ parse_ld_annotation (CGEN_CPU_DESC cd,
 	    return errmsg;
 	}
     }
-  
+
   while (**strp == ' ' || **strp == '\t')
     ++*strp;
-  
+
   if (**strp != '@')
     return "missing `@'";
 
@@ -198,7 +198,7 @@ parse_ulo16 (CGEN_CPU_DESC cd,
   const char *errmsg;
   enum cgen_parse_operand_result result_type;
   bfd_vma value;
- 
+
   if (**strp == '#' || **strp == '%')
     {
       if (strncasecmp (*strp + 1, "lo(", 3) == 0)
@@ -324,7 +324,7 @@ parse_uslo16 (CGEN_CPU_DESC cd,
   const char *errmsg;
   enum cgen_parse_operand_result result_type;
   bfd_vma value;
- 
+
   if (**strp == '#' || **strp == '%')
     {
       if (strncasecmp (*strp + 1, "lo(", 3) == 0)
@@ -450,7 +450,7 @@ parse_uhi16 (CGEN_CPU_DESC cd,
   const char *errmsg;
   enum cgen_parse_operand_result result_type;
   bfd_vma value;
- 
+
   if (**strp == '#' || **strp == '%')
     {
       if (strncasecmp (*strp + 1, "hi(", 3) == 0)
@@ -635,7 +635,7 @@ parse_d12 (CGEN_CPU_DESC cd,
   const char *errmsg;
   enum cgen_parse_operand_result result_type;
   bfd_vma value;
- 
+
   /* Check for small data reference.  */
   if (**strp == '#' || **strp == '%')
     {
@@ -748,7 +748,7 @@ parse_s12 (CGEN_CPU_DESC cd,
   const char *errmsg;
   enum cgen_parse_operand_result result_type;
   bfd_vma value;
- 
+
   /* Check for small data reference.  */
   if (**strp == '#' || **strp == '%')
     {
@@ -864,7 +864,7 @@ parse_u12 (CGEN_CPU_DESC cd,
   const char *errmsg;
   enum cgen_parse_operand_result result_type;
   bfd_vma value;
- 
+
   /* Check for small data reference.  */
   if ((**strp == '#' || **strp == '%')
       && strncasecmp (*strp + 1, "gprel12(", 8) == 0)
@@ -895,7 +895,7 @@ parse_A (CGEN_CPU_DESC cd,
 	 unsigned long A)
 {
   const char *errmsg;
- 
+
   if (**strp == '#')
     ++*strp;
 
@@ -957,7 +957,7 @@ parse_call_label (CGEN_CPU_DESC cd,
 {
   const char *errmsg;
   bfd_vma value;
- 
+
   /* Check for small data reference.  */
   if (opinfo == 0 && (**strp == '#' || **strp == '%'))
     {
@@ -1266,7 +1266,7 @@ frv_cgen_parse_operand (CGEN_CPU_DESC cd,
   return errmsg;
 }
 
-cgen_parse_fn * const frv_cgen_parse_handlers[] = 
+cgen_parse_fn * const frv_cgen_parse_handlers[] =
 {
   parse_insn_normal,
 };
@@ -1296,9 +1296,9 @@ CGEN_ASM_INIT_HOOK
 
    Returns NULL for success, an error message for failure.  */
 
-char * 
+char *
 frv_cgen_build_insn_regex (CGEN_INSN *insn)
-{  
+{
   CGEN_OPCODE *opc = (CGEN_OPCODE *) CGEN_INSN_OPCODE (insn);
   const char *mnem = CGEN_INSN_MNEMONIC (insn);
   char rxbuf[CGEN_MAX_RX_ELEMENTS];
@@ -1337,18 +1337,18 @@ frv_cgen_build_insn_regex (CGEN_INSN *insn)
   /* Copy any remaining literals from the syntax string into the rx.  */
   for(; * syn != 0 && rx <= rxbuf + (CGEN_MAX_RX_ELEMENTS - 7 - 4); ++syn)
     {
-      if (CGEN_SYNTAX_CHAR_P (* syn)) 
+      if (CGEN_SYNTAX_CHAR_P (* syn))
 	{
 	  char c = CGEN_SYNTAX_CHAR (* syn);
 
-	  switch (c) 
+	  switch (c)
 	    {
 	      /* Escape any regex metacharacters in the syntax.  */
-	    case '.': case '[': case '\\': 
-	    case '*': case '^': case '$': 
+	    case '.': case '[': case '\\':
+	    case '*': case '^': case '$':
 
 #ifdef CGEN_ESCAPE_EXTENDED_REGEX
-	    case '?': case '{': case '}': 
+	    case '?': case '{': case '}':
 	    case '(': case ')': case '*':
 	    case '|': case '+': case ']':
 #endif
@@ -1378,20 +1378,20 @@ frv_cgen_build_insn_regex (CGEN_INSN *insn)
     }
 
   /* Trailing whitespace ok.  */
-  * rx++ = '['; 
-  * rx++ = ' '; 
-  * rx++ = '\t'; 
-  * rx++ = ']'; 
-  * rx++ = '*'; 
+  * rx++ = '[';
+  * rx++ = ' ';
+  * rx++ = '\t';
+  * rx++ = ']';
+  * rx++ = '*';
 
   /* But anchor it after that.  */
-  * rx++ = '$'; 
+  * rx++ = '$';
   * rx = '\0';
 
   CGEN_INSN_RX (insn) = xmalloc (sizeof (regex_t));
   reg_err = regcomp ((regex_t *) CGEN_INSN_RX (insn), rxbuf, REG_NOSUB);
 
-  if (reg_err == 0) 
+  if (reg_err == 0)
     return NULL;
   else
     {
@@ -1590,7 +1590,7 @@ frv_cgen_assemble_insn (CGEN_CPU_DESC cd,
       const CGEN_INSN *insn = ilist->insn;
       recognized_mnemonic = 1;
 
-#ifdef CGEN_VALIDATE_INSN_SUPPORTED 
+#ifdef CGEN_VALIDATE_INSN_SUPPORTED
       /* Not usually needed as unsupported opcodes
 	 shouldn't be in the hash lists.  */
       /* Is this insn supported by the selected cpu?  */
@@ -1650,7 +1650,7 @@ frv_cgen_assemble_insn (CGEN_CPU_DESC cd,
 	if (strlen (start) > 50)
 	  /* xgettext:c-format */
 	  sprintf (errbuf, "%s `%.50s...'", tmp_errmsg, start);
-	else 
+	else
 	  /* xgettext:c-format */
 	  sprintf (errbuf, "%s `%.50s'", tmp_errmsg, start);
       }
@@ -1659,11 +1659,11 @@ frv_cgen_assemble_insn (CGEN_CPU_DESC cd,
 	if (strlen (start) > 50)
 	  /* xgettext:c-format */
 	  sprintf (errbuf, _("bad instruction `%.50s...'"), start);
-	else 
+	else
 	  /* xgettext:c-format */
 	  sprintf (errbuf, _("bad instruction `%.50s'"), start);
       }
-      
+
     *errmsg = errbuf;
     return NULL;
   }
--- a/opcodes/frv-desc.c
+++ b/opcodes/frv-desc.c
@@ -2054,359 +2054,359 @@ const CGEN_OPERAND frv_cgen_operand_table[] =
 {
 /* pc: program counter */
   { "pc", FRV_OPERAND_PC, HW_H_PC, 0, 0,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_NIL] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_NIL] } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* pack: packing bit */
   { "pack", FRV_OPERAND_PACK, HW_H_PACK, 31, 1,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_PACK] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_PACK] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* GRi: source register 1 */
   { "GRi", FRV_OPERAND_GRI, HW_H_GR, 17, 6,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_GRI] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_GRI] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* GRj: source register 2 */
   { "GRj", FRV_OPERAND_GRJ, HW_H_GR, 5, 6,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_GRJ] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_GRJ] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* GRk: destination register */
   { "GRk", FRV_OPERAND_GRK, HW_H_GR, 30, 6,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_GRK] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_GRK] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* GRkhi: destination register */
   { "GRkhi", FRV_OPERAND_GRKHI, HW_H_GR_HI, 30, 6,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_GRK] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_GRK] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* GRklo: destination register */
   { "GRklo", FRV_OPERAND_GRKLO, HW_H_GR_LO, 30, 6,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_GRK] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_GRK] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* GRdoublek: destination register */
   { "GRdoublek", FRV_OPERAND_GRDOUBLEK, HW_H_GR_DOUBLE, 30, 6,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_GRK] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_GRK] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* ACC40Si: signed accumulator */
   { "ACC40Si", FRV_OPERAND_ACC40SI, HW_H_ACC40S, 17, 6,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_ACC40SI] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_ACC40SI] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* ACC40Ui: unsigned accumulator */
   { "ACC40Ui", FRV_OPERAND_ACC40UI, HW_H_ACC40U, 17, 6,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_ACC40UI] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_ACC40UI] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* ACC40Sk: target accumulator */
   { "ACC40Sk", FRV_OPERAND_ACC40SK, HW_H_ACC40S, 30, 6,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_ACC40SK] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_ACC40SK] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* ACC40Uk: target accumulator */
   { "ACC40Uk", FRV_OPERAND_ACC40UK, HW_H_ACC40U, 30, 6,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_ACC40UK] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_ACC40UK] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* ACCGi: source register */
   { "ACCGi", FRV_OPERAND_ACCGI, HW_H_ACCG, 17, 6,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_ACCGI] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_ACCGI] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* ACCGk: target register */
   { "ACCGk", FRV_OPERAND_ACCGK, HW_H_ACCG, 30, 6,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_ACCGK] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_ACCGK] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* CPRi: source register */
   { "CPRi", FRV_OPERAND_CPRI, HW_H_CPR, 17, 6,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_CPRI] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_CPRI] } },
     { 0, { { { (1<<MACH_FRV), 0 } } } }  },
 /* CPRj: source register */
   { "CPRj", FRV_OPERAND_CPRJ, HW_H_CPR, 5, 6,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_CPRJ] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_CPRJ] } },
     { 0, { { { (1<<MACH_FRV), 0 } } } }  },
 /* CPRk: destination register */
   { "CPRk", FRV_OPERAND_CPRK, HW_H_CPR, 30, 6,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_CPRK] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_CPRK] } },
     { 0, { { { (1<<MACH_FRV), 0 } } } }  },
 /* CPRdoublek: destination register */
   { "CPRdoublek", FRV_OPERAND_CPRDOUBLEK, HW_H_CPR_DOUBLE, 30, 6,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_CPRK] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_CPRK] } },
     { 0, { { { (1<<MACH_FRV), 0 } } } }  },
 /* FRinti: source register 1 */
   { "FRinti", FRV_OPERAND_FRINTI, HW_H_FR_INT, 17, 6,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_FRI] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_FRI] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* FRintj: source register 2 */
   { "FRintj", FRV_OPERAND_FRINTJ, HW_H_FR_INT, 5, 6,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_FRJ] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_FRJ] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* FRintk: target register */
   { "FRintk", FRV_OPERAND_FRINTK, HW_H_FR_INT, 30, 6,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_FRK] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_FRK] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* FRi: source register 1 */
   { "FRi", FRV_OPERAND_FRI, HW_H_FR, 17, 6,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_FRI] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_FRI] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* FRj: source register 2 */
   { "FRj", FRV_OPERAND_FRJ, HW_H_FR, 5, 6,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_FRJ] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_FRJ] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* FRk: destination register */
   { "FRk", FRV_OPERAND_FRK, HW_H_FR, 30, 6,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_FRK] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_FRK] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* FRkhi: destination register */
   { "FRkhi", FRV_OPERAND_FRKHI, HW_H_FR_HI, 30, 6,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_FRK] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_FRK] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* FRklo: destination register */
   { "FRklo", FRV_OPERAND_FRKLO, HW_H_FR_LO, 30, 6,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_FRK] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_FRK] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* FRdoublei: source register 1 */
   { "FRdoublei", FRV_OPERAND_FRDOUBLEI, HW_H_FR_DOUBLE, 17, 6,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_FRI] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_FRI] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* FRdoublej: source register 2 */
   { "FRdoublej", FRV_OPERAND_FRDOUBLEJ, HW_H_FR_DOUBLE, 5, 6,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_FRJ] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_FRJ] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* FRdoublek: target register */
   { "FRdoublek", FRV_OPERAND_FRDOUBLEK, HW_H_FR_DOUBLE, 30, 6,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_FRK] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_FRK] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* CRi: source register 1 */
   { "CRi", FRV_OPERAND_CRI, HW_H_CCCR, 14, 3,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_CRI] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_CRI] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* CRj: source register 2 */
   { "CRj", FRV_OPERAND_CRJ, HW_H_CCCR, 2, 3,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_CRJ] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_CRJ] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* CRj_int: destination register */
   { "CRj_int", FRV_OPERAND_CRJ_INT, HW_H_CCCR, 26, 2,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_CRJ_INT] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_CRJ_INT] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* CRj_float: destination register */
   { "CRj_float", FRV_OPERAND_CRJ_FLOAT, HW_H_CCCR, 26, 2,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_CRJ_FLOAT] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_CRJ_FLOAT] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* CRk: destination register */
   { "CRk", FRV_OPERAND_CRK, HW_H_CCCR, 27, 3,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_CRK] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_CRK] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* CCi: condition   register */
   { "CCi", FRV_OPERAND_CCI, HW_H_CCCR, 11, 3,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_CCI] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_CCI] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* ICCi_1: condition   register */
   { "ICCi_1", FRV_OPERAND_ICCI_1, HW_H_ICCR, 11, 2,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_ICCI_1] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_ICCI_1] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* ICCi_2: condition   register */
   { "ICCi_2", FRV_OPERAND_ICCI_2, HW_H_ICCR, 26, 2,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_ICCI_2] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_ICCI_2] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* ICCi_3: condition   register */
   { "ICCi_3", FRV_OPERAND_ICCI_3, HW_H_ICCR, 1, 2,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_ICCI_3] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_ICCI_3] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* FCCi_1: condition   register */
   { "FCCi_1", FRV_OPERAND_FCCI_1, HW_H_FCCR, 11, 2,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_FCCI_1] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_FCCI_1] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* FCCi_2: condition   register */
   { "FCCi_2", FRV_OPERAND_FCCI_2, HW_H_FCCR, 26, 2,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_FCCI_2] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_FCCI_2] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* FCCi_3: condition   register */
   { "FCCi_3", FRV_OPERAND_FCCI_3, HW_H_FCCR, 1, 2,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_FCCI_3] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_FCCI_3] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* FCCk: condition   register */
   { "FCCk", FRV_OPERAND_FCCK, HW_H_FCCR, 26, 2,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_FCCK] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_FCCK] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* eir: exception insn reg */
   { "eir", FRV_OPERAND_EIR, HW_H_UINT, 17, 6,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_EIR] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_EIR] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* s10: 10 bit signed immediate */
   { "s10", FRV_OPERAND_S10, HW_H_SINT, 9, 10,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_S10] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_S10] } },
     { 0|A(HASH_PREFIX), { { { (1<<MACH_BASE), 0 } } } }  },
 /* u16: 16 bit unsigned immediate */
   { "u16", FRV_OPERAND_U16, HW_H_UINT, 15, 16,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_U16] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_U16] } },
     { 0|A(HASH_PREFIX), { { { (1<<MACH_BASE), 0 } } } }  },
 /* s16: 16 bit signed   immediate */
   { "s16", FRV_OPERAND_S16, HW_H_SINT, 15, 16,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_S16] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_S16] } },
     { 0|A(HASH_PREFIX), { { { (1<<MACH_BASE), 0 } } } }  },
 /* s6: 6  bit signed   immediate */
   { "s6", FRV_OPERAND_S6, HW_H_SINT, 5, 6,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_S6] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_S6] } },
     { 0|A(HASH_PREFIX), { { { (1<<MACH_BASE), 0 } } } }  },
 /* s6_1: 6  bit signed   immediate */
   { "s6_1", FRV_OPERAND_S6_1, HW_H_SINT, 11, 6,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_S6_1] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_S6_1] } },
     { 0|A(HASH_PREFIX), { { { (1<<MACH_BASE), 0 } } } }  },
 /* u6: 6  bit unsigned immediate */
   { "u6", FRV_OPERAND_U6, HW_H_UINT, 5, 6,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_U6] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_U6] } },
     { 0|A(HASH_PREFIX), { { { (1<<MACH_BASE), 0 } } } }  },
 /* s5: 5  bit signed   immediate */
   { "s5", FRV_OPERAND_S5, HW_H_SINT, 4, 5,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_S5] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_S5] } },
     { 0|A(HASH_PREFIX), { { { (1<<MACH_BASE), 0 } } } }  },
 /* cond: conditional arithmetic */
   { "cond", FRV_OPERAND_COND, HW_H_UINT, 8, 1,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_COND] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_COND] } },
     { 0|A(HASH_PREFIX), { { { (1<<MACH_BASE), 0 } } } }  },
 /* ccond: lr branch condition */
   { "ccond", FRV_OPERAND_CCOND, HW_H_UINT, 12, 1,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_CCOND] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_CCOND] } },
     { 0|A(HASH_PREFIX), { { { (1<<MACH_BASE), 0 } } } }  },
 /* hint: 2 bit branch predictor */
   { "hint", FRV_OPERAND_HINT, HW_H_UINT, 17, 2,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_HINT] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_HINT] } },
     { 0|A(HASH_PREFIX), { { { (1<<MACH_BASE), 0 } } } }  },
 /* hint_taken: 2 bit branch predictor */
   { "hint_taken", FRV_OPERAND_HINT_TAKEN, HW_H_HINT_TAKEN, 17, 2,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_HINT] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_HINT] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* hint_not_taken: 2 bit branch predictor */
   { "hint_not_taken", FRV_OPERAND_HINT_NOT_TAKEN, HW_H_HINT_NOT_TAKEN, 17, 2,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_HINT] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_HINT] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* LI: link indicator */
   { "LI", FRV_OPERAND_LI, HW_H_UINT, 25, 1,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_LI] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_LI] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* lock: cache lock indicator */
   { "lock", FRV_OPERAND_LOCK, HW_H_UINT, 25, 1,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_LOCK] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_LOCK] } },
     { 0|A(HASH_PREFIX), { { { (1<<MACH_BASE), 0 } } } }  },
 /* debug: debug mode indicator */
   { "debug", FRV_OPERAND_DEBUG, HW_H_UINT, 25, 1,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_DEBUG] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_DEBUG] } },
     { 0|A(HASH_PREFIX), { { { (1<<MACH_BASE), 0 } } } }  },
 /* ae: all entries indicator */
   { "ae", FRV_OPERAND_AE, HW_H_UINT, 25, 1,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_AE] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_AE] } },
     { 0|A(HASH_PREFIX), { { { (1<<MACH_BASE), 0 } } } }  },
 /* label16: 18 bit pc relative address */
   { "label16", FRV_OPERAND_LABEL16, HW_H_IADDR, 15, 16,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_LABEL16] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_LABEL16] } },
     { 0|A(PCREL_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
 /* LRAE: Load Real Address E flag */
   { "LRAE", FRV_OPERAND_LRAE, HW_H_UINT, 5, 1,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_LRAE] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_LRAE] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* LRAD: Load Real Address D flag */
   { "LRAD", FRV_OPERAND_LRAD, HW_H_UINT, 4, 1,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_LRAD] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_LRAD] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* LRAS: Load Real Address S flag */
   { "LRAS", FRV_OPERAND_LRAS, HW_H_UINT, 3, 1,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_LRAS] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_LRAS] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* TLBPRopx: TLB Probe operation number */
   { "TLBPRopx", FRV_OPERAND_TLBPROPX, HW_H_UINT, 28, 3,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_TLBPROPX] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_TLBPROPX] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* TLBPRL: TLB Probe L flag */
   { "TLBPRL", FRV_OPERAND_TLBPRL, HW_H_UINT, 25, 1,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_TLBPRL] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_TLBPRL] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* A0: A==0 operand of mclracc */
   { "A0", FRV_OPERAND_A0, HW_H_UINT, 17, 1,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_A] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_A] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* A1: A==1 operand of mclracc */
   { "A1", FRV_OPERAND_A1, HW_H_UINT, 17, 1,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_A] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_A] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* FRintieven: (even) source register 1 */
   { "FRintieven", FRV_OPERAND_FRINTIEVEN, HW_H_FR_INT, 17, 6,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_FRI] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_FRI] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* FRintjeven: (even) source register 2 */
   { "FRintjeven", FRV_OPERAND_FRINTJEVEN, HW_H_FR_INT, 5, 6,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_FRJ] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_FRJ] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* FRintkeven: (even) target register */
   { "FRintkeven", FRV_OPERAND_FRINTKEVEN, HW_H_FR_INT, 30, 6,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_FRK] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_FRK] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* d12: 12 bit signed immediate */
   { "d12", FRV_OPERAND_D12, HW_H_SINT, 11, 12,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_D12] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_D12] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* s12: 12 bit signed immediate */
   { "s12", FRV_OPERAND_S12, HW_H_SINT, 11, 12,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_D12] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_D12] } },
     { 0|A(HASH_PREFIX), { { { (1<<MACH_BASE), 0 } } } }  },
 /* u12: 12 bit signed immediate */
   { "u12", FRV_OPERAND_U12, HW_H_SINT, 5, 12,
-    { 2, { (const PTR) &FRV_F_U12_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &FRV_F_U12_MULTI_IFIELD[0] } },
     { 0|A(HASH_PREFIX)|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } }  },
 /* spr: special purpose register */
   { "spr", FRV_OPERAND_SPR, HW_H_SPR, 17, 12,
-    { 2, { (const PTR) &FRV_F_SPR_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &FRV_F_SPR_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } }  },
 /* ulo16: 16 bit unsigned immediate, for #lo() */
   { "ulo16", FRV_OPERAND_ULO16, HW_H_UINT, 15, 16,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_U16] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_U16] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* slo16: 16 bit unsigned immediate, for #lo() */
   { "slo16", FRV_OPERAND_SLO16, HW_H_SINT, 15, 16,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_S16] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_S16] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* uhi16: 16 bit unsigned immediate, for #hi() */
   { "uhi16", FRV_OPERAND_UHI16, HW_H_UINT, 15, 16,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_U16] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_U16] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* label24: 26 bit pc relative address */
   { "label24", FRV_OPERAND_LABEL24, HW_H_IADDR, 17, 24,
-    { 2, { (const PTR) &FRV_F_LABEL24_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &FRV_F_LABEL24_MULTI_IFIELD[0] } },
     { 0|A(PCREL_ADDR)|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } }  },
 /* psr_esr: PSR.ESR bit */
   { "psr_esr", FRV_OPERAND_PSR_ESR, HW_H_PSR_ESR, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* psr_s: PSR.S   bit */
   { "psr_s", FRV_OPERAND_PSR_S, HW_H_PSR_S, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* psr_ps: PSR.PS  bit */
   { "psr_ps", FRV_OPERAND_PSR_PS, HW_H_PSR_PS, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* psr_et: PSR.ET  bit */
   { "psr_et", FRV_OPERAND_PSR_ET, HW_H_PSR_ET, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* bpsr_bs: BPSR.BS  bit */
   { "bpsr_bs", FRV_OPERAND_BPSR_BS, HW_H_BPSR_BS, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* bpsr_bet: BPSR.BET bit */
   { "bpsr_bet", FRV_OPERAND_BPSR_BET, HW_H_BPSR_BET, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* tbr_tba: TBR.TBA */
   { "tbr_tba", FRV_OPERAND_TBR_TBA, HW_H_TBR_TBA, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* tbr_tt: TBR.TT */
   { "tbr_tt", FRV_OPERAND_TBR_TT, HW_H_TBR_TT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* ldann: ld annotation */
   { "ldann", FRV_OPERAND_LDANN, HW_H_RELOC_ANN, 0, 0,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_RELOC_ANN] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_RELOC_ANN] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* lddann: ldd annotation */
   { "lddann", FRV_OPERAND_LDDANN, HW_H_RELOC_ANN, 0, 0,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_RELOC_ANN] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_RELOC_ANN] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* callann: call annotation */
   { "callann", FRV_OPERAND_CALLANN, HW_H_RELOC_ANN, 0, 0,
-    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_RELOC_ANN] } }, 
+    { 0, { (const PTR) &frv_cgen_ifld_table[FRV_F_RELOC_ANN] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* sentinel */
   { 0, 0, 0, 0, 0,
@@ -6429,7 +6429,7 @@ frv_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)
 
   /* Default to not allowing signed overflow.  */
   cd->signed_overflow_ok_p = 0;
-  
+
   return (CGEN_CPU_DESC) cd;
 }
 
@@ -6469,7 +6469,7 @@ frv_cgen_cpu_close (CGEN_CPU_DESC cd)
       for (i = 0; i < cd->insn_table.num_init_entries; ++i, ++insns)
 	if (CGEN_INSN_RX (insns))
 	  regfree (CGEN_INSN_RX (insns));
-    }  
+    }
 
   if (cd->macro_insn_table.init_entries)
     free ((CGEN_INSN *) cd->macro_insn_table.init_entries);
--- a/opcodes/frv-dis.c
+++ b/opcodes/frv-dis.c
@@ -69,7 +69,7 @@ print_at (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
   disassemble_info *info = (disassemble_info *) dis_info;
 
   (*info->fprintf_func) (info->stream, "@");
-}  
+}
 
 static void
 print_spr (CGEN_CPU_DESC cd,
@@ -398,7 +398,7 @@ frv_cgen_print_operand (CGEN_CPU_DESC cd,
   }
 }
 
-cgen_print_fn * const frv_cgen_print_handlers[] = 
+cgen_print_fn * const frv_cgen_print_handlers[] =
 {
   print_insn_normal,
 };
@@ -588,7 +588,7 @@ print_insn (CGEN_CPU_DESC cd,
       int length;
       unsigned long insn_value_cropped;
 
-#ifdef CGEN_VALIDATE_INSN_SUPPORTED 
+#ifdef CGEN_VALIDATE_INSN_SUPPORTED
       /* Not needed as insn shouldn't be in hash lists if not supported.  */
       /* Supported by this cpu?  */
       if (! frv_cgen_insn_supported (cd, insn))
@@ -606,7 +606,7 @@ print_insn (CGEN_CPU_DESC cd,
          relevant part from the buffer. */
       if ((unsigned) (CGEN_INSN_BITSIZE (insn) / 8) < buflen &&
 	  (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
-	insn_value_cropped = bfd_get_bits (buf, CGEN_INSN_BITSIZE (insn), 
+	insn_value_cropped = bfd_get_bits (buf, CGEN_INSN_BITSIZE (insn),
 					   info->endian == BFD_ENDIAN_BIG);
       else
 	insn_value_cropped = insn_value;
@@ -725,7 +725,7 @@ print_insn_frv (bfd_vma pc, disassemble_info *info)
   arch = info->arch;
   if (arch == bfd_arch_unknown)
     arch = CGEN_BFD_ARCH;
-   
+
   /* There's no standard way to compute the machine or isa number
      so we leave it to the target.  */
 #ifdef CGEN_COMPUTE_MACH
@@ -766,7 +766,7 @@ print_insn_frv (bfd_vma pc, disassemble_info *info)
 	      break;
 	    }
 	}
-    } 
+    }
 
   /* If we haven't initialized yet, initialize the opcode table.  */
   if (! cd)
--- a/opcodes/frv-ibld.c
+++ b/opcodes/frv-ibld.c
@@ -154,7 +154,7 @@ insert_normal (CGEN_CPU_DESC cd,
     {
       long minval = - (1L << (length - 1));
       unsigned long maxval = mask;
-      
+
       if ((value > 0 && (unsigned long) value > maxval)
 	  || value < minval)
 	{
@@ -192,7 +192,7 @@ insert_normal (CGEN_CPU_DESC cd,
 	{
 	  long minval = - (1L << (length - 1));
 	  long maxval =   (1L << (length - 1)) - 1;
-	  
+
 	  if (value < minval || value > maxval)
 	    {
 	      sprintf
@@ -1174,12 +1174,12 @@ frv_cgen_extract_operand (CGEN_CPU_DESC cd,
   return length;
 }
 
-cgen_insert_fn * const frv_cgen_insert_handlers[] = 
+cgen_insert_fn * const frv_cgen_insert_handlers[] =
 {
   insert_insn_normal,
 };
 
-cgen_extract_fn * const frv_cgen_extract_handlers[] = 
+cgen_extract_fn * const frv_cgen_extract_handlers[] =
 {
   extract_insn_normal,
 };
--- a/opcodes/frv-opc.c
+++ b/opcodes/frv-opc.c
@@ -234,7 +234,7 @@ static CGEN_ATTR_VALUE_ENUM_TYPE fr400_unit_mapping[] =
 /* NIL      */     UNIT_NIL,
 /* I0       */     UNIT_I0,
 /* I1       */     UNIT_I1,
-/* I01      */     UNIT_I01, 
+/* I01      */     UNIT_I01,
 /* I2       */     UNIT_NIL, /* no I2 or I3 unit */
 /* I3       */     UNIT_NIL,
 /* IALL     */     UNIT_I01, /* only I0 and I1 units */
@@ -269,7 +269,7 @@ static CGEN_ATTR_VALUE_ENUM_TYPE fr450_unit_mapping[] =
 /* NIL      */     UNIT_NIL,
 /* I0       */     UNIT_I0,
 /* I1       */     UNIT_I1,
-/* I01      */     UNIT_I01, 
+/* I01      */     UNIT_I01,
 /* I2       */     UNIT_NIL, /* no I2 or I3 unit */
 /* I3       */     UNIT_NIL,
 /* IALL     */     UNIT_I01, /* only I0 and I1 units */
@@ -301,7 +301,7 @@ static CGEN_ATTR_VALUE_ENUM_TYPE fr500_unit_mapping[] =
 /* NIL      */     UNIT_NIL,
 /* I0       */     UNIT_I0,
 /* I1       */     UNIT_I1,
-/* I01      */     UNIT_I01, 
+/* I01      */     UNIT_I01,
 /* I2       */     UNIT_NIL, /* no I2 or I3 unit */
 /* I3       */     UNIT_NIL,
 /* IALL     */     UNIT_I01, /* only I0 and I1 units */
@@ -333,10 +333,10 @@ static CGEN_ATTR_VALUE_ENUM_TYPE fr550_unit_mapping[] =
 /* NIL      */     UNIT_NIL,
 /* I0       */     UNIT_I0,
 /* I1       */     UNIT_I1,
-/* I01      */     UNIT_I01, 
+/* I01      */     UNIT_I01,
 /* I2       */     UNIT_I2,
 /* I3       */     UNIT_I3,
-/* IALL     */     UNIT_IALL, 
+/* IALL     */     UNIT_IALL,
 /* FM0      */     UNIT_FM0,
 /* FM1      */     UNIT_FM1,
 /* FM01     */     UNIT_FM01,
--- a/opcodes/h8300-dis.c
+++ b/opcodes/h8300-dis.c
@@ -269,14 +269,14 @@ print_one_arg (disassemble_info *info,
 	{
 	  outfn (stream, ".%s%d (0x%lx)",
 		   (short) cst > 0 ? "+" : "",
-		   (short) cst, 
+		   (short) cst,
 		   (long)(addr + (short) cst + len));
 	}
       else
 	{
 	  outfn (stream, ".%s%d (0x%lx)",
 		   (char) cst > 0 ? "+" : "",
-		   (char) cst, 
+		   (char) cst,
 		   (long)(addr + (char) cst + len));
 	}
     }
@@ -285,12 +285,12 @@ print_one_arg (disassemble_info *info,
 
   else if ((x & MODE) == INDEXB)
     /* Always take low half of reg.  */
-    outfn (stream, "@(0x%x:%d,%s.b)", cst, cstlen, 
+    outfn (stream, "@(0x%x:%d,%s.b)", cst, cstlen,
 	   regnames[rdisp_n < 8 ? rdisp_n + 8 : rdisp_n]);
 
   else if ((x & MODE) == INDEXW)
     /* Always take low half of reg.  */
-    outfn (stream, "@(0x%x:%d,%s.w)", cst, cstlen, 
+    outfn (stream, "@(0x%x:%d,%s.w)", cst, cstlen,
 	   wregnames[rdisp_n < 8 ? rdisp_n : rdisp_n - 8]);
 
   else if ((x & MODE) == INDEXL)
@@ -460,8 +460,8 @@ bfd_h8_disassemble (bfd_vma addr, disassemble_info *info, int mach)
 		       || (looking_for & MODE) == INDEXW
 		       || (looking_for & MODE) == INDEXL)
 		{
-		  extract_immediate (stream, looking_for, thisnib, 
-				     data + len / 2, cst + opnr, 
+		  extract_immediate (stream, looking_for, thisnib,
+				     data + len / 2, cst + opnr,
 				     cstlen + opnr, q);
 		  /* Even address == bra, odd == bra/s.  */
 		  if (q->how == O (O_BRAS, SB))
@@ -529,8 +529,8 @@ bfd_h8_disassemble (bfd_vma addr, disassemble_info *info, int mach)
 		{
 		  int i = len / 2;
 
-		  cst[opnr] = ((data[i] << 24) 
-			       | (data[i + 1] << 16) 
+		  cst[opnr] = ((data[i] << 24)
+			       | (data[i + 1] << 16)
 			       | (data[i + 2] << 8)
 			       | (data[i + 3]));
 
@@ -540,7 +540,7 @@ bfd_h8_disassemble (bfd_vma addr, disassemble_info *info, int mach)
 		{
 		  int i = len / 2;
 
-		  cst[opnr] = 
+		  cst[opnr] =
 		    (data[i] << 16) | (data[i + 1] << 8) | (data[i + 2]);
 		  cstlen[opnr] = 24;
 		}
@@ -633,21 +633,21 @@ bfd_h8_disassemble (bfd_vma addr, disassemble_info *info, int mach)
 		      if (args[1] == (op_type) E)
 			{
 			  /* Short form.  */
-			  print_one_arg (info, addr, args[0], cst[0], 
-					 cstlen[0], dispregno[0], regno[0], 
+			  print_one_arg (info, addr, args[0], cst[0],
+					 cstlen[0], dispregno[0], regno[0],
 					 pregnames, qi->length);
 			  outfn (stream, ",er%d", dispregno[0]);
 			}
 		      else
 			{
 			  outfn (stream, "@(0x%x:%d,", cst[0], cstlen[0]);
-			  print_one_arg (info, addr, args[1], cst[1], 
-					 cstlen[1], dispregno[1], regno[1], 
+			  print_one_arg (info, addr, args[1], cst[1],
+					 cstlen[1], dispregno[1], regno[1],
 					 pregnames, qi->length);
 			  outfn (stream, ".%c),",
 				 (args[0] & MODE) == INDEXB ? 'b' : 'w');
-			  print_one_arg (info, addr, args[2], cst[2], 
-					 cstlen[2], dispregno[2], regno[2], 
+			  print_one_arg (info, addr, args[2], cst[2],
+					 cstlen[2], dispregno[2], regno[2],
 					 pregnames, qi->length);
 			}
 		      return qi->length;
@@ -669,7 +669,7 @@ bfd_h8_disassemble (bfd_vma addr, disassemble_info *info, int mach)
 			return qi->length;
 		      }
 
-		    for (nargs = 0; 
+		    for (nargs = 0;
 			 nargs < 3 && args[nargs] != (op_type) E;
 			 nargs++)
 		      {
--- a/opcodes/i370-opc.c
+++ b/opcodes/i370-opc.c
@@ -257,7 +257,7 @@ const struct i370_operand i370_operands[] =
 #define SS_D2 (SS_B2 + 1)
 #define SS_D2_MASK (0xfff)
   { 12, 0, insert_ss_d2, extract_ss_d2, I370_OPERAND_RELATIVE, "SS D2" },
-  
+
 };
 
 
#--- a/opcodes/i386-opc.h
#+++ b/opcodes/i386-opc.h
#@@ -196,7 +196,7 @@ enum
#   CpuAVX512VBMI,
#   /* mwaitx instruction required */
#   CpuMWAITX,
#-  /* Clzero instruction required */ 
#+  /* Clzero instruction required */
#   CpuCLZERO,
#   /* 64bit support required  */
#   Cpu64,
--- a/opcodes/i860-dis.c
+++ b/opcodes/i860-dis.c
@@ -28,14 +28,14 @@
 #define I860_REG_PREFIX "%"
 
 /* Integer register names (encoded as 0..31 in the instruction).  */
-static const char *const grnames[] = 
+static const char *const grnames[] =
  {"r0",  "r1",  "sp",  "fp",  "r4",  "r5",  "r6",  "r7",
   "r8",  "r9",  "r10", "r11", "r12", "r13", "r14", "r15",
   "r16", "r17", "r18", "r19", "r20", "r21", "r22", "r23",
   "r24", "r25", "r26", "r27", "r28", "r29", "r30", "r31"};
 
 /* FP register names (encoded as 0..31 in the instruction).  */
-static const char *const frnames[] = 
+static const char *const frnames[] =
  {"f0",  "f1",  "f2",  "f3",  "f4",  "f5",  "f6",  "f7",
   "f8",  "f9",  "f10", "f11", "f12", "f13", "f14", "f15",
   "f16", "f17", "f18", "f19", "f20", "f21", "f22", "f23",
@@ -43,7 +43,7 @@ static const char *const frnames[] =
 
 /* Control/status register names (encoded as 0..11 in the instruction).
    Registers bear, ccr, p0, p1, p2 and p3 are XP only.  */
-static const char *const crnames[] = 
+static const char *const crnames[] =
  {"fir", "psr", "dirbase", "db", "fsr", "epsr", "bear", "ccr",
   "p0", "p1", "p2", "p3", "--", "--", "--", "--" };
 
@@ -78,9 +78,9 @@ print_br_address (disassemble_info *info, bfd_vma memaddr, long val)
   long adj = (long)memaddr + 4 + (val << 2);
 
   (*info->fprintf_func) (info->stream, "0x%08lx", adj);
-	    
+
   /* Attempt to obtain a symbol for the target address.  */
-	
+
   if (info->print_address_func && adj != 0)
     {
       (*info->fprintf_func) (info->stream, "\t// ");
@@ -134,7 +134,7 @@ print_insn_i860 (bfd_vma memaddr, disassemble_info *info)
       int val;
 
       /* If this a flop (or a shrd) and its dual bit is set,
-         prefix with 'd.'.  */ 	
+         prefix with 'd.'.  */
       if (((insn & 0xfc000000) == 0x48000000
            || (insn & 0xfc000000) == 0xb0000000)
           && (insn & 0x200))
--- a/opcodes/ia64-asmtab.c
+++ b/opcodes/ia64-asmtab.c
@@ -413,1379 +413,1379 @@ dependencies[] = {
 };
 
 static const unsigned short dep0[] = {
-  100, 288, 2143, 2333, 
+  100, 288, 2143, 2333,
 };
 
 static const unsigned short dep1[] = {
-  41, 42, 100, 161, 165, 178, 188, 288, 2141, 2142, 2143, 2169, 2170, 2173, 
-  2176, 2333, 4136, 20619, 
+  41, 42, 100, 161, 165, 178, 188, 288, 2141, 2142, 2143, 2169, 2170, 2173,
+  2176, 2333, 4136, 20619,
 };
 
 static const unsigned short dep2[] = {
-  100, 288, 2169, 2170, 2172, 2173, 2175, 2176, 2178, 2350, 2353, 2354, 2357, 
-  2358, 2361, 2362, 
+  100, 288, 2169, 2170, 2172, 2173, 2175, 2176, 2178, 2350, 2353, 2354, 2357,
+  2358, 2361, 2362,
 };
 
 static const unsigned short dep3[] = {
-  41, 42, 100, 161, 165, 178, 188, 288, 2141, 2142, 2143, 2169, 2170, 2173, 
-  2176, 2350, 2353, 2354, 2357, 2358, 2361, 2362, 4136, 20619, 
+  41, 42, 100, 161, 165, 178, 188, 288, 2141, 2142, 2143, 2169, 2170, 2173,
+  2176, 2350, 2353, 2354, 2357, 2358, 2361, 2362, 4136, 20619,
 };
 
 static const unsigned short dep4[] = {
-  100, 288, 22649, 22650, 22652, 22653, 22655, 22656, 22658, 22830, 22833, 22834, 
-  22837, 22838, 22841, 22842, 
+  100, 288, 22649, 22650, 22652, 22653, 22655, 22656, 22658, 22830, 22833, 22834,
+  22837, 22838, 22841, 22842,
 };
 
 static const unsigned short dep5[] = {
-  41, 42, 100, 161, 165, 178, 188, 288, 2141, 2142, 2143, 2169, 2170, 2173, 
-  2176, 4136, 20619, 22830, 22833, 22834, 22837, 22838, 22841, 22842, 
+  41, 42, 100, 161, 165, 178, 188, 288, 2141, 2142, 2143, 2169, 2170, 2173,
+  2176, 4136, 20619, 22830, 22833, 22834, 22837, 22838, 22841, 22842,
 };
 
 static const unsigned short dep6[] = {
-  100, 288, 2169, 2170, 2172, 2173, 2175, 2176, 2178, 2350, 2351, 2353, 2355, 
-  2357, 2359, 2361, 
+  100, 288, 2169, 2170, 2172, 2173, 2175, 2176, 2178, 2350, 2351, 2353, 2355,
+  2357, 2359, 2361,
 };
 
 static const unsigned short dep7[] = {
-  41, 42, 100, 161, 165, 178, 188, 288, 2141, 2142, 2143, 2169, 2170, 2173, 
-  2176, 2350, 2351, 2354, 2355, 2358, 2359, 2362, 4136, 20619, 
+  41, 42, 100, 161, 165, 178, 188, 288, 2141, 2142, 2143, 2169, 2170, 2173,
+  2176, 2350, 2351, 2354, 2355, 2358, 2359, 2362, 4136, 20619,
 };
 
 static const unsigned short dep8[] = {
-  100, 288, 2169, 2170, 2172, 2173, 2175, 2176, 2178, 2350, 2352, 2354, 2356, 
-  2358, 2360, 2362, 
+  100, 288, 2169, 2170, 2172, 2173, 2175, 2176, 2178, 2350, 2352, 2354, 2356,
+  2358, 2360, 2362,
 };
 
 static const unsigned short dep9[] = {
-  41, 42, 100, 161, 165, 178, 188, 288, 2141, 2142, 2143, 2169, 2170, 2173, 
-  2176, 2350, 2352, 2353, 2356, 2357, 2360, 2361, 4136, 20619, 
+  41, 42, 100, 161, 165, 178, 188, 288, 2141, 2142, 2143, 2169, 2170, 2173,
+  2176, 2350, 2352, 2353, 2356, 2357, 2360, 2361, 4136, 20619,
 };
 
 static const unsigned short dep10[] = {
-  100, 288, 2169, 2170, 2172, 2173, 2175, 2176, 2178, 2350, 2351, 2352, 2353, 
-  2354, 2355, 2356, 2357, 2358, 2359, 2360, 2361, 2362, 
+  100, 288, 2169, 2170, 2172, 2173, 2175, 2176, 2178, 2350, 2351, 2352, 2353,
+  2354, 2355, 2356, 2357, 2358, 2359, 2360, 2361, 2362,
 };
 
 static const unsigned short dep11[] = {
-  41, 42, 100, 161, 165, 178, 188, 288, 2141, 2142, 2143, 2169, 2170, 2173, 
-  2176, 2350, 2351, 2352, 2353, 2354, 2355, 2356, 2357, 2358, 2359, 2360, 2361, 
-  2362, 4136, 20619, 
+  41, 42, 100, 161, 165, 178, 188, 288, 2141, 2142, 2143, 2169, 2170, 2173,
+  2176, 2350, 2351, 2352, 2353, 2354, 2355, 2356, 2357, 2358, 2359, 2360, 2361,
+  2362, 4136, 20619,
 };
 
 static const unsigned short dep12[] = {
-  100, 288, 2401, 
+  100, 288, 2401,
 };
 
 static const unsigned short dep13[] = {
-  41, 42, 100, 161, 165, 167, 178, 188, 189, 191, 288, 2083, 2084, 2169, 2171, 
-  2172, 2174, 2175, 2177, 2178, 4136, 
+  41, 42, 100, 161, 165, 167, 178, 188, 189, 191, 288, 2083, 2084, 2169, 2171,
+  2172, 2174, 2175, 2177, 2178, 4136,
 };
 
 static const unsigned short dep14[] = {
-  100, 166, 288, 331, 2401, 28869, 29024, 
+  100, 166, 288, 331, 2401, 28869, 29024,
 };
 
 static const unsigned short dep15[] = {
-  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 
-  22, 23, 24, 25, 26, 28, 29, 30, 31, 32, 33, 34, 41, 42, 100, 153, 155, 161, 
-  165, 167, 178, 188, 189, 191, 288, 331, 2083, 2084, 2169, 2171, 2172, 2174, 
-  2175, 2177, 2178, 4136, 28869, 29024, 
+  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
+  22, 23, 24, 25, 26, 28, 29, 30, 31, 32, 33, 34, 41, 42, 100, 153, 155, 161,
+  165, 167, 178, 188, 189, 191, 288, 331, 2083, 2084, 2169, 2171, 2172, 2174,
+  2175, 2177, 2178, 4136, 28869, 29024,
 };
 
 static const unsigned short dep16[] = {
-  1, 6, 41, 77, 100, 140, 199, 204, 245, 272, 288, 318, 2401, 28869, 29024, 
-  
+  1, 6, 41, 77, 100, 140, 199, 204, 245, 272, 288, 318, 2401, 28869, 29024,
+
 };
 
 static const unsigned short dep17[] = {
-  1, 25, 27, 39, 41, 42, 100, 161, 165, 167, 169, 170, 178, 188, 189, 191, 199, 
-  204, 245, 272, 288, 318, 2083, 2084, 2169, 2171, 2172, 2174, 2175, 2177, 2178, 
-  4136, 28869, 29024, 
+  1, 25, 27, 39, 41, 42, 100, 161, 165, 167, 169, 170, 178, 188, 189, 191, 199,
+  204, 245, 272, 288, 318, 2083, 2084, 2169, 2171, 2172, 2174, 2175, 2177, 2178,
+  4136, 28869, 29024,
 };
 
 static const unsigned short dep18[] = {
-  1, 41, 52, 100, 199, 245, 252, 288, 28869, 29024, 
+  1, 41, 52, 100, 199, 245, 252, 288, 28869, 29024,
 };
 
 static const unsigned short dep19[] = {
-  1, 39, 41, 42, 100, 161, 163, 164, 165, 178, 188, 193, 194, 199, 245, 252, 
-  288, 4136, 28869, 29024, 
+  1, 39, 41, 42, 100, 161, 163, 164, 165, 178, 188, 193, 194, 199, 245, 252,
+  288, 4136, 28869, 29024,
 };
 
 static const unsigned short dep20[] = {
-  41, 100, 245, 288, 
+  41, 100, 245, 288,
 };
 
 static const unsigned short dep21[] = {
-  100, 161, 165, 178, 188, 245, 288, 
+  100, 161, 165, 178, 188, 245, 288,
 };
 
 static const unsigned short dep22[] = {
-  1, 41, 100, 134, 138, 139, 141, 142, 145, 146, 149, 152, 155, 158, 159, 160, 
-  161, 164, 165, 166, 167, 170, 171, 172, 173, 176, 177, 178, 181, 184, 187, 
-  188, 191, 192, 194, 199, 245, 272, 288, 315, 316, 317, 318, 319, 320, 321, 
-  322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 336, 337, 
-  339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 28869, 29024, 
-  
+  1, 41, 100, 134, 138, 139, 141, 142, 145, 146, 149, 152, 155, 158, 159, 160,
+  161, 164, 165, 166, 167, 170, 171, 172, 173, 176, 177, 178, 181, 184, 187,
+  188, 191, 192, 194, 199, 245, 272, 288, 315, 316, 317, 318, 319, 320, 321,
+  322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 336, 337,
+  339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 28869, 29024,
+
 };
 
 static const unsigned short dep23[] = {
-  1, 39, 41, 42, 51, 52, 57, 60, 75, 100, 140, 141, 161, 165, 178, 188, 193, 
-  194, 199, 245, 272, 288, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 
-  325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 336, 337, 339, 340, 341, 
-  342, 343, 344, 345, 346, 347, 348, 349, 350, 4136, 28869, 29024, 
+  1, 39, 41, 42, 51, 52, 57, 60, 75, 100, 140, 141, 161, 165, 178, 188, 193,
+  194, 199, 245, 272, 288, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324,
+  325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 336, 337, 339, 340, 341,
+  342, 343, 344, 345, 346, 347, 348, 349, 350, 4136, 28869, 29024,
 };
 
 static const unsigned short dep24[] = {
-  100, 139, 288, 317, 
+  100, 139, 288, 317,
 };
 
 static const unsigned short dep25[] = {
-  100, 140, 141, 161, 165, 178, 188, 193, 194, 288, 317, 
+  100, 140, 141, 161, 165, 178, 188, 193, 194, 288, 317,
 };
 
 static const unsigned short dep26[] = {
-  100, 140, 288, 318, 
+  100, 140, 288, 318,
 };
 
 static const unsigned short dep27[] = {
-  25, 26, 100, 101, 104, 108, 111, 140, 141, 161, 165, 167, 178, 188, 288, 318, 
-  
+  25, 26, 100, 101, 104, 108, 111, 140, 141, 161, 165, 167, 178, 188, 288, 318,
+
 };
 
 static const unsigned short dep28[] = {
-  100, 193, 288, 350, 
+  100, 193, 288, 350,
 };
 
 static const unsigned short dep29[] = {
-  100, 101, 104, 108, 111, 140, 141, 161, 165, 167, 178, 188, 288, 350, 
+  100, 101, 104, 108, 111, 140, 141, 161, 165, 167, 178, 188, 288, 350,
 };
 
 static const unsigned short dep30[] = {
-  41, 42, 100, 161, 165, 178, 188, 288, 2169, 2171, 2172, 2174, 2175, 2177, 
-  2178, 4136, 
+  41, 42, 100, 161, 165, 178, 188, 288, 2169, 2171, 2172, 2174, 2175, 2177,
+  2178, 4136,
 };
 
 static const unsigned short dep31[] = {
-  1, 25, 41, 77, 100, 199, 231, 232, 245, 272, 288, 2083, 2289, 2292, 2401, 
-  28869, 29024, 
+  1, 25, 41, 77, 100, 199, 231, 232, 245, 272, 288, 2083, 2289, 2292, 2401,
+  28869, 29024,
 };
 
 static const unsigned short dep32[] = {
-  1, 6, 39, 41, 42, 77, 100, 140, 141, 161, 165, 167, 178, 188, 189, 191, 199, 
-  231, 233, 245, 272, 288, 2083, 2084, 2169, 2171, 2172, 2174, 2175, 2177, 2178, 
-  2290, 2292, 4136, 28869, 29024, 
+  1, 6, 39, 41, 42, 77, 100, 140, 141, 161, 165, 167, 178, 188, 189, 191, 199,
+  231, 233, 245, 272, 288, 2083, 2084, 2169, 2171, 2172, 2174, 2175, 2177, 2178,
+  2290, 2292, 4136, 28869, 29024,
 };
 
 static const unsigned short dep33[] = {
-  100, 288, 
+  100, 288,
 };
 
 static const unsigned short dep34[] = {
-  100, 161, 165, 178, 188, 288, 2083, 2085, 
+  100, 161, 165, 178, 188, 288, 2083, 2085,
 };
 
 static const unsigned short dep35[] = {
-  41, 42, 100, 161, 165, 167, 178, 188, 189, 191, 288, 2169, 2171, 2172, 2174, 
-  2175, 2177, 2178, 4136, 
+  41, 42, 100, 161, 165, 167, 178, 188, 189, 191, 288, 2169, 2171, 2172, 2174,
+  2175, 2177, 2178, 4136,
 };
 
 static const unsigned short dep36[] = {
-  6, 38, 39, 40, 100, 128, 129, 204, 245, 288, 313, 314, 2401, 
+  6, 38, 39, 40, 100, 128, 129, 204, 245, 288, 313, 314, 2401,
 };
 
 static const unsigned short dep37[] = {
-  6, 38, 41, 42, 100, 161, 165, 167, 178, 188, 189, 191, 204, 245, 288, 313, 
-  314, 353, 2169, 2171, 2172, 2174, 2175, 2177, 2178, 4136, 
+  6, 38, 41, 42, 100, 161, 165, 167, 178, 188, 189, 191, 204, 245, 288, 313,
+  314, 353, 2169, 2171, 2172, 2174, 2175, 2177, 2178, 4136,
 };
 
 static const unsigned short dep38[] = {
-  24, 100, 230, 288, 2401, 
+  24, 100, 230, 288, 2401,
 };
 
 static const unsigned short dep39[] = {
-  24, 41, 42, 100, 161, 165, 167, 178, 188, 189, 191, 230, 288, 2169, 2171, 
-  2172, 2174, 2175, 2177, 2178, 4136, 
+  24, 41, 42, 100, 161, 165, 167, 178, 188, 189, 191, 230, 288, 2169, 2171,
+  2172, 2174, 2175, 2177, 2178, 4136,
 };
 
 static const unsigned short dep40[] = {
-  6, 24, 38, 39, 40, 100, 128, 129, 204, 230, 245, 288, 313, 314, 2401, 
+  6, 24, 38, 39, 40, 100, 128, 129, 204, 230, 245, 288, 313, 314, 2401,
 };
 
 static const unsigned short dep41[] = {
-  6, 24, 38, 41, 42, 100, 161, 165, 167, 178, 188, 189, 191, 204, 230, 245, 
-  288, 313, 314, 353, 2169, 2171, 2172, 2174, 2175, 2177, 2178, 4136, 
+  6, 24, 38, 41, 42, 100, 161, 165, 167, 178, 188, 189, 191, 204, 230, 245,
+  288, 313, 314, 353, 2169, 2171, 2172, 2174, 2175, 2177, 2178, 4136,
 };
 
 static const unsigned short dep42[] = {
-  1, 6, 39, 41, 42, 77, 100, 140, 141, 161, 165, 167, 178, 188, 189, 191, 199, 
-  231, 233, 245, 272, 288, 2169, 2171, 2172, 2174, 2175, 2177, 2178, 2290, 2292, 
-  4136, 28869, 29024, 
+  1, 6, 39, 41, 42, 77, 100, 140, 141, 161, 165, 167, 178, 188, 189, 191, 199,
+  231, 233, 245, 272, 288, 2169, 2171, 2172, 2174, 2175, 2177, 2178, 2290, 2292,
+  4136, 28869, 29024,
 };
 
 static const unsigned short dep43[] = {
-  100, 161, 165, 178, 188, 288, 
+  100, 161, 165, 178, 188, 288,
 };
 
 static const unsigned short dep44[] = {
-  15, 100, 213, 214, 288, 2139, 2331, 18604, 18605, 18767, 18768, 18770, 18771, 
-  22649, 22650, 22651, 22653, 22654, 22656, 22657, 22830, 22833, 22834, 22837, 
-  22838, 22841, 22842, 
+  15, 100, 213, 214, 288, 2139, 2331, 18604, 18605, 18767, 18768, 18770, 18771,
+  22649, 22650, 22651, 22653, 22654, 22656, 22657, 22830, 22833, 22834, 22837,
+  22838, 22841, 22842,
 };
 
 static const unsigned short dep45[] = {
-  11, 19, 20, 41, 42, 100, 161, 165, 178, 188, 213, 215, 288, 2138, 2139, 2140, 
-  2169, 2170, 2173, 2176, 2331, 4136, 16531, 16533, 16534, 16536, 18767, 18769, 
-  18770, 18772, 22830, 22833, 22834, 22837, 22838, 22841, 22842, 
+  11, 19, 20, 41, 42, 100, 161, 165, 178, 188, 213, 215, 288, 2138, 2139, 2140,
+  2169, 2170, 2173, 2176, 2331, 4136, 16531, 16533, 16534, 16536, 18767, 18769,
+  18770, 18772, 22830, 22833, 22834, 22837, 22838, 22841, 22842,
 };
 
 static const unsigned short dep46[] = {
-  15, 16, 17, 18, 100, 213, 214, 216, 217, 219, 220, 222, 223, 288, 2139, 2331, 
-  18604, 18605, 18767, 18768, 18770, 18771, 22649, 22650, 22651, 22653, 22654, 
-  22656, 22657, 22830, 22833, 22834, 22837, 22838, 22841, 22842, 
+  15, 16, 17, 18, 100, 213, 214, 216, 217, 219, 220, 222, 223, 288, 2139, 2331,
+  18604, 18605, 18767, 18768, 18770, 18771, 22649, 22650, 22651, 22653, 22654,
+  22656, 22657, 22830, 22833, 22834, 22837, 22838, 22841, 22842,
 };
 
 static const unsigned short dep47[] = {
-  11, 12, 13, 14, 19, 20, 41, 42, 100, 161, 165, 178, 188, 213, 215, 216, 218, 
-  219, 221, 222, 224, 288, 2138, 2139, 2140, 2169, 2170, 2173, 2176, 2331, 4136, 
-  16531, 16533, 16534, 16536, 18767, 18769, 18770, 18772, 22830, 22833, 22834, 
-  22837, 22838, 22841, 22842, 
+  11, 12, 13, 14, 19, 20, 41, 42, 100, 161, 165, 178, 188, 213, 215, 216, 218,
+  219, 221, 222, 224, 288, 2138, 2139, 2140, 2169, 2170, 2173, 2176, 2331, 4136,
+  16531, 16533, 16534, 16536, 18767, 18769, 18770, 18772, 22830, 22833, 22834,
+  22837, 22838, 22841, 22842,
 };
 
 static const unsigned short dep48[] = {
-  16, 100, 216, 217, 288, 2139, 2331, 18604, 18605, 18767, 18768, 18770, 18771, 
-  22649, 22650, 22651, 22653, 22654, 22656, 22657, 22830, 22833, 22834, 22837, 
-  22838, 22841, 22842, 
+  16, 100, 216, 217, 288, 2139, 2331, 18604, 18605, 18767, 18768, 18770, 18771,
+  22649, 22650, 22651, 22653, 22654, 22656, 22657, 22830, 22833, 22834, 22837,
+  22838, 22841, 22842,
 };
 
 static const unsigned short dep49[] = {
-  12, 19, 20, 41, 42, 100, 161, 165, 178, 188, 216, 218, 288, 2138, 2139, 2140, 
-  2169, 2170, 2173, 2176, 2331, 4136, 16531, 16533, 16534, 16536, 18767, 18769, 
-  18770, 18772, 22830, 22833, 22834, 22837, 22838, 22841, 22842, 
+  12, 19, 20, 41, 42, 100, 161, 165, 178, 188, 216, 218, 288, 2138, 2139, 2140,
+  2169, 2170, 2173, 2176, 2331, 4136, 16531, 16533, 16534, 16536, 18767, 18769,
+  18770, 18772, 22830, 22833, 22834, 22837, 22838, 22841, 22842,
 };
 
 static const unsigned short dep50[] = {
-  17, 100, 219, 220, 288, 2139, 2331, 18604, 18605, 18767, 18768, 18770, 18771, 
-  22649, 22650, 22651, 22653, 22654, 22656, 22657, 22830, 22833, 22834, 22837, 
-  22838, 22841, 22842, 
+  17, 100, 219, 220, 288, 2139, 2331, 18604, 18605, 18767, 18768, 18770, 18771,
+  22649, 22650, 22651, 22653, 22654, 22656, 22657, 22830, 22833, 22834, 22837,
+  22838, 22841, 22842,
 };
 
 static const unsigned short dep51[] = {
-  13, 19, 20, 41, 42, 100, 161, 165, 178, 188, 219, 221, 288, 2138, 2139, 2140, 
-  2169, 2170, 2173, 2176, 2331, 4136, 16531, 16533, 16534, 16536, 18767, 18769, 
-  18770, 18772, 22830, 22833, 22834, 22837, 22838, 22841, 22842, 
+  13, 19, 20, 41, 42, 100, 161, 165, 178, 188, 219, 221, 288, 2138, 2139, 2140,
+  2169, 2170, 2173, 2176, 2331, 4136, 16531, 16533, 16534, 16536, 18767, 18769,
+  18770, 18772, 22830, 22833, 22834, 22837, 22838, 22841, 22842,
 };
 
 static const unsigned short dep52[] = {
-  18, 100, 222, 223, 288, 2139, 2331, 18604, 18605, 18767, 18768, 18770, 18771, 
-  22649, 22650, 22651, 22653, 22654, 22656, 22657, 22830, 22833, 22834, 22837, 
-  22838, 22841, 22842, 
+  18, 100, 222, 223, 288, 2139, 2331, 18604, 18605, 18767, 18768, 18770, 18771,
+  22649, 22650, 22651, 22653, 22654, 22656, 22657, 22830, 22833, 22834, 22837,
+  22838, 22841, 22842,
 };
 
 static const unsigned short dep53[] = {
-  14, 19, 20, 41, 42, 100, 161, 165, 178, 188, 222, 224, 288, 2138, 2139, 2140, 
-  2169, 2170, 2173, 2176, 2331, 4136, 16531, 16533, 16534, 16536, 18767, 18769, 
-  18770, 18772, 22830, 22833, 22834, 22837, 22838, 22841, 22842, 
+  14, 19, 20, 41, 42, 100, 161, 165, 178, 188, 222, 224, 288, 2138, 2139, 2140,
+  2169, 2170, 2173, 2176, 2331, 4136, 16531, 16533, 16534, 16536, 18767, 18769,
+  18770, 18772, 22830, 22833, 22834, 22837, 22838, 22841, 22842,
 };
 
 static const unsigned short dep54[] = {
-  15, 100, 213, 214, 288, 2139, 2331, 18604, 18605, 18767, 18768, 18770, 18771, 
-  
+  15, 100, 213, 214, 288, 2139, 2331, 18604, 18605, 18767, 18768, 18770, 18771,
+
 };
 
 static const unsigned short dep55[] = {
-  11, 19, 20, 41, 42, 100, 161, 165, 178, 188, 213, 215, 288, 2138, 2139, 2140, 
-  2169, 2170, 2173, 2176, 2331, 4136, 16531, 16533, 16534, 16536, 18767, 18769, 
-  18770, 18772, 
+  11, 19, 20, 41, 42, 100, 161, 165, 178, 188, 213, 215, 288, 2138, 2139, 2140,
+  2169, 2170, 2173, 2176, 2331, 4136, 16531, 16533, 16534, 16536, 18767, 18769,
+  18770, 18772,
 };
 
 static const unsigned short dep56[] = {
-  15, 16, 17, 18, 100, 213, 214, 216, 217, 219, 220, 222, 223, 288, 2139, 2331, 
-  18604, 18605, 18767, 18768, 18770, 18771, 
+  15, 16, 17, 18, 100, 213, 214, 216, 217, 219, 220, 222, 223, 288, 2139, 2331,
+  18604, 18605, 18767, 18768, 18770, 18771,
 };
 
 static const unsigned short dep57[] = {
-  11, 12, 13, 14, 19, 20, 41, 42, 100, 161, 165, 178, 188, 213, 215, 216, 218, 
-  219, 221, 222, 224, 288, 2138, 2139, 2140, 2169, 2170, 2173, 2176, 2331, 4136, 
-  16531, 16533, 16534, 16536, 18767, 18769, 18770, 18772, 
+  11, 12, 13, 14, 19, 20, 41, 42, 100, 161, 165, 178, 188, 213, 215, 216, 218,
+  219, 221, 222, 224, 288, 2138, 2139, 2140, 2169, 2170, 2173, 2176, 2331, 4136,
+  16531, 16533, 16534, 16536, 18767, 18769, 18770, 18772,
 };
 
 static const unsigned short dep58[] = {
-  16, 100, 216, 217, 288, 2139, 2331, 18604, 18605, 18767, 18768, 18770, 18771, 
-  
+  16, 100, 216, 217, 288, 2139, 2331, 18604, 18605, 18767, 18768, 18770, 18771,
+
 };
 
 static const unsigned short dep59[] = {
-  12, 19, 20, 41, 42, 100, 161, 165, 178, 188, 216, 218, 288, 2138, 2139, 2140, 
-  2169, 2170, 2173, 2176, 2331, 4136, 16531, 16533, 16534, 16536, 18767, 18769, 
-  18770, 18772, 
+  12, 19, 20, 41, 42, 100, 161, 165, 178, 188, 216, 218, 288, 2138, 2139, 2140,
+  2169, 2170, 2173, 2176, 2331, 4136, 16531, 16533, 16534, 16536, 18767, 18769,
+  18770, 18772,
 };
 
 static const unsigned short dep60[] = {
-  17, 100, 219, 220, 288, 2139, 2331, 18604, 18605, 18767, 18768, 18770, 18771, 
-  
+  17, 100, 219, 220, 288, 2139, 2331, 18604, 18605, 18767, 18768, 18770, 18771,
+
 };
 
 static const unsigned short dep61[] = {
-  13, 19, 20, 41, 42, 100, 161, 165, 178, 188, 219, 221, 288, 2138, 2139, 2140, 
-  2169, 2170, 2173, 2176, 2331, 4136, 16531, 16533, 16534, 16536, 18767, 18769, 
-  18770, 18772, 
+  13, 19, 20, 41, 42, 100, 161, 165, 178, 188, 219, 221, 288, 2138, 2139, 2140,
+  2169, 2170, 2173, 2176, 2331, 4136, 16531, 16533, 16534, 16536, 18767, 18769,
+  18770, 18772,
 };
 
 static const unsigned short dep62[] = {
-  18, 100, 222, 223, 288, 2139, 2331, 18604, 18605, 18767, 18768, 18770, 18771, 
-  
+  18, 100, 222, 223, 288, 2139, 2331, 18604, 18605, 18767, 18768, 18770, 18771,
+
 };
 
 static const unsigned short dep63[] = {
-  14, 19, 20, 41, 42, 100, 161, 165, 178, 188, 222, 224, 288, 2138, 2139, 2140, 
-  2169, 2170, 2173, 2176, 2331, 4136, 16531, 16533, 16534, 16536, 18767, 18769, 
-  18770, 18772, 
+  14, 19, 20, 41, 42, 100, 161, 165, 178, 188, 222, 224, 288, 2138, 2139, 2140,
+  2169, 2170, 2173, 2176, 2331, 4136, 16531, 16533, 16534, 16536, 18767, 18769,
+  18770, 18772,
 };
 
 static const unsigned short dep64[] = {
-  100, 288, 2139, 2331, 18604, 18605, 18767, 18768, 18770, 18771, 
+  100, 288, 2139, 2331, 18604, 18605, 18767, 18768, 18770, 18771,
 };
 
 static const unsigned short dep65[] = {
-  41, 42, 100, 161, 165, 178, 188, 288, 2138, 2139, 2140, 2169, 2170, 2173, 
-  2176, 2331, 4136, 16531, 16533, 16534, 16536, 18767, 18769, 18770, 18772, 
-  
+  41, 42, 100, 161, 165, 178, 188, 288, 2138, 2139, 2140, 2169, 2170, 2173,
+  2176, 2331, 4136, 16531, 16533, 16534, 16536, 18767, 18769, 18770, 18772,
+
 };
 
 static const unsigned short dep66[] = {
-  11, 100, 209, 288, 
+  11, 100, 209, 288,
 };
 
 static const unsigned short dep67[] = {
-  11, 41, 42, 100, 161, 165, 178, 188, 209, 288, 2169, 2170, 2173, 2176, 4136, 
-  
+  11, 41, 42, 100, 161, 165, 178, 188, 209, 288, 2169, 2170, 2173, 2176, 4136,
+
 };
 
 static const unsigned short dep68[] = {
-  11, 41, 42, 100, 161, 165, 178, 188, 288, 2169, 2170, 2173, 2176, 4136, 
+  11, 41, 42, 100, 161, 165, 178, 188, 288, 2169, 2170, 2173, 2176, 4136,
 };
 
 static const unsigned short dep69[] = {
-  12, 100, 210, 288, 
+  12, 100, 210, 288,
 };
 
 static const unsigned short dep70[] = {
-  11, 41, 42, 100, 161, 165, 178, 188, 210, 288, 2169, 2170, 2173, 2176, 4136, 
-  
+  11, 41, 42, 100, 161, 165, 178, 188, 210, 288, 2169, 2170, 2173, 2176, 4136,
+
 };
 
 static const unsigned short dep71[] = {
-  13, 100, 211, 288, 
+  13, 100, 211, 288,
 };
 
 static const unsigned short dep72[] = {
-  11, 41, 42, 100, 161, 165, 178, 188, 211, 288, 2169, 2170, 2173, 2176, 4136, 
-  
+  11, 41, 42, 100, 161, 165, 178, 188, 211, 288, 2169, 2170, 2173, 2176, 4136,
+
 };
 
 static const unsigned short dep73[] = {
-  14, 100, 212, 288, 
+  14, 100, 212, 288,
 };
 
 static const unsigned short dep74[] = {
-  11, 41, 42, 100, 161, 165, 178, 188, 212, 288, 2169, 2170, 2173, 2176, 4136, 
-  
+  11, 41, 42, 100, 161, 165, 178, 188, 212, 288, 2169, 2170, 2173, 2176, 4136,
+
 };
 
 static const unsigned short dep75[] = {
-  15, 100, 214, 215, 288, 
+  15, 100, 214, 215, 288,
 };
 
 static const unsigned short dep76[] = {
-  41, 42, 100, 161, 165, 178, 188, 214, 215, 288, 2169, 2170, 2173, 2176, 4136, 
-  
+  41, 42, 100, 161, 165, 178, 188, 214, 215, 288, 2169, 2170, 2173, 2176, 4136,
+
 };
 
 static const unsigned short dep77[] = {
-  41, 42, 100, 161, 165, 178, 188, 288, 2169, 2170, 2173, 2176, 4136, 
+  41, 42, 100, 161, 165, 178, 188, 288, 2169, 2170, 2173, 2176, 4136,
 };
 
 static const unsigned short dep78[] = {
-  16, 100, 217, 218, 288, 
+  16, 100, 217, 218, 288,
 };
 
 static const unsigned short dep79[] = {
-  41, 42, 100, 161, 165, 178, 188, 217, 218, 288, 2169, 2170, 2173, 2176, 4136, 
-  
+  41, 42, 100, 161, 165, 178, 188, 217, 218, 288, 2169, 2170, 2173, 2176, 4136,
+
 };
 
 static const unsigned short dep80[] = {
-  17, 100, 220, 221, 288, 
+  17, 100, 220, 221, 288,
 };
 
 static const unsigned short dep81[] = {
-  41, 42, 100, 161, 165, 178, 188, 220, 221, 288, 2169, 2170, 2173, 2176, 4136, 
-  
+  41, 42, 100, 161, 165, 178, 188, 220, 221, 288, 2169, 2170, 2173, 2176, 4136,
+
 };
 
 static const unsigned short dep82[] = {
-  18, 100, 223, 224, 288, 
+  18, 100, 223, 224, 288,
 };
 
 static const unsigned short dep83[] = {
-  41, 42, 100, 161, 165, 178, 188, 223, 224, 288, 2169, 2170, 2173, 2176, 4136, 
-  
+  41, 42, 100, 161, 165, 178, 188, 223, 224, 288, 2169, 2170, 2173, 2176, 4136,
+
 };
 
 static const unsigned short dep84[] = {
-  15, 19, 20, 41, 42, 100, 161, 165, 167, 178, 188, 189, 191, 288, 2169, 2170, 
-  2173, 2176, 4136, 
+  15, 19, 20, 41, 42, 100, 161, 165, 167, 178, 188, 189, 191, 288, 2169, 2170,
+  2173, 2176, 4136,
 };
 
 static const unsigned short dep85[] = {
-  15, 16, 19, 20, 41, 42, 100, 161, 165, 167, 178, 188, 189, 191, 288, 2169, 
-  2170, 2173, 2176, 4136, 
+  15, 16, 19, 20, 41, 42, 100, 161, 165, 167, 178, 188, 189, 191, 288, 2169,
+  2170, 2173, 2176, 4136,
 };
 
 static const unsigned short dep86[] = {
-  15, 17, 19, 20, 41, 42, 100, 161, 165, 167, 178, 188, 189, 191, 288, 2169, 
-  2170, 2173, 2176, 4136, 
+  15, 17, 19, 20, 41, 42, 100, 161, 165, 167, 178, 188, 189, 191, 288, 2169,
+  2170, 2173, 2176, 4136,
 };
 
 static const unsigned short dep87[] = {
-  15, 18, 19, 20, 41, 42, 100, 161, 165, 167, 178, 188, 189, 191, 288, 2169, 
-  2170, 2173, 2176, 4136, 
+  15, 18, 19, 20, 41, 42, 100, 161, 165, 167, 178, 188, 189, 191, 288, 2169,
+  2170, 2173, 2176, 4136,
 };
 
 static const unsigned short dep88[] = {
-  15, 100, 213, 214, 288, 
+  15, 100, 213, 214, 288,
 };
 
 static const unsigned short dep89[] = {
-  11, 19, 20, 41, 42, 100, 161, 165, 178, 188, 213, 215, 288, 2169, 2170, 2173, 
-  2176, 4136, 
+  11, 19, 20, 41, 42, 100, 161, 165, 178, 188, 213, 215, 288, 2169, 2170, 2173,
+  2176, 4136,
 };
 
 static const unsigned short dep90[] = {
-  15, 16, 17, 18, 100, 213, 214, 216, 217, 219, 220, 222, 223, 288, 
+  15, 16, 17, 18, 100, 213, 214, 216, 217, 219, 220, 222, 223, 288,
 };
 
 static const unsigned short dep91[] = {
-  11, 12, 13, 14, 19, 20, 41, 42, 100, 161, 165, 178, 188, 213, 215, 216, 218, 
-  219, 221, 222, 224, 288, 2169, 2170, 2173, 2176, 4136, 
+  11, 12, 13, 14, 19, 20, 41, 42, 100, 161, 165, 178, 188, 213, 215, 216, 218,
+  219, 221, 222, 224, 288, 2169, 2170, 2173, 2176, 4136,
 };
 
 static const unsigned short dep92[] = {
-  16, 100, 216, 217, 288, 
+  16, 100, 216, 217, 288,
 };
 
 static const unsigned short dep93[] = {
-  12, 19, 20, 41, 42, 100, 161, 165, 178, 188, 216, 218, 288, 2169, 2170, 2173, 
-  2176, 4136, 
+  12, 19, 20, 41, 42, 100, 161, 165, 178, 188, 216, 218, 288, 2169, 2170, 2173,
+  2176, 4136,
 };
 
 static const unsigned short dep94[] = {
-  17, 100, 219, 220, 288, 
+  17, 100, 219, 220, 288,
 };
 
 static const unsigned short dep95[] = {
-  13, 19, 20, 41, 42, 100, 161, 165, 178, 188, 219, 221, 288, 2169, 2170, 2173, 
-  2176, 4136, 
+  13, 19, 20, 41, 42, 100, 161, 165, 178, 188, 219, 221, 288, 2169, 2170, 2173,
+  2176, 4136,
 };
 
 static const unsigned short dep96[] = {
-  18, 100, 222, 223, 288, 
+  18, 100, 222, 223, 288,
 };
 
 static const unsigned short dep97[] = {
-  14, 19, 20, 41, 42, 100, 161, 165, 178, 188, 222, 224, 288, 2169, 2170, 2173, 
-  2176, 4136, 
+  14, 19, 20, 41, 42, 100, 161, 165, 178, 188, 222, 224, 288, 2169, 2170, 2173,
+  2176, 4136,
 };
 
 static const unsigned short dep98[] = {
-  15, 100, 213, 214, 288, 2169, 2170, 2171, 2173, 2174, 2176, 2177, 2350, 2353, 
-  2354, 2357, 2358, 2361, 2362, 
+  15, 100, 213, 214, 288, 2169, 2170, 2171, 2173, 2174, 2176, 2177, 2350, 2353,
+  2354, 2357, 2358, 2361, 2362,
 };
 
 static const unsigned short dep99[] = {
-  11, 19, 20, 41, 42, 100, 161, 165, 178, 188, 213, 215, 288, 2138, 2139, 2140, 
-  2169, 2170, 2173, 2176, 2350, 2353, 2354, 2357, 2358, 2361, 2362, 4136, 16531, 
-  16533, 16534, 16536, 
+  11, 19, 20, 41, 42, 100, 161, 165, 178, 188, 213, 215, 288, 2138, 2139, 2140,
+  2169, 2170, 2173, 2176, 2350, 2353, 2354, 2357, 2358, 2361, 2362, 4136, 16531,
+  16533, 16534, 16536,
 };
 
 static const unsigned short dep100[] = {
-  15, 16, 17, 18, 100, 213, 214, 216, 217, 219, 220, 222, 223, 288, 2169, 2170, 
-  2171, 2173, 2174, 2176, 2177, 2350, 2353, 2354, 2357, 2358, 2361, 2362, 
+  15, 16, 17, 18, 100, 213, 214, 216, 217, 219, 220, 222, 223, 288, 2169, 2170,
+  2171, 2173, 2174, 2176, 2177, 2350, 2353, 2354, 2357, 2358, 2361, 2362,
 };
 
 static const unsigned short dep101[] = {
-  11, 12, 13, 14, 19, 20, 41, 42, 100, 161, 165, 178, 188, 213, 215, 216, 218, 
-  219, 221, 222, 224, 288, 2138, 2139, 2140, 2169, 2170, 2173, 2176, 2350, 2353, 
-  2354, 2357, 2358, 2361, 2362, 4136, 16531, 16533, 16534, 16536, 
+  11, 12, 13, 14, 19, 20, 41, 42, 100, 161, 165, 178, 188, 213, 215, 216, 218,
+  219, 221, 222, 224, 288, 2138, 2139, 2140, 2169, 2170, 2173, 2176, 2350, 2353,
+  2354, 2357, 2358, 2361, 2362, 4136, 16531, 16533, 16534, 16536,
 };
 
 static const unsigned short dep102[] = {
-  16, 100, 216, 217, 288, 2169, 2170, 2171, 2173, 2174, 2176, 2177, 2350, 2353, 
-  2354, 2357, 2358, 2361, 2362, 
+  16, 100, 216, 217, 288, 2169, 2170, 2171, 2173, 2174, 2176, 2177, 2350, 2353,
+  2354, 2357, 2358, 2361, 2362,
 };
 
 static const unsigned short dep103[] = {
-  12, 19, 20, 41, 42, 100, 161, 165, 178, 188, 216, 218, 288, 2138, 2139, 2140, 
-  2169, 2170, 2173, 2176, 2350, 2353, 2354, 2357, 2358, 2361, 2362, 4136, 16531, 
-  16533, 16534, 16536, 
+  12, 19, 20, 41, 42, 100, 161, 165, 178, 188, 216, 218, 288, 2138, 2139, 2140,
+  2169, 2170, 2173, 2176, 2350, 2353, 2354, 2357, 2358, 2361, 2362, 4136, 16531,
+  16533, 16534, 16536,
 };
 
 static const unsigned short dep104[] = {
-  17, 100, 219, 220, 288, 2169, 2170, 2171, 2173, 2174, 2176, 2177, 2350, 2353, 
-  2354, 2357, 2358, 2361, 2362, 
+  17, 100, 219, 220, 288, 2169, 2170, 2171, 2173, 2174, 2176, 2177, 2350, 2353,
+  2354, 2357, 2358, 2361, 2362,
 };
 
 static const unsigned short dep105[] = {
-  13, 19, 20, 41, 42, 100, 161, 165, 178, 188, 219, 221, 288, 2138, 2139, 2140, 
-  2169, 2170, 2173, 2176, 2350, 2353, 2354, 2357, 2358, 2361, 2362, 4136, 16531, 
-  16533, 16534, 16536, 
+  13, 19, 20, 41, 42, 100, 161, 165, 178, 188, 219, 221, 288, 2138, 2139, 2140,
+  2169, 2170, 2173, 2176, 2350, 2353, 2354, 2357, 2358, 2361, 2362, 4136, 16531,
+  16533, 16534, 16536,
 };
 
 static const unsigned short dep106[] = {
-  18, 100, 222, 223, 288, 2169, 2170, 2171, 2173, 2174, 2176, 2177, 2350, 2353, 
-  2354, 2357, 2358, 2361, 2362, 
+  18, 100, 222, 223, 288, 2169, 2170, 2171, 2173, 2174, 2176, 2177, 2350, 2353,
+  2354, 2357, 2358, 2361, 2362,
 };
 
 static const unsigned short dep107[] = {
-  14, 19, 20, 41, 42, 100, 161, 165, 178, 188, 222, 224, 288, 2138, 2139, 2140, 
-  2169, 2170, 2173, 2176, 2350, 2353, 2354, 2357, 2358, 2361, 2362, 4136, 16531, 
-  16533, 16534, 16536, 
+  14, 19, 20, 41, 42, 100, 161, 165, 178, 188, 222, 224, 288, 2138, 2139, 2140,
+  2169, 2170, 2173, 2176, 2350, 2353, 2354, 2357, 2358, 2361, 2362, 4136, 16531,
+  16533, 16534, 16536,
 };
 
 static const unsigned short dep108[] = {
-  15, 100, 213, 214, 288, 22649, 22650, 22651, 22653, 22654, 22656, 22657, 22830, 
-  22833, 22834, 22837, 22838, 22841, 22842, 
+  15, 100, 213, 214, 288, 22649, 22650, 22651, 22653, 22654, 22656, 22657, 22830,
+  22833, 22834, 22837, 22838, 22841, 22842,
 };
 
 static const unsigned short dep109[] = {
-  11, 19, 20, 41, 42, 100, 161, 165, 178, 188, 213, 215, 288, 2138, 2139, 2140, 
-  2169, 2170, 2173, 2176, 4136, 16531, 16533, 16534, 16536, 22830, 22833, 22834, 
-  22837, 22838, 22841, 22842, 
+  11, 19, 20, 41, 42, 100, 161, 165, 178, 188, 213, 215, 288, 2138, 2139, 2140,
+  2169, 2170, 2173, 2176, 4136, 16531, 16533, 16534, 16536, 22830, 22833, 22834,
+  22837, 22838, 22841, 22842,
 };
 
 static const unsigned short dep110[] = {
-  15, 16, 17, 18, 100, 213, 214, 216, 217, 219, 220, 222, 223, 288, 22649, 22650, 
-  22651, 22653, 22654, 22656, 22657, 22830, 22833, 22834, 22837, 22838, 22841, 
-  22842, 
+  15, 16, 17, 18, 100, 213, 214, 216, 217, 219, 220, 222, 223, 288, 22649, 22650,
+  22651, 22653, 22654, 22656, 22657, 22830, 22833, 22834, 22837, 22838, 22841,
+  22842,
 };
 
 static const unsigned short dep111[] = {
-  11, 12, 13, 14, 19, 20, 41, 42, 100, 161, 165, 178, 188, 213, 215, 216, 218, 
-  219, 221, 222, 224, 288, 2138, 2139, 2140, 2169, 2170, 2173, 2176, 4136, 16531, 
-  16533, 16534, 16536, 22830, 22833, 22834, 22837, 22838, 22841, 22842, 
+  11, 12, 13, 14, 19, 20, 41, 42, 100, 161, 165, 178, 188, 213, 215, 216, 218,
+  219, 221, 222, 224, 288, 2138, 2139, 2140, 2169, 2170, 2173, 2176, 4136, 16531,
+  16533, 16534, 16536, 22830, 22833, 22834, 22837, 22838, 22841, 22842,
 };
 
 static const unsigned short dep112[] = {
-  16, 100, 216, 217, 288, 22649, 22650, 22651, 22653, 22654, 22656, 22657, 22830, 
-  22833, 22834, 22837, 22838, 22841, 22842, 
+  16, 100, 216, 217, 288, 22649, 22650, 22651, 22653, 22654, 22656, 22657, 22830,
+  22833, 22834, 22837, 22838, 22841, 22842,
 };
 
 static const unsigned short dep113[] = {
-  12, 19, 20, 41, 42, 100, 161, 165, 178, 188, 216, 218, 288, 2138, 2139, 2140, 
-  2169, 2170, 2173, 2176, 4136, 16531, 16533, 16534, 16536, 22830, 22833, 22834, 
-  22837, 22838, 22841, 22842, 
+  12, 19, 20, 41, 42, 100, 161, 165, 178, 188, 216, 218, 288, 2138, 2139, 2140,
+  2169, 2170, 2173, 2176, 4136, 16531, 16533, 16534, 16536, 22830, 22833, 22834,
+  22837, 22838, 22841, 22842,
 };
 
 static const unsigned short dep114[] = {
-  17, 100, 219, 220, 288, 22649, 22650, 22651, 22653, 22654, 22656, 22657, 22830, 
-  22833, 22834, 22837, 22838, 22841, 22842, 
+  17, 100, 219, 220, 288, 22649, 22650, 22651, 22653, 22654, 22656, 22657, 22830,
+  22833, 22834, 22837, 22838, 22841, 22842,
 };
 
 static const unsigned short dep115[] = {
-  13, 19, 20, 41, 42, 100, 161, 165, 178, 188, 219, 221, 288, 2138, 2139, 2140, 
-  2169, 2170, 2173, 2176, 4136, 16531, 16533, 16534, 16536, 22830, 22833, 22834, 
-  22837, 22838, 22841, 22842, 
+  13, 19, 20, 41, 42, 100, 161, 165, 178, 188, 219, 221, 288, 2138, 2139, 2140,
+  2169, 2170, 2173, 2176, 4136, 16531, 16533, 16534, 16536, 22830, 22833, 22834,
+  22837, 22838, 22841, 22842,
 };
 
 static const unsigned short dep116[] = {
-  18, 100, 222, 223, 288, 22649, 22650, 22651, 22653, 22654, 22656, 22657, 22830, 
-  22833, 22834, 22837, 22838, 22841, 22842, 
+  18, 100, 222, 223, 288, 22649, 22650, 22651, 22653, 22654, 22656, 22657, 22830,
+  22833, 22834, 22837, 22838, 22841, 22842,
 };
 
 static const unsigned short dep117[] = {
-  14, 19, 20, 41, 42, 100, 161, 165, 178, 188, 222, 224, 288, 2138, 2139, 2140, 
-  2169, 2170, 2173, 2176, 4136, 16531, 16533, 16534, 16536, 22830, 22833, 22834, 
-  22837, 22838, 22841, 22842, 
+  14, 19, 20, 41, 42, 100, 161, 165, 178, 188, 222, 224, 288, 2138, 2139, 2140,
+  2169, 2170, 2173, 2176, 4136, 16531, 16533, 16534, 16536, 22830, 22833, 22834,
+  22837, 22838, 22841, 22842,
 };
 
 static const unsigned short dep118[] = {
-  100, 288, 2169, 2170, 2171, 2173, 2174, 2176, 2177, 2350, 2353, 2354, 2357, 
-  2358, 2361, 2362, 
+  100, 288, 2169, 2170, 2171, 2173, 2174, 2176, 2177, 2350, 2353, 2354, 2357,
+  2358, 2361, 2362,
 };
 
 static const unsigned short dep119[] = {
-  41, 42, 100, 161, 165, 178, 188, 288, 2138, 2139, 2140, 2169, 2170, 2173, 
-  2176, 2350, 2353, 2354, 2357, 2358, 2361, 2362, 4136, 16531, 16533, 16534, 
-  16536, 
+  41, 42, 100, 161, 165, 178, 188, 288, 2138, 2139, 2140, 2169, 2170, 2173,
+  2176, 2350, 2353, 2354, 2357, 2358, 2361, 2362, 4136, 16531, 16533, 16534,
+  16536,
 };
 
 static const unsigned short dep120[] = {
-  100, 288, 22649, 22650, 22651, 22653, 22654, 22656, 22657, 22830, 22833, 22834, 
-  22837, 22838, 22841, 22842, 
+  100, 288, 22649, 22650, 22651, 22653, 22654, 22656, 22657, 22830, 22833, 22834,
+  22837, 22838, 22841, 22842,
 };
 
 static const unsigned short dep121[] = {
-  41, 42, 100, 161, 165, 178, 188, 288, 2138, 2139, 2140, 2169, 2170, 2173, 
-  2176, 4136, 16531, 16533, 16534, 16536, 22830, 22833, 22834, 22837, 22838, 
-  22841, 22842, 
+  41, 42, 100, 161, 165, 178, 188, 288, 2138, 2139, 2140, 2169, 2170, 2173,
+  2176, 4136, 16531, 16533, 16534, 16536, 22830, 22833, 22834, 22837, 22838,
+  22841, 22842,
 };
 
 static const unsigned short dep122[] = {
-  19, 20, 41, 42, 100, 161, 165, 178, 188, 288, 2138, 2139, 2140, 2169, 2170, 
-  2173, 2176, 2331, 4136, 16531, 16533, 16534, 16536, 18767, 18769, 18770, 18772, 
-  
+  19, 20, 41, 42, 100, 161, 165, 178, 188, 288, 2138, 2139, 2140, 2169, 2170,
+  2173, 2176, 2331, 4136, 16531, 16533, 16534, 16536, 18767, 18769, 18770, 18772,
+
 };
 
 static const unsigned short dep123[] = {
-  41, 42, 100, 161, 165, 167, 178, 188, 189, 191, 288, 2141, 2142, 2143, 2169, 
-  2170, 2173, 2176, 4136, 20619, 
+  41, 42, 100, 161, 165, 167, 178, 188, 189, 191, 288, 2141, 2142, 2143, 2169,
+  2170, 2173, 2176, 4136, 20619,
 };
 
 static const unsigned short dep124[] = {
-  100, 288, 2084, 2085, 2290, 2291, 
+  100, 288, 2084, 2085, 2290, 2291,
 };
 
 static const unsigned short dep125[] = {
-  41, 42, 100, 161, 165, 178, 188, 288, 2141, 2142, 2143, 2169, 2170, 2173, 
-  2176, 2289, 2291, 4136, 20619, 
+  41, 42, 100, 161, 165, 178, 188, 288, 2141, 2142, 2143, 2169, 2170, 2173,
+  2176, 2289, 2291, 4136, 20619,
 };
 
 static const unsigned short dep126[] = {
-  41, 42, 100, 161, 165, 178, 188, 288, 2083, 2085, 2169, 2170, 2173, 2176, 
-  2333, 4136, 20619, 
+  41, 42, 100, 161, 165, 178, 188, 288, 2083, 2085, 2169, 2170, 2173, 2176,
+  2333, 4136, 20619,
 };
 
 static const unsigned short dep127[] = {
-  100, 288, 14458, 14460, 14461, 14463, 14464, 14466, 14641, 14642, 14645, 14646, 
-  14649, 14650, 
+  100, 288, 14458, 14460, 14461, 14463, 14464, 14466, 14641, 14642, 14645, 14646,
+  14649, 14650,
 };
 
 static const unsigned short dep128[] = {
-  41, 42, 100, 161, 165, 178, 188, 288, 2141, 2142, 2143, 4136, 14641, 14642, 
-  14645, 14646, 14649, 14650, 20619, 24697, 24698, 24701, 24704, 
+  41, 42, 100, 161, 165, 178, 188, 288, 2141, 2142, 2143, 4136, 14641, 14642,
+  14645, 14646, 14649, 14650, 20619, 24697, 24698, 24701, 24704,
 };
 
 static const unsigned short dep129[] = {
-  100, 125, 127, 128, 130, 288, 309, 310, 313, 314, 
+  100, 125, 127, 128, 130, 288, 309, 310, 313, 314,
 };
 
 static const unsigned short dep130[] = {
-  41, 42, 100, 161, 165, 178, 188, 288, 309, 310, 313, 314, 4136, 24697, 24698, 
-  24701, 24704, 
+  41, 42, 100, 161, 165, 178, 188, 288, 309, 310, 313, 314, 4136, 24697, 24698,
+  24701, 24704,
 };
 
 static const unsigned short dep131[] = {
-  41, 42, 100, 161, 165, 178, 188, 288, 2169, 2170, 2173, 2176, 2333, 4136, 
-  20619, 
+  41, 42, 100, 161, 165, 178, 188, 288, 2169, 2170, 2173, 2176, 2333, 4136,
+  20619,
 };
 
 static const unsigned short dep132[] = {
-  41, 42, 100, 122, 125, 128, 161, 165, 178, 188, 288, 2333, 4136, 20619, 24697, 
-  
+  41, 42, 100, 122, 125, 128, 161, 165, 178, 188, 288, 2333, 4136, 20619, 24697,
+
 };
 
 static const unsigned short dep133[] = {
-  6, 24, 26, 27, 100, 204, 230, 233, 288, 2082, 2288, 
+  6, 24, 26, 27, 100, 204, 230, 233, 288, 2082, 2288,
 };
 
 static const unsigned short dep134[] = {
-  41, 42, 100, 161, 165, 178, 188, 204, 230, 232, 288, 2141, 2142, 2143, 2169, 
-  2170, 2173, 2176, 2288, 4136, 20619, 
+  41, 42, 100, 161, 165, 178, 188, 204, 230, 232, 288, 2141, 2142, 2143, 2169,
+  2170, 2173, 2176, 2288, 4136, 20619,
 };
 
 static const unsigned short dep135[] = {
-  6, 24, 25, 26, 41, 42, 100, 161, 165, 178, 188, 288, 2082, 2169, 2170, 2173, 
-  2176, 2333, 4136, 20619, 
+  6, 24, 25, 26, 41, 42, 100, 161, 165, 178, 188, 288, 2082, 2169, 2170, 2173,
+  2176, 2333, 4136, 20619,
 };
 
 static const unsigned short dep136[] = {
-  41, 42, 100, 161, 165, 178, 188, 288, 2169, 2170, 2173, 2176, 2350, 2353, 
-  2354, 2357, 2358, 2361, 2362, 4136, 
+  41, 42, 100, 161, 165, 178, 188, 288, 2169, 2170, 2173, 2176, 2350, 2353,
+  2354, 2357, 2358, 2361, 2362, 4136,
 };
 
 static const unsigned short dep137[] = {
-  41, 42, 100, 161, 165, 178, 188, 288, 2169, 2170, 2173, 2176, 4136, 22830, 
-  22833, 22834, 22837, 22838, 22841, 22842, 
+  41, 42, 100, 161, 165, 178, 188, 288, 2169, 2170, 2173, 2176, 4136, 22830,
+  22833, 22834, 22837, 22838, 22841, 22842,
 };
 
 static const unsigned short dep138[] = {
-  41, 42, 100, 161, 165, 178, 188, 288, 2169, 2170, 2173, 2176, 2350, 2351, 
-  2354, 2355, 2358, 2359, 2362, 4136, 
+  41, 42, 100, 161, 165, 178, 188, 288, 2169, 2170, 2173, 2176, 2350, 2351,
+  2354, 2355, 2358, 2359, 2362, 4136,
 };
 
 static const unsigned short dep139[] = {
-  41, 42, 100, 161, 165, 178, 188, 288, 2169, 2170, 2173, 2176, 2350, 2352, 
-  2353, 2356, 2357, 2360, 2361, 4136, 
+  41, 42, 100, 161, 165, 178, 188, 288, 2169, 2170, 2173, 2176, 2350, 2352,
+  2353, 2356, 2357, 2360, 2361, 4136,
 };
 
 static const unsigned short dep140[] = {
-  41, 42, 100, 161, 165, 178, 188, 288, 2169, 2170, 2173, 2176, 2350, 2351, 
-  2352, 2353, 2354, 2355, 2356, 2357, 2358, 2359, 2360, 2361, 2362, 4136, 
+  41, 42, 100, 161, 165, 178, 188, 288, 2169, 2170, 2173, 2176, 2350, 2351,
+  2352, 2353, 2354, 2355, 2356, 2357, 2358, 2359, 2360, 2361, 2362, 4136,
 };
 
 static const unsigned short dep141[] = {
-  0, 41, 42, 100, 161, 165, 167, 178, 188, 189, 191, 288, 2169, 2170, 2173, 
-  2176, 4136, 
+  0, 41, 42, 100, 161, 165, 167, 178, 188, 189, 191, 288, 2169, 2170, 2173,
+  2176, 4136,
 };
 
 static const unsigned short dep142[] = {
-  0, 100, 198, 288, 
+  0, 100, 198, 288,
 };
 
 static const unsigned short dep143[] = {
-  0, 41, 42, 100, 161, 165, 167, 178, 188, 189, 191, 198, 288, 2169, 2170, 2173, 
-  2176, 4136, 
+  0, 41, 42, 100, 161, 165, 167, 178, 188, 189, 191, 198, 288, 2169, 2170, 2173,
+  2176, 4136,
 };
 
 static const unsigned short dep144[] = {
-  41, 42, 100, 161, 165, 178, 188, 198, 288, 2169, 2170, 2173, 2176, 4136, 
+  41, 42, 100, 161, 165, 178, 188, 198, 288, 2169, 2170, 2173, 2176, 4136,
 };
 
 static const unsigned short dep145[] = {
-  2, 28, 100, 200, 234, 288, 28869, 29024, 
+  2, 28, 100, 200, 234, 288, 28869, 29024,
 };
 
 static const unsigned short dep146[] = {
-  1, 2, 28, 29, 100, 161, 165, 178, 180, 181, 188, 200, 234, 288, 28869, 29024, 
-  
+  1, 2, 28, 29, 100, 161, 165, 178, 180, 181, 188, 200, 234, 288, 28869, 29024,
+
 };
 
 static const unsigned short dep147[] = {
-  1, 28, 29, 39, 41, 42, 100, 161, 165, 178, 180, 181, 188, 200, 234, 288, 4136, 
-  28869, 29024, 
+  1, 28, 29, 39, 41, 42, 100, 161, 165, 178, 180, 181, 188, 200, 234, 288, 4136,
+  28869, 29024,
 };
 
 static const unsigned short dep148[] = {
-  0, 41, 42, 100, 161, 165, 178, 188, 198, 288, 2169, 2170, 2173, 2176, 4136, 
-  
+  0, 41, 42, 100, 161, 165, 178, 188, 198, 288, 2169, 2170, 2173, 2176, 4136,
+
 };
 
 static const unsigned short dep149[] = {
-  1, 2, 3, 4, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 
-  28, 29, 30, 31, 32, 100, 199, 200, 201, 202, 203, 205, 206, 207, 208, 209, 
-  210, 211, 212, 214, 215, 217, 218, 220, 221, 223, 224, 225, 226, 227, 228, 
-  234, 235, 236, 237, 238, 272, 288, 2071, 2082, 2277, 2288, 28869, 29024, 
+  1, 2, 3, 4, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,
+  28, 29, 30, 31, 32, 100, 199, 200, 201, 202, 203, 205, 206, 207, 208, 209,
+  210, 211, 212, 214, 215, 217, 218, 220, 221, 223, 224, 225, 226, 227, 228,
+  234, 235, 236, 237, 238, 272, 288, 2071, 2082, 2277, 2288, 28869, 29024,
 };
 
 static const unsigned short dep150[] = {
-  29, 41, 42, 100, 140, 141, 161, 165, 178, 188, 193, 194, 199, 200, 201, 202, 
-  203, 205, 206, 207, 208, 209, 210, 211, 212, 214, 215, 217, 218, 220, 221, 
-  223, 224, 225, 226, 227, 228, 234, 235, 236, 237, 238, 272, 288, 2141, 2142, 
-  2143, 2169, 2170, 2173, 2176, 2277, 2288, 4136, 20619, 28869, 29024, 
+  29, 41, 42, 100, 140, 141, 161, 165, 178, 188, 193, 194, 199, 200, 201, 202,
+  203, 205, 206, 207, 208, 209, 210, 211, 212, 214, 215, 217, 218, 220, 221,
+  223, 224, 225, 226, 227, 228, 234, 235, 236, 237, 238, 272, 288, 2141, 2142,
+  2143, 2169, 2170, 2173, 2176, 2277, 2288, 4136, 20619, 28869, 29024,
 };
 
 static const unsigned short dep151[] = {
-  77, 272, 
+  77, 272,
 };
 
 static const unsigned short dep152[] = {
-  272, 
+  272,
 };
 
 static const unsigned short dep153[] = {
-  100, 288, 14467, 14469, 14471, 14473, 14508, 14509, 14528, 14651, 14652, 14672, 
-  14673, 14675, 14676, 14685, 
+  100, 288, 14467, 14469, 14471, 14473, 14508, 14509, 14528, 14651, 14652, 14672,
+  14673, 14675, 14676, 14685,
 };
 
 static const unsigned short dep154[] = {
-  41, 42, 100, 161, 165, 178, 186, 187, 188, 288, 2169, 2170, 2173, 2176, 4136, 
-  14651, 14652, 14672, 14673, 14675, 14676, 14685, 
+  41, 42, 100, 161, 165, 178, 186, 187, 188, 288, 2169, 2170, 2173, 2176, 4136,
+  14651, 14652, 14672, 14673, 14675, 14676, 14685,
 };
 
 static const unsigned short dep155[] = {
-  14467, 14469, 14471, 14473, 14508, 14509, 14528, 14651, 14652, 14672, 14673, 
-  14675, 14676, 14685, 
+  14467, 14469, 14471, 14473, 14508, 14509, 14528, 14651, 14652, 14672, 14673,
+  14675, 14676, 14685,
 };
 
 static const unsigned short dep156[] = {
-  186, 187, 14651, 14652, 14672, 14673, 14675, 14676, 14685, 
+  186, 187, 14651, 14652, 14672, 14673, 14675, 14676, 14685,
 };
 
 static const unsigned short dep157[] = {
-  100, 288, 14468, 14469, 14472, 14473, 14483, 14484, 14486, 14487, 14489, 14490, 
-  14492, 14493, 14496, 14498, 14499, 14508, 14509, 14510, 14511, 14513, 14518, 
-  14519, 14521, 14522, 14528, 14651, 14652, 14658, 14659, 14660, 14661, 14663, 
-  14665, 14672, 14673, 14675, 14676, 14677, 14678, 14681, 14682, 14685, 
+  100, 288, 14468, 14469, 14472, 14473, 14483, 14484, 14486, 14487, 14489, 14490,
+  14492, 14493, 14496, 14498, 14499, 14508, 14509, 14510, 14511, 14513, 14518,
+  14519, 14521, 14522, 14528, 14651, 14652, 14658, 14659, 14660, 14661, 14663,
+  14665, 14672, 14673, 14675, 14676, 14677, 14678, 14681, 14682, 14685,
 };
 
 static const unsigned short dep158[] = {
-  41, 42, 100, 140, 141, 161, 165, 178, 188, 193, 194, 288, 2169, 2170, 2173, 
-  2176, 4136, 14651, 14652, 14658, 14659, 14660, 14661, 14663, 14665, 14672, 
-  14673, 14675, 14676, 14677, 14678, 14681, 14682, 14685, 34890, 
+  41, 42, 100, 140, 141, 161, 165, 178, 188, 193, 194, 288, 2169, 2170, 2173,
+  2176, 4136, 14651, 14652, 14658, 14659, 14660, 14661, 14663, 14665, 14672,
+  14673, 14675, 14676, 14677, 14678, 14681, 14682, 14685, 34890,
 };
 
 static const unsigned short dep159[] = {
-  41, 42, 100, 140, 141, 161, 165, 178, 188, 193, 194, 288, 2169, 2170, 2173, 
-  2176, 4136, 14651, 14652, 14658, 14659, 14660, 14661, 14663, 14665, 14672, 
-  14673, 14675, 14676, 14677, 14678, 14681, 14682, 14685, 
+  41, 42, 100, 140, 141, 161, 165, 178, 188, 193, 194, 288, 2169, 2170, 2173,
+  2176, 4136, 14651, 14652, 14658, 14659, 14660, 14661, 14663, 14665, 14672,
+  14673, 14675, 14676, 14677, 14678, 14681, 14682, 14685,
 };
 
 static const unsigned short dep160[] = {
-  1, 2, 3, 4, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 
-  28, 29, 30, 31, 32, 41, 42, 100, 140, 141, 161, 165, 178, 183, 184, 188, 193, 
-  194, 288, 2071, 2082, 2169, 2170, 2173, 2176, 2333, 4136, 20619, 28869, 
+  1, 2, 3, 4, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,
+  28, 29, 30, 31, 32, 41, 42, 100, 140, 141, 161, 165, 178, 183, 184, 188, 193,
+  194, 288, 2071, 2082, 2169, 2170, 2173, 2176, 2333, 4136, 20619, 28869,
 };
 
 static const unsigned short dep161[] = {
-  44, 45, 46, 47, 48, 49, 50, 51, 53, 54, 55, 56, 57, 58, 59, 60, 62, 63, 64, 
-  65, 66, 67, 69, 71, 72, 73, 74, 75, 97, 99, 100, 247, 248, 249, 250, 251, 
-  252, 253, 254, 255, 256, 257, 258, 260, 261, 262, 263, 264, 266, 268, 269, 
-  270, 287, 288, 2118, 2315, 
+  44, 45, 46, 47, 48, 49, 50, 51, 53, 54, 55, 56, 57, 58, 59, 60, 62, 63, 64,
+  65, 66, 67, 69, 71, 72, 73, 74, 75, 97, 99, 100, 247, 248, 249, 250, 251,
+  252, 253, 254, 255, 256, 257, 258, 260, 261, 262, 263, 264, 266, 268, 269,
+  270, 287, 288, 2118, 2315,
 };
 
 static const unsigned short dep162[] = {
-  41, 42, 99, 100, 140, 141, 161, 163, 164, 165, 178, 188, 193, 194, 247, 248, 
-  249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 260, 261, 262, 263, 264, 
-  266, 268, 269, 270, 287, 288, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 2315, 
-  4136, 20619, 
+  41, 42, 99, 100, 140, 141, 161, 163, 164, 165, 178, 188, 193, 194, 247, 248,
+  249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 260, 261, 262, 263, 264,
+  266, 268, 269, 270, 287, 288, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 2315,
+  4136, 20619,
 };
 
 static const unsigned short dep163[] = {
-  61, 98, 100, 259, 287, 288, 2143, 2333, 
+  61, 98, 100, 259, 287, 288, 2143, 2333,
 };
 
 static const unsigned short dep164[] = {
-  41, 42, 44, 45, 47, 49, 50, 52, 53, 54, 55, 56, 58, 59, 62, 63, 65, 66, 67, 
-  68, 69, 71, 72, 73, 97, 98, 100, 140, 141, 161, 163, 164, 165, 178, 188, 193, 
-  194, 259, 287, 288, 2109, 2118, 2169, 2170, 2173, 2176, 2333, 4136, 20619, 
-  
+  41, 42, 44, 45, 47, 49, 50, 52, 53, 54, 55, 56, 58, 59, 62, 63, 65, 66, 67,
+  68, 69, 71, 72, 73, 97, 98, 100, 140, 141, 161, 163, 164, 165, 178, 188, 193,
+  194, 259, 287, 288, 2109, 2118, 2169, 2170, 2173, 2176, 2333, 4136, 20619,
+
 };
 
 static const unsigned short dep165[] = {
-  2, 28, 42, 100, 200, 234, 245, 288, 2143, 2333, 28869, 29024, 
+  2, 28, 42, 100, 200, 234, 245, 288, 2143, 2333, 28869, 29024,
 };
 
 static const unsigned short dep166[] = {
-  2, 25, 26, 28, 29, 39, 41, 42, 100, 161, 165, 178, 180, 181, 188, 200, 234, 
-  245, 288, 2333, 4136, 20619, 28869, 29024, 
+  2, 25, 26, 28, 29, 39, 41, 42, 100, 161, 165, 178, 180, 181, 188, 200, 234,
+  245, 288, 2333, 4136, 20619, 28869, 29024,
 };
 
 static const unsigned short dep167[] = {
-  100, 132, 133, 136, 137, 143, 144, 147, 148, 150, 151, 153, 154, 156, 157, 
-  160, 162, 163, 168, 169, 172, 173, 174, 175, 177, 179, 180, 182, 183, 185, 
-  186, 189, 190, 192, 288, 315, 316, 320, 322, 323, 324, 325, 327, 329, 333, 
-  336, 337, 339, 340, 341, 342, 344, 345, 346, 348, 349, 
+  100, 132, 133, 136, 137, 143, 144, 147, 148, 150, 151, 153, 154, 156, 157,
+  160, 162, 163, 168, 169, 172, 173, 174, 175, 177, 179, 180, 182, 183, 185,
+  186, 189, 190, 192, 288, 315, 316, 320, 322, 323, 324, 325, 327, 329, 333,
+  336, 337, 339, 340, 341, 342, 344, 345, 346, 348, 349,
 };
 
 static const unsigned short dep168[] = {
-  41, 42, 100, 140, 141, 161, 165, 178, 188, 193, 194, 288, 315, 316, 320, 322, 
-  323, 324, 325, 327, 329, 333, 336, 337, 339, 340, 341, 342, 344, 345, 346, 
-  348, 349, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 4136, 20619, 34890, 
+  41, 42, 100, 140, 141, 161, 165, 178, 188, 193, 194, 288, 315, 316, 320, 322,
+  323, 324, 325, 327, 329, 333, 336, 337, 339, 340, 341, 342, 344, 345, 346,
+  348, 349, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 4136, 20619, 34890,
 };
 
 static const unsigned short dep169[] = {
-  100, 131, 133, 135, 137, 172, 173, 192, 288, 315, 316, 336, 337, 339, 340, 
-  349, 
+  100, 131, 133, 135, 137, 172, 173, 192, 288, 315, 316, 336, 337, 339, 340,
+  349,
 };
 
 static const unsigned short dep170[] = {
-  41, 42, 100, 161, 165, 178, 186, 187, 188, 288, 315, 316, 336, 337, 339, 340, 
-  349, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 4136, 20619, 
+  41, 42, 100, 161, 165, 178, 186, 187, 188, 288, 315, 316, 336, 337, 339, 340,
+  349, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 4136, 20619,
 };
 
 static const unsigned short dep171[] = {
-  41, 42, 100, 133, 134, 137, 138, 140, 141, 144, 145, 148, 149, 151, 152, 154, 
-  155, 157, 158, 160, 161, 162, 164, 165, 167, 168, 170, 171, 172, 173, 175, 
-  176, 177, 178, 179, 181, 182, 184, 185, 187, 188, 190, 191, 192, 193, 194, 
-  288, 2169, 2170, 2173, 2176, 2333, 4136, 20619, 
+  41, 42, 100, 133, 134, 137, 138, 140, 141, 144, 145, 148, 149, 151, 152, 154,
+  155, 157, 158, 160, 161, 162, 164, 165, 167, 168, 170, 171, 172, 173, 175,
+  176, 177, 178, 179, 181, 182, 184, 185, 187, 188, 190, 191, 192, 193, 194,
+  288, 2169, 2170, 2173, 2176, 2333, 4136, 20619,
 };
 
 static const unsigned short dep172[] = {
-  41, 42, 100, 133, 134, 137, 138, 161, 165, 172, 173, 178, 188, 192, 288, 2169, 
-  2170, 2173, 2176, 2333, 4136, 20619, 
+  41, 42, 100, 133, 134, 137, 138, 161, 165, 172, 173, 178, 188, 192, 288, 2169,
+  2170, 2173, 2176, 2333, 4136, 20619,
 };
 
 static const unsigned short dep173[] = {
-  41, 42, 72, 79, 80, 85, 87, 100, 114, 140, 141, 156, 158, 161, 165, 174, 176, 
-  178, 188, 195, 288, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 2333, 4136, 
-  20619, 
+  41, 42, 72, 79, 80, 85, 87, 100, 114, 140, 141, 156, 158, 161, 165, 174, 176,
+  178, 188, 195, 288, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 2333, 4136,
+  20619,
 };
 
 static const unsigned short dep174[] = {
-  41, 42, 72, 79, 80, 85, 87, 100, 114, 140, 141, 142, 143, 145, 146, 156, 158, 
-  161, 165, 174, 176, 178, 188, 195, 288, 2141, 2142, 2143, 2169, 2170, 2173, 
-  2176, 4136, 20619, 
+  41, 42, 72, 79, 80, 85, 87, 100, 114, 140, 141, 142, 143, 145, 146, 156, 158,
+  161, 165, 174, 176, 178, 188, 195, 288, 2141, 2142, 2143, 2169, 2170, 2173,
+  2176, 4136, 20619,
 };
 
 static const unsigned short dep175[] = {
-  80, 81, 100, 104, 105, 275, 276, 288, 290, 291, 
+  80, 81, 100, 104, 105, 275, 276, 288, 290, 291,
 };
 
 static const unsigned short dep176[] = {
-  41, 42, 48, 64, 81, 83, 89, 100, 102, 105, 140, 141, 161, 163, 164, 165, 178, 
-  188, 193, 194, 195, 275, 276, 288, 290, 291, 2141, 2142, 2143, 2169, 2170, 
-  2173, 2176, 4136, 20619, 
+  41, 42, 48, 64, 81, 83, 89, 100, 102, 105, 140, 141, 161, 163, 164, 165, 178,
+  188, 193, 194, 195, 275, 276, 288, 290, 291, 2141, 2142, 2143, 2169, 2170,
+  2173, 2176, 4136, 20619,
 };
 
 static const unsigned short dep177[] = {
-  41, 42, 48, 64, 81, 83, 100, 102, 105, 107, 109, 140, 141, 161, 163, 164, 
-  165, 178, 188, 193, 194, 195, 275, 276, 288, 290, 291, 2141, 2142, 2143, 2169, 
-  2170, 2173, 2176, 4136, 20619, 
+  41, 42, 48, 64, 81, 83, 100, 102, 105, 107, 109, 140, 141, 161, 163, 164,
+  165, 178, 188, 193, 194, 195, 275, 276, 288, 290, 291, 2141, 2142, 2143, 2169,
+  2170, 2173, 2176, 4136, 20619,
 };
 
 static const unsigned short dep178[] = {
-  100, 288, 12483, 12484, 12639, 
+  100, 288, 12483, 12484, 12639,
 };
 
 static const unsigned short dep179[] = {
-  41, 42, 100, 140, 141, 161, 165, 178, 188, 193, 194, 288, 2141, 2142, 2143, 
-  2169, 2170, 2173, 2176, 4136, 12639, 20619, 
+  41, 42, 100, 140, 141, 161, 165, 178, 188, 193, 194, 288, 2141, 2142, 2143,
+  2169, 2170, 2173, 2176, 4136, 12639, 20619,
 };
 
 static const unsigned short dep180[] = {
-  100, 288, 6222, 6223, 6417, 
+  100, 288, 6222, 6223, 6417,
 };
 
 static const unsigned short dep181[] = {
-  41, 42, 100, 140, 141, 161, 165, 178, 188, 193, 194, 288, 2141, 2142, 2143, 
-  2169, 2170, 2173, 2176, 4136, 6417, 20619, 
+  41, 42, 100, 140, 141, 161, 165, 178, 188, 193, 194, 288, 2141, 2142, 2143,
+  2169, 2170, 2173, 2176, 4136, 6417, 20619,
 };
 
 static const unsigned short dep182[] = {
-  100, 288, 6240, 6430, 
+  100, 288, 6240, 6430,
 };
 
 static const unsigned short dep183[] = {
-  41, 42, 100, 140, 141, 161, 165, 178, 188, 193, 194, 288, 2141, 2142, 2143, 
-  2169, 2170, 2173, 2176, 4136, 6430, 20619, 
+  41, 42, 100, 140, 141, 161, 165, 178, 188, 193, 194, 288, 2141, 2142, 2143,
+  2169, 2170, 2173, 2176, 4136, 6430, 20619,
 };
 
 static const unsigned short dep184[] = {
-  100, 288, 6258, 6259, 6260, 6261, 6441, 6443, 8490, 
+  100, 288, 6258, 6259, 6260, 6261, 6441, 6443, 8490,
 };
 
 static const unsigned short dep185[] = {
-  41, 42, 100, 140, 141, 161, 165, 178, 188, 193, 194, 288, 2141, 2142, 2143, 
-  2169, 2170, 2173, 2176, 4136, 6261, 6442, 6443, 8307, 8489, 20619, 
+  41, 42, 100, 140, 141, 161, 165, 178, 188, 193, 194, 288, 2141, 2142, 2143,
+  2169, 2170, 2173, 2176, 4136, 6261, 6442, 6443, 8307, 8489, 20619,
 };
 
 static const unsigned short dep186[] = {
-  100, 288, 6262, 6263, 6444, 
+  100, 288, 6262, 6263, 6444,
 };
 
 static const unsigned short dep187[] = {
-  41, 42, 100, 140, 141, 161, 165, 178, 188, 193, 194, 288, 2141, 2142, 2143, 
-  2169, 2170, 2173, 2176, 4136, 6444, 20619, 
+  41, 42, 100, 140, 141, 161, 165, 178, 188, 193, 194, 288, 2141, 2142, 2143,
+  2169, 2170, 2173, 2176, 4136, 6444, 20619,
 };
 
 static const unsigned short dep188[] = {
-  100, 288, 6264, 6445, 
+  100, 288, 6264, 6445,
 };
 
 static const unsigned short dep189[] = {
-  41, 42, 100, 140, 141, 161, 165, 178, 188, 193, 194, 288, 2141, 2142, 2143, 
-  2169, 2170, 2173, 2176, 4136, 6445, 20619, 
+  41, 42, 100, 140, 141, 161, 165, 178, 188, 193, 194, 288, 2141, 2142, 2143,
+  2169, 2170, 2173, 2176, 4136, 6445, 20619,
 };
 
 static const unsigned short dep190[] = {
-  100, 288, 10353, 10536, 
+  100, 288, 10353, 10536,
 };
 
 static const unsigned short dep191[] = {
-  41, 42, 100, 140, 141, 161, 165, 178, 188, 193, 194, 288, 2141, 2142, 2143, 
-  2169, 2170, 2173, 2176, 4136, 10536, 20619, 
+  41, 42, 100, 140, 141, 161, 165, 178, 188, 193, 194, 288, 2141, 2142, 2143,
+  2169, 2170, 2173, 2176, 4136, 10536, 20619,
 };
 
 static const unsigned short dep192[] = {
-  80, 81, 85, 86, 100, 104, 105, 275, 276, 278, 279, 288, 290, 291, 
+  80, 81, 85, 86, 100, 104, 105, 275, 276, 278, 279, 288, 290, 291,
 };
 
 static const unsigned short dep193[] = {
-  41, 42, 48, 64, 81, 83, 86, 89, 100, 102, 105, 140, 141, 161, 163, 164, 165, 
-  178, 188, 193, 194, 195, 275, 276, 278, 280, 288, 290, 291, 2141, 2142, 2143, 
-  2169, 2170, 2173, 2176, 4136, 20619, 
+  41, 42, 48, 64, 81, 83, 86, 89, 100, 102, 105, 140, 141, 161, 163, 164, 165,
+  178, 188, 193, 194, 195, 275, 276, 278, 280, 288, 290, 291, 2141, 2142, 2143,
+  2169, 2170, 2173, 2176, 4136, 20619,
 };
 
 static const unsigned short dep194[] = {
-  80, 81, 100, 104, 105, 107, 108, 275, 276, 288, 290, 291, 292, 293, 
+  80, 81, 100, 104, 105, 107, 108, 275, 276, 288, 290, 291, 292, 293,
 };
 
 static const unsigned short dep195[] = {
-  41, 42, 48, 64, 81, 83, 100, 102, 105, 107, 109, 140, 141, 161, 163, 164, 
-  165, 178, 188, 193, 194, 195, 275, 276, 288, 290, 291, 292, 293, 2141, 2142, 
-  2143, 2169, 2170, 2173, 2176, 4136, 20619, 
+  41, 42, 48, 64, 81, 83, 100, 102, 105, 107, 109, 140, 141, 161, 163, 164,
+  165, 178, 188, 193, 194, 195, 275, 276, 288, 290, 291, 292, 293, 2141, 2142,
+  2143, 2169, 2170, 2173, 2176, 4136, 20619,
 };
 
 static const unsigned short dep196[] = {
-  41, 42, 100, 140, 141, 161, 165, 178, 188, 193, 194, 288, 2141, 2142, 2143, 
-  2169, 2170, 2173, 2176, 2333, 4136, 12484, 20619, 
+  41, 42, 100, 140, 141, 161, 165, 178, 188, 193, 194, 288, 2141, 2142, 2143,
+  2169, 2170, 2173, 2176, 2333, 4136, 12484, 20619,
 };
 
 static const unsigned short dep197[] = {
-  41, 42, 100, 140, 141, 161, 165, 178, 188, 193, 194, 288, 2141, 2142, 2143, 
-  2169, 2170, 2173, 2176, 2333, 4136, 6222, 20619, 
+  41, 42, 100, 140, 141, 161, 165, 178, 188, 193, 194, 288, 2141, 2142, 2143,
+  2169, 2170, 2173, 2176, 2333, 4136, 6222, 20619,
 };
 
 static const unsigned short dep198[] = {
-  41, 42, 100, 140, 141, 161, 165, 178, 188, 193, 194, 288, 2141, 2142, 2143, 
-  2169, 2170, 2173, 2176, 2333, 4136, 6240, 20619, 
+  41, 42, 100, 140, 141, 161, 165, 178, 188, 193, 194, 288, 2141, 2142, 2143,
+  2169, 2170, 2173, 2176, 2333, 4136, 6240, 20619,
 };
 
 static const unsigned short dep199[] = {
-  41, 42, 100, 140, 141, 161, 165, 178, 188, 193, 194, 288, 2141, 2142, 2143, 
-  2169, 2170, 2173, 2176, 2333, 4136, 6260, 8306, 20619, 
+  41, 42, 100, 140, 141, 161, 165, 178, 188, 193, 194, 288, 2141, 2142, 2143,
+  2169, 2170, 2173, 2176, 2333, 4136, 6260, 8306, 20619,
 };
 
 static const unsigned short dep200[] = {
-  41, 42, 100, 140, 141, 161, 165, 178, 188, 193, 194, 288, 2141, 2142, 2143, 
-  2169, 2170, 2173, 2176, 2333, 4136, 6262, 20619, 
+  41, 42, 100, 140, 141, 161, 165, 178, 188, 193, 194, 288, 2141, 2142, 2143,
+  2169, 2170, 2173, 2176, 2333, 4136, 6262, 20619,
 };
 
 static const unsigned short dep201[] = {
-  41, 42, 100, 140, 141, 161, 165, 178, 186, 187, 188, 288, 2141, 2142, 2143, 
-  2169, 2170, 2173, 2176, 2333, 4136, 6263, 6264, 20619, 
+  41, 42, 100, 140, 141, 161, 165, 178, 186, 187, 188, 288, 2141, 2142, 2143,
+  2169, 2170, 2173, 2176, 2333, 4136, 6263, 6264, 20619,
 };
 
 static const unsigned short dep202[] = {
-  41, 42, 100, 161, 165, 178, 188, 288, 2141, 2142, 2143, 2169, 2170, 2173, 
-  2176, 2333, 4136, 10353, 20619, 
+  41, 42, 100, 161, 165, 178, 188, 288, 2141, 2142, 2143, 2169, 2170, 2173,
+  2176, 2333, 4136, 10353, 20619,
 };
 
 static const unsigned short dep203[] = {
-  41, 42, 100, 161, 165, 178, 188, 193, 194, 288, 2141, 2142, 2143, 2169, 2170, 
-  2173, 2176, 2333, 4136, 6187, 20619, 
+  41, 42, 100, 161, 165, 178, 188, 193, 194, 288, 2141, 2142, 2143, 2169, 2170,
+  2173, 2176, 2333, 4136, 6187, 20619,
 };
 
 static const unsigned short dep204[] = {
-  80, 82, 83, 100, 101, 102, 103, 274, 275, 288, 289, 290, 
+  80, 82, 83, 100, 101, 102, 103, 274, 275, 288, 289, 290,
 };
 
 static const unsigned short dep205[] = {
-  41, 42, 81, 82, 86, 88, 100, 103, 105, 107, 110, 140, 141, 161, 165, 178, 
-  188, 193, 194, 195, 274, 276, 288, 289, 291, 2141, 2142, 2143, 2169, 2170, 
-  2173, 2176, 4136, 20619, 
+  41, 42, 81, 82, 86, 88, 100, 103, 105, 107, 110, 140, 141, 161, 165, 178,
+  188, 193, 194, 195, 274, 276, 288, 289, 291, 2141, 2142, 2143, 2169, 2170,
+  2173, 2176, 4136, 20619,
 };
 
 static const unsigned short dep206[] = {
-  80, 82, 83, 84, 100, 101, 102, 103, 106, 274, 275, 277, 288, 289, 290, 
+  80, 82, 83, 84, 100, 101, 102, 103, 106, 274, 275, 277, 288, 289, 290,
 };
 
 static const unsigned short dep207[] = {
-  41, 42, 81, 82, 84, 86, 88, 100, 103, 105, 106, 107, 110, 140, 141, 161, 165, 
-  178, 188, 193, 194, 195, 274, 276, 277, 288, 289, 291, 2141, 2142, 2143, 2169, 
-  2170, 2173, 2176, 4136, 20619, 
+  41, 42, 81, 82, 84, 86, 88, 100, 103, 105, 106, 107, 110, 140, 141, 161, 165,
+  178, 188, 193, 194, 195, 274, 276, 277, 288, 289, 291, 2141, 2142, 2143, 2169,
+  2170, 2173, 2176, 4136, 20619,
 };
 
 static const unsigned short dep208[] = {
-  80, 82, 83, 87, 88, 89, 100, 101, 102, 103, 274, 275, 280, 281, 288, 289, 
-  290, 
+  80, 82, 83, 87, 88, 89, 100, 101, 102, 103, 274, 275, 280, 281, 288, 289,
+  290,
 };
 
 static const unsigned short dep209[] = {
-  41, 42, 81, 82, 86, 88, 100, 103, 105, 140, 141, 161, 165, 178, 188, 193, 
-  194, 195, 274, 276, 279, 281, 288, 289, 291, 2141, 2142, 2143, 2169, 2170, 
-  2173, 2176, 4136, 20619, 
+  41, 42, 81, 82, 86, 88, 100, 103, 105, 140, 141, 161, 165, 178, 188, 193,
+  194, 195, 274, 276, 279, 281, 288, 289, 291, 2141, 2142, 2143, 2169, 2170,
+  2173, 2176, 4136, 20619,
 };
 
 static const unsigned short dep210[] = {
-  80, 82, 83, 100, 101, 102, 103, 109, 110, 111, 274, 275, 288, 289, 290, 293, 
-  294, 
+  80, 82, 83, 100, 101, 102, 103, 109, 110, 111, 274, 275, 288, 289, 290, 293,
+  294,
 };
 
 static const unsigned short dep211[] = {
-  41, 42, 81, 82, 100, 103, 105, 107, 110, 140, 141, 161, 165, 178, 188, 193, 
-  194, 195, 274, 276, 288, 289, 291, 292, 294, 2141, 2142, 2143, 2169, 2170, 
-  2173, 2176, 4136, 20619, 
+  41, 42, 81, 82, 100, 103, 105, 107, 110, 140, 141, 161, 165, 178, 188, 193,
+  194, 195, 274, 276, 288, 289, 291, 292, 294, 2141, 2142, 2143, 2169, 2170,
+  2173, 2176, 4136, 20619,
 };
 
 static const unsigned short dep212[] = {
-  41, 42, 47, 72, 100, 161, 165, 178, 188, 193, 194, 195, 288, 2141, 2142, 2143, 
-  2169, 2170, 2173, 2176, 2333, 4136, 20619, 
+  41, 42, 47, 72, 100, 161, 165, 178, 188, 193, 194, 195, 288, 2141, 2142, 2143,
+  2169, 2170, 2173, 2176, 2333, 4136, 20619,
 };
 
 static const unsigned short dep213[] = {
-  41, 42, 100, 161, 165, 178, 188, 193, 194, 195, 288, 2141, 2142, 2143, 2169, 
-  2170, 2173, 2176, 2333, 4136, 20619, 
+  41, 42, 100, 161, 165, 178, 188, 193, 194, 195, 288, 2141, 2142, 2143, 2169,
+  2170, 2173, 2176, 2333, 4136, 20619,
 };
 
 static const unsigned short dep214[] = {
-  41, 42, 72, 80, 85, 87, 100, 140, 141, 156, 158, 161, 165, 178, 188, 193, 
-  194, 195, 288, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 2333, 4136, 20619, 
-  
+  41, 42, 72, 80, 85, 87, 100, 140, 141, 156, 158, 161, 165, 178, 188, 193,
+  194, 195, 288, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 2333, 4136, 20619,
+
 };
 
 static const unsigned short dep215[] = {
-  41, 42, 100, 161, 165, 167, 178, 188, 189, 191, 288, 2138, 2139, 2140, 2141, 
-  2142, 2143, 2169, 2170, 2173, 2176, 4136, 16531, 16533, 16534, 16536, 20619, 
-  
+  41, 42, 100, 161, 165, 167, 178, 188, 189, 191, 288, 2138, 2139, 2140, 2141,
+  2142, 2143, 2169, 2170, 2173, 2176, 4136, 16531, 16533, 16534, 16536, 20619,
+
 };
 
 static const unsigned short dep216[] = {
-  41, 42, 72, 80, 85, 87, 100, 156, 158, 161, 165, 178, 188, 195, 288, 2141, 
-  2142, 2143, 2169, 2170, 2173, 2176, 4136, 20619, 
+  41, 42, 72, 80, 85, 87, 100, 156, 158, 161, 165, 178, 188, 195, 288, 2141,
+  2142, 2143, 2169, 2170, 2173, 2176, 4136, 20619,
 };
 
 static const unsigned short dep217[] = {
-  41, 42, 81, 82, 100, 103, 140, 141, 161, 165, 178, 188, 193, 194, 274, 276, 
-  288, 289, 291, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 4136, 20619, 
+  41, 42, 81, 82, 100, 103, 140, 141, 161, 165, 178, 188, 193, 194, 274, 276,
+  288, 289, 291, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 4136, 20619,
 };
 
 static const unsigned short dep218[] = {
-  41, 42, 72, 77, 79, 80, 85, 87, 100, 112, 114, 131, 132, 134, 135, 136, 138, 
-  140, 141, 142, 143, 145, 146, 156, 158, 161, 165, 174, 176, 178, 188, 193, 
-  194, 195, 288, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 2333, 4136, 20619, 
-  
+  41, 42, 72, 77, 79, 80, 85, 87, 100, 112, 114, 131, 132, 134, 135, 136, 138,
+  140, 141, 142, 143, 145, 146, 156, 158, 161, 165, 174, 176, 178, 188, 193,
+  194, 195, 288, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 2333, 4136, 20619,
+
 };
 
 static const unsigned short dep219[] = {
-  41, 42, 45, 72, 77, 79, 80, 85, 87, 100, 112, 114, 131, 132, 134, 135, 136, 
-  138, 140, 141, 142, 143, 145, 146, 156, 158, 159, 161, 165, 174, 176, 178, 
-  188, 193, 194, 195, 288, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 2333, 4136, 
-  20619, 
+  41, 42, 45, 72, 77, 79, 80, 85, 87, 100, 112, 114, 131, 132, 134, 135, 136,
+  138, 140, 141, 142, 143, 145, 146, 156, 158, 159, 161, 165, 174, 176, 178,
+  188, 193, 194, 195, 288, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 2333, 4136,
+  20619,
 };
 
 static const unsigned short dep220[] = {
-  0, 100, 198, 288, 2143, 2333, 
+  0, 100, 198, 288, 2143, 2333,
 };
 
 static const unsigned short dep221[] = {
-  0, 41, 42, 72, 77, 79, 80, 85, 87, 100, 112, 114, 131, 132, 134, 135, 136, 
-  138, 140, 141, 142, 143, 145, 146, 156, 158, 161, 165, 174, 176, 178, 188, 
-  193, 194, 195, 198, 288, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 2333, 4136, 
-  20619, 
+  0, 41, 42, 72, 77, 79, 80, 85, 87, 100, 112, 114, 131, 132, 134, 135, 136,
+  138, 140, 141, 142, 143, 145, 146, 156, 158, 161, 165, 174, 176, 178, 188,
+  193, 194, 195, 198, 288, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 2333, 4136,
+  20619,
 };
 
 static const unsigned short dep222[] = {
-  0, 41, 42, 45, 72, 77, 79, 80, 85, 87, 100, 112, 114, 131, 132, 134, 135, 
-  136, 138, 140, 141, 142, 143, 145, 146, 156, 158, 159, 161, 165, 174, 176, 
-  178, 188, 193, 194, 195, 198, 288, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 
-  2333, 4136, 20619, 
+  0, 41, 42, 45, 72, 77, 79, 80, 85, 87, 100, 112, 114, 131, 132, 134, 135,
+  136, 138, 140, 141, 142, 143, 145, 146, 156, 158, 159, 161, 165, 174, 176,
+  178, 188, 193, 194, 195, 198, 288, 2141, 2142, 2143, 2169, 2170, 2173, 2176,
+  2333, 4136, 20619,
 };
 
 static const unsigned short dep223[] = {
-  32, 41, 42, 72, 77, 79, 80, 85, 87, 100, 112, 114, 131, 132, 134, 135, 136, 
-  138, 140, 141, 142, 143, 145, 146, 156, 158, 161, 165, 174, 176, 178, 188, 
-  193, 194, 195, 288, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 2333, 4136, 
-  20619, 
+  32, 41, 42, 72, 77, 79, 80, 85, 87, 100, 112, 114, 131, 132, 134, 135, 136,
+  138, 140, 141, 142, 143, 145, 146, 156, 158, 161, 165, 174, 176, 178, 188,
+  193, 194, 195, 288, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 2333, 4136,
+  20619,
 };
 
 static const unsigned short dep224[] = {
-  0, 100, 198, 288, 2333, 26718, 
+  0, 100, 198, 288, 2333, 26718,
 };
 
 static const unsigned short dep225[] = {
-  5, 100, 203, 288, 2143, 2333, 
+  5, 100, 203, 288, 2143, 2333,
 };
 
 static const unsigned short dep226[] = {
-  41, 42, 72, 77, 79, 80, 85, 87, 100, 112, 114, 131, 132, 134, 135, 136, 138, 
-  140, 141, 142, 143, 145, 146, 156, 158, 161, 165, 174, 176, 178, 188, 193, 
-  194, 195, 203, 288, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 2333, 4136, 
-  20619, 
+  41, 42, 72, 77, 79, 80, 85, 87, 100, 112, 114, 131, 132, 134, 135, 136, 138,
+  140, 141, 142, 143, 145, 146, 156, 158, 161, 165, 174, 176, 178, 188, 193,
+  194, 195, 203, 288, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 2333, 4136,
+  20619,
 };
 
 static const unsigned short dep227[] = {
-  0, 100, 112, 198, 288, 295, 
+  0, 100, 112, 198, 288, 295,
 };
 
 static const unsigned short dep228[] = {
-  0, 41, 42, 72, 77, 79, 80, 85, 87, 100, 114, 131, 132, 134, 135, 136, 138, 
-  140, 141, 142, 143, 145, 146, 156, 158, 161, 165, 174, 176, 178, 188, 193, 
-  194, 195, 198, 288, 295, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 4136, 20619, 
-  
+  0, 41, 42, 72, 77, 79, 80, 85, 87, 100, 114, 131, 132, 134, 135, 136, 138,
+  140, 141, 142, 143, 145, 146, 156, 158, 161, 165, 174, 176, 178, 188, 193,
+  194, 195, 198, 288, 295, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 4136, 20619,
+
 };
 
 static const unsigned short dep229[] = {
-  0, 5, 41, 42, 72, 77, 79, 80, 85, 87, 100, 114, 131, 132, 134, 135, 136, 138, 
-  140, 141, 142, 143, 145, 146, 156, 158, 161, 165, 174, 176, 178, 188, 193, 
-  194, 195, 198, 288, 295, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 4136, 20619, 
-  
+  0, 5, 41, 42, 72, 77, 79, 80, 85, 87, 100, 114, 131, 132, 134, 135, 136, 138,
+  140, 141, 142, 143, 145, 146, 156, 158, 161, 165, 174, 176, 178, 188, 193,
+  194, 195, 198, 288, 295, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 4136, 20619,
+
 };
 
 static const unsigned short dep230[] = {
-  0, 32, 100, 112, 198, 238, 288, 295, 
+  0, 32, 100, 112, 198, 238, 288, 295,
 };
 
 static const unsigned short dep231[] = {
-  0, 41, 42, 72, 77, 79, 80, 85, 87, 100, 114, 131, 132, 134, 135, 136, 138, 
-  140, 141, 142, 143, 145, 146, 156, 158, 161, 165, 174, 176, 178, 188, 193, 
-  194, 195, 198, 238, 288, 295, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 4136, 
-  20619, 
+  0, 41, 42, 72, 77, 79, 80, 85, 87, 100, 114, 131, 132, 134, 135, 136, 138,
+  140, 141, 142, 143, 145, 146, 156, 158, 161, 165, 174, 176, 178, 188, 193,
+  194, 195, 198, 238, 288, 295, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 4136,
+  20619,
 };
 
 static const unsigned short dep232[] = {
-  0, 100, 112, 198, 288, 295, 2143, 2333, 
+  0, 100, 112, 198, 288, 295, 2143, 2333,
 };
 
 static const unsigned short dep233[] = {
-  0, 3, 41, 42, 72, 77, 79, 80, 85, 87, 100, 112, 114, 131, 132, 134, 135, 136, 
-  138, 140, 141, 142, 143, 145, 146, 156, 158, 161, 165, 174, 176, 178, 188, 
-  193, 194, 195, 198, 288, 295, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 2333, 
-  4136, 20619, 
+  0, 3, 41, 42, 72, 77, 79, 80, 85, 87, 100, 112, 114, 131, 132, 134, 135, 136,
+  138, 140, 141, 142, 143, 145, 146, 156, 158, 161, 165, 174, 176, 178, 188,
+  193, 194, 195, 198, 288, 295, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 2333,
+  4136, 20619,
 };
 
 static const unsigned short dep234[] = {
-  0, 3, 5, 41, 42, 72, 77, 79, 80, 85, 87, 100, 112, 114, 131, 132, 134, 135, 
-  136, 138, 140, 141, 142, 143, 145, 146, 156, 158, 161, 165, 174, 176, 178, 
-  188, 193, 194, 195, 198, 288, 295, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 
-  2333, 4136, 20619, 
+  0, 3, 5, 41, 42, 72, 77, 79, 80, 85, 87, 100, 112, 114, 131, 132, 134, 135,
+  136, 138, 140, 141, 142, 143, 145, 146, 156, 158, 161, 165, 174, 176, 178,
+  188, 193, 194, 195, 198, 288, 295, 2141, 2142, 2143, 2169, 2170, 2173, 2176,
+  2333, 4136, 20619,
 };
 
 static const unsigned short dep235[] = {
-  0, 41, 42, 72, 77, 79, 80, 85, 87, 100, 112, 114, 131, 132, 134, 135, 136, 
-  138, 140, 141, 142, 143, 145, 146, 156, 158, 161, 165, 174, 176, 178, 188, 
-  193, 194, 195, 198, 288, 295, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 2333, 
-  4136, 20619, 
+  0, 41, 42, 72, 77, 79, 80, 85, 87, 100, 112, 114, 131, 132, 134, 135, 136,
+  138, 140, 141, 142, 143, 145, 146, 156, 158, 161, 165, 174, 176, 178, 188,
+  193, 194, 195, 198, 288, 295, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 2333,
+  4136, 20619,
 };
 
 static const unsigned short dep236[] = {
-  41, 42, 100, 161, 165, 178, 188, 288, 2138, 2139, 2140, 2169, 2170, 2173, 
-  2176, 2333, 4136, 16531, 16533, 16534, 16536, 20619, 
+  41, 42, 100, 161, 165, 178, 188, 288, 2138, 2139, 2140, 2169, 2170, 2173,
+  2176, 2333, 4136, 16531, 16533, 16534, 16536, 20619,
 };
 
 static const unsigned short dep237[] = {
-  0, 41, 42, 72, 77, 79, 80, 85, 87, 100, 114, 131, 132, 134, 135, 136, 138, 
-  140, 141, 142, 143, 145, 146, 156, 158, 161, 165, 174, 176, 178, 188, 193, 
-  194, 195, 198, 288, 295, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 2333, 4136, 
-  20619, 
+  0, 41, 42, 72, 77, 79, 80, 85, 87, 100, 114, 131, 132, 134, 135, 136, 138,
+  140, 141, 142, 143, 145, 146, 156, 158, 161, 165, 174, 176, 178, 188, 193,
+  194, 195, 198, 288, 295, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 2333, 4136,
+  20619,
 };
 
 static const unsigned short dep238[] = {
-  0, 32, 100, 112, 198, 238, 288, 295, 2143, 2333, 
+  0, 32, 100, 112, 198, 238, 288, 295, 2143, 2333,
 };
 
 static const unsigned short dep239[] = {
-  0, 41, 42, 72, 77, 79, 80, 85, 87, 100, 114, 131, 132, 134, 135, 136, 138, 
-  140, 141, 142, 143, 145, 146, 156, 158, 161, 165, 174, 176, 178, 188, 193, 
-  194, 195, 198, 238, 288, 295, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 2333, 
-  4136, 20619, 
+  0, 41, 42, 72, 77, 79, 80, 85, 87, 100, 114, 131, 132, 134, 135, 136, 138,
+  140, 141, 142, 143, 145, 146, 156, 158, 161, 165, 174, 176, 178, 188, 193,
+  194, 195, 198, 238, 288, 295, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 2333,
+  4136, 20619,
 };
 
 static const unsigned short dep240[] = {
-  41, 42, 72, 77, 79, 80, 85, 87, 100, 112, 114, 131, 132, 134, 135, 136, 138, 
-  140, 141, 142, 143, 145, 146, 156, 158, 161, 165, 174, 176, 178, 188, 193, 
-  194, 195, 288, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 2331, 4136, 16531, 
-  16533, 16534, 16536, 18767, 18769, 18770, 18772, 20619, 
+  41, 42, 72, 77, 79, 80, 85, 87, 100, 112, 114, 131, 132, 134, 135, 136, 138,
+  140, 141, 142, 143, 145, 146, 156, 158, 161, 165, 174, 176, 178, 188, 193,
+  194, 195, 288, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 2331, 4136, 16531,
+  16533, 16534, 16536, 18767, 18769, 18770, 18772, 20619,
 };
 
 static const unsigned short dep241[] = {
-  41, 42, 45, 72, 77, 79, 80, 85, 87, 100, 112, 114, 131, 132, 134, 135, 136, 
-  138, 140, 141, 142, 143, 145, 146, 156, 158, 159, 161, 165, 174, 176, 178, 
-  188, 193, 194, 195, 288, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 2331, 4136, 
-  16531, 16533, 16534, 16536, 18767, 18769, 18770, 18772, 20619, 
+  41, 42, 45, 72, 77, 79, 80, 85, 87, 100, 112, 114, 131, 132, 134, 135, 136,
+  138, 140, 141, 142, 143, 145, 146, 156, 158, 159, 161, 165, 174, 176, 178,
+  188, 193, 194, 195, 288, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 2331, 4136,
+  16531, 16533, 16534, 16536, 18767, 18769, 18770, 18772, 20619,
 };
 
 static const unsigned short dep242[] = {
-  0, 100, 198, 288, 2139, 2331, 18604, 18605, 18767, 18768, 18770, 18771, 
+  0, 100, 198, 288, 2139, 2331, 18604, 18605, 18767, 18768, 18770, 18771,
 };
 
 static const unsigned short dep243[] = {
-  0, 41, 42, 72, 77, 79, 80, 85, 87, 100, 112, 114, 131, 132, 134, 135, 136, 
-  138, 140, 141, 142, 143, 145, 146, 156, 158, 161, 165, 174, 176, 178, 188, 
-  193, 194, 195, 198, 288, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 2331, 4136, 
-  16531, 16533, 16534, 16536, 18767, 18769, 18770, 18772, 20619, 
+  0, 41, 42, 72, 77, 79, 80, 85, 87, 100, 112, 114, 131, 132, 134, 135, 136,
+  138, 140, 141, 142, 143, 145, 146, 156, 158, 161, 165, 174, 176, 178, 188,
+  193, 194, 195, 198, 288, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 2331, 4136,
+  16531, 16533, 16534, 16536, 18767, 18769, 18770, 18772, 20619,
 };
 
 static const unsigned short dep244[] = {
-  0, 41, 42, 45, 72, 77, 79, 80, 85, 87, 100, 112, 114, 131, 132, 134, 135, 
-  136, 138, 140, 141, 142, 143, 145, 146, 156, 158, 159, 161, 165, 174, 176, 
-  178, 188, 193, 194, 195, 198, 288, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 
-  2331, 4136, 16531, 16533, 16534, 16536, 18767, 18769, 18770, 18772, 20619, 
-  
+  0, 41, 42, 45, 72, 77, 79, 80, 85, 87, 100, 112, 114, 131, 132, 134, 135,
+  136, 138, 140, 141, 142, 143, 145, 146, 156, 158, 159, 161, 165, 174, 176,
+  178, 188, 193, 194, 195, 198, 288, 2141, 2142, 2143, 2169, 2170, 2173, 2176,
+  2331, 4136, 16531, 16533, 16534, 16536, 18767, 18769, 18770, 18772, 20619,
+
 };
 
 static const unsigned short dep245[] = {
-  0, 100, 198, 288, 2140, 2331, 18604, 18605, 18767, 18768, 18770, 18771, 
+  0, 100, 198, 288, 2140, 2331, 18604, 18605, 18767, 18768, 18770, 18771,
 };
 
 static const unsigned short dep246[] = {
-  100, 288, 2139, 2143, 2331, 2333, 18604, 18605, 18767, 18768, 18770, 18771, 
-  
+  100, 288, 2139, 2143, 2331, 2333, 18604, 18605, 18767, 18768, 18770, 18771,
+
 };
 
 static const unsigned short dep247[] = {
-  41, 42, 72, 77, 79, 80, 85, 87, 100, 112, 114, 131, 132, 134, 135, 136, 138, 
-  140, 141, 142, 143, 145, 146, 156, 158, 161, 165, 174, 176, 178, 188, 193, 
-  194, 195, 288, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 2331, 2333, 4136, 
-  16531, 16533, 16534, 16536, 18767, 18769, 18770, 18772, 20619, 
+  41, 42, 72, 77, 79, 80, 85, 87, 100, 112, 114, 131, 132, 134, 135, 136, 138,
+  140, 141, 142, 143, 145, 146, 156, 158, 161, 165, 174, 176, 178, 188, 193,
+  194, 195, 288, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 2331, 2333, 4136,
+  16531, 16533, 16534, 16536, 18767, 18769, 18770, 18772, 20619,
 };
 
 static const unsigned short dep248[] = {
-  41, 42, 45, 72, 77, 79, 80, 85, 87, 100, 112, 114, 131, 132, 134, 135, 136, 
-  138, 140, 141, 142, 143, 145, 146, 156, 158, 159, 161, 165, 174, 176, 178, 
-  188, 193, 194, 195, 288, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 2331, 2333, 
-  4136, 16531, 16533, 16534, 16536, 18767, 18769, 18770, 18772, 20619, 
+  41, 42, 45, 72, 77, 79, 80, 85, 87, 100, 112, 114, 131, 132, 134, 135, 136,
+  138, 140, 141, 142, 143, 145, 146, 156, 158, 159, 161, 165, 174, 176, 178,
+  188, 193, 194, 195, 288, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 2331, 2333,
+  4136, 16531, 16533, 16534, 16536, 18767, 18769, 18770, 18772, 20619,
 };
 
 static const unsigned short dep249[] = {
-  0, 100, 198, 288, 2139, 2143, 2331, 2333, 18604, 18605, 18767, 18768, 18770, 
-  18771, 
+  0, 100, 198, 288, 2139, 2143, 2331, 2333, 18604, 18605, 18767, 18768, 18770,
+  18771,
 };
 
 static const unsigned short dep250[] = {
-  0, 41, 42, 72, 77, 79, 80, 85, 87, 100, 112, 114, 131, 132, 134, 135, 136, 
-  138, 140, 141, 142, 143, 145, 146, 156, 158, 161, 165, 174, 176, 178, 188, 
-  193, 194, 195, 198, 288, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 2331, 2333, 
-  4136, 16531, 16533, 16534, 16536, 18767, 18769, 18770, 18772, 20619, 
+  0, 41, 42, 72, 77, 79, 80, 85, 87, 100, 112, 114, 131, 132, 134, 135, 136,
+  138, 140, 141, 142, 143, 145, 146, 156, 158, 161, 165, 174, 176, 178, 188,
+  193, 194, 195, 198, 288, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 2331, 2333,
+  4136, 16531, 16533, 16534, 16536, 18767, 18769, 18770, 18772, 20619,
 };
 
 static const unsigned short dep251[] = {
-  0, 41, 42, 45, 72, 77, 79, 80, 85, 87, 100, 112, 114, 131, 132, 134, 135, 
-  136, 138, 140, 141, 142, 143, 145, 146, 156, 158, 159, 161, 165, 174, 176, 
-  178, 188, 193, 194, 195, 198, 288, 2141, 2142, 2143, 2169, 2170, 2173, 2176, 
-  2331, 2333, 4136, 16531, 16533, 16534, 16536, 18767, 18769, 18770, 18772, 
-  20619, 
+  0, 41, 42, 45, 72, 77, 79, 80, 85, 87, 100, 112, 114, 131, 132, 134, 135,
+  136, 138, 140, 141, 142, 143, 145, 146, 156, 158, 159, 161, 165, 174, 176,
+  178, 188, 193, 194, 195, 198, 288, 2141, 2142, 2143, 2169, 2170, 2173, 2176,
+  2331, 2333, 4136, 16531, 16533, 16534, 16536, 18767, 18769, 18770, 18772,
+  20619,
 };
 
 static const unsigned short dep252[] = {
-  0, 100, 198, 288, 2140, 2143, 2331, 2333, 18604, 18605, 18767, 18768, 18770, 
-  18771, 
+  0, 100, 198, 288, 2140, 2143, 2331, 2333, 18604, 18605, 18767, 18768, 18770,
+  18771,
 };
 
 static const unsigned short dep253[] = {
-  0, 41, 42, 72, 77, 79, 80, 85, 87, 100, 114, 131, 132, 134, 135, 136, 138, 
-  140, 141, 142, 143, 145, 146, 156, 158, 161, 165, 174, 176, 178, 188, 193, 
-  194, 195, 198, 288, 295, 2138, 2139, 2140, 2141, 2142, 2143, 2169, 2170, 2173, 
-  2176, 4136, 16531, 16533, 16534, 16536, 20619, 
+  0, 41, 42, 72, 77, 79, 80, 85, 87, 100, 114, 131, 132, 134, 135, 136, 138,
+  140, 141, 142, 143, 145, 146, 156, 158, 161, 165, 174, 176, 178, 188, 193,
+  194, 195, 198, 288, 295, 2138, 2139, 2140, 2141, 2142, 2143, 2169, 2170, 2173,
+  2176, 4136, 16531, 16533, 16534, 16536, 20619,
 };
 
 static const unsigned short dep254[] = {
-  41, 42, 72, 79, 80, 85, 87, 100, 140, 141, 142, 143, 145, 146, 156, 158, 159, 
-  161, 165, 174, 176, 178, 188, 195, 288, 2169, 2170, 2173, 2176, 4136, 
+  41, 42, 72, 79, 80, 85, 87, 100, 140, 141, 142, 143, 145, 146, 156, 158, 159,
+  161, 165, 174, 176, 178, 188, 195, 288, 2169, 2170, 2173, 2176, 4136,
 };
 
 static const unsigned short dep255[] = {
-  41, 42, 72, 79, 80, 85, 87, 100, 140, 141, 142, 143, 145, 146, 156, 158, 159, 
-  161, 165, 174, 176, 178, 188, 195, 288, 2141, 2142, 2143, 2169, 2170, 2173, 
-  2176, 2333, 4136, 20619, 
+  41, 42, 72, 79, 80, 85, 87, 100, 140, 141, 142, 143, 145, 146, 156, 158, 159,
+  161, 165, 174, 176, 178, 188, 195, 288, 2141, 2142, 2143, 2169, 2170, 2173,
+  2176, 2333, 4136, 20619,
 };
 
 static const unsigned short dep256[] = {
-  41, 42, 100, 161, 165, 178, 188, 288, 2141, 2142, 2143, 2169, 2170, 2173, 
-  2176, 2331, 4136, 16531, 16533, 16534, 16536, 18767, 18769, 18770, 18772, 
-  20619, 
+  41, 42, 100, 161, 165, 178, 188, 288, 2141, 2142, 2143, 2169, 2170, 2173,
+  2176, 2331, 4136, 16531, 16533, 16534, 16536, 18767, 18769, 18770, 18772,
+  20619,
 };
 
 static const unsigned short dep257[] = {
-  0, 41, 42, 72, 77, 79, 80, 85, 87, 100, 114, 131, 132, 134, 135, 136, 138, 
-  140, 141, 142, 143, 145, 146, 156, 158, 161, 165, 174, 176, 178, 188, 193, 
-  194, 195, 198, 288, 295, 2138, 2139, 2140, 2141, 2142, 2143, 2169, 2170, 2173, 
-  2176, 2333, 4136, 16531, 16533, 16534, 16536, 20619, 
+  0, 41, 42, 72, 77, 79, 80, 85, 87, 100, 114, 131, 132, 134, 135, 136, 138,
+  140, 141, 142, 143, 145, 146, 156, 158, 161, 165, 174, 176, 178, 188, 193,
+  194, 195, 198, 288, 295, 2138, 2139, 2140, 2141, 2142, 2143, 2169, 2170, 2173,
+  2176, 2333, 4136, 16531, 16533, 16534, 16536, 20619,
 };
 
 static const unsigned short dep258[] = {
-  1, 6, 39, 41, 42, 100, 140, 141, 161, 165, 167, 178, 188, 189, 191, 199, 231, 
-  233, 245, 272, 288, 2169, 2171, 2172, 2174, 2175, 2177, 2178, 2290, 2292, 
-  4136, 28869, 29024, 
+  1, 6, 39, 41, 42, 100, 140, 141, 161, 165, 167, 178, 188, 189, 191, 199, 231,
+  233, 245, 272, 288, 2169, 2171, 2172, 2174, 2175, 2177, 2178, 2290, 2292,
+  4136, 28869, 29024,
 };
 
 static const unsigned short dep259[] = {
-  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 
-  22, 24, 26, 27, 28, 29, 30, 31, 32, 100, 199, 200, 201, 202, 203, 204, 205, 
-  206, 207, 208, 209, 210, 211, 212, 214, 215, 217, 218, 220, 221, 223, 224, 
-  225, 226, 227, 228, 230, 233, 234, 235, 236, 237, 238, 272, 288, 2071, 2082, 
-  2143, 2277, 2288, 2333, 28869, 29024, 
+  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
+  22, 24, 26, 27, 28, 29, 30, 31, 32, 100, 199, 200, 201, 202, 203, 204, 205,
+  206, 207, 208, 209, 210, 211, 212, 214, 215, 217, 218, 220, 221, 223, 224,
+  225, 226, 227, 228, 230, 233, 234, 235, 236, 237, 238, 272, 288, 2071, 2082,
+  2143, 2277, 2288, 2333, 28869, 29024,
 };
 
 static const unsigned short dep260[] = {
-  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 
-  22, 24, 25, 26, 28, 29, 30, 31, 32, 41, 42, 100, 140, 141, 161, 165, 178, 
-  183, 184, 188, 193, 194, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 
-  209, 210, 211, 212, 214, 215, 217, 218, 220, 221, 223, 224, 225, 226, 227, 
-  228, 230, 232, 234, 235, 236, 237, 238, 272, 288, 2071, 2082, 2141, 2142, 
-  2143, 2169, 2170, 2173, 2176, 2277, 2288, 2333, 4136, 20619, 28869, 29024, 
-  
+  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
+  22, 24, 25, 26, 28, 29, 30, 31, 32, 41, 42, 100, 140, 141, 161, 165, 178,
+  183, 184, 188, 193, 194, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208,
+  209, 210, 211, 212, 214, 215, 217, 218, 220, 221, 223, 224, 225, 226, 227,
+  228, 230, 232, 234, 235, 236, 237, 238, 272, 288, 2071, 2082, 2141, 2142,
+  2143, 2169, 2170, 2173, 2176, 2277, 2288, 2333, 4136, 20619, 28869, 29024,
+
 };
 
 #define NELS(X) (sizeof(X)/sizeof(X[0]))
@@ -6395,802 +6395,802 @@ main_table[] = {
 };
 
 static const char dis_table[] = {
-0xa1, 0x02, 0x78, 0xa0, 0x2f, 0x28, 0xa0, 0x2d, 0x10, 0xa0, 0x1c, 0x40, 
-0x98, 0xb0, 0x02, 0x50, 0x90, 0x50, 0x90, 0x28, 0x24, 0x52, 0x40, 0x24, 
-0x52, 0x38, 0x90, 0x28, 0x24, 0x52, 0x30, 0x24, 0x52, 0x28, 0x91, 0x60, 
-0x90, 0x28, 0x24, 0x52, 0x18, 0x10, 0x10, 0x58, 0x41, 0x62, 0x90, 0x80, 
-0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
-0x10, 0x10, 0x52, 0xc0, 0xc0, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
-0x10, 0x10, 0x10, 0x24, 0x3d, 0x90, 0x90, 0x28, 0x24, 0x52, 0x08, 0x24, 
-0x52, 0x00, 0xa8, 0x0b, 0x88, 0x15, 0x60, 0x97, 0x60, 0x96, 0x08, 0x9a, 
-0xf8, 0x05, 0x78, 0x91, 0x58, 0x90, 0xe0, 0x90, 0xa0, 0x80, 0x90, 0x20, 
-0x37, 0xc9, 0x90, 0x20, 0x37, 0xc6, 0xcb, 0xa1, 0xf1, 0x00, 0xa4, 0x37, 
-0xf8, 0x37, 0x00, 0x80, 0xa4, 0x4f, 0xb8, 0x39, 0xfc, 0x90, 0x50, 0x90, 
-0x28, 0x80, 0x39, 0xf2, 0x80, 0x37, 0xaa, 0x81, 0x37, 0x03, 0x90, 0xe0, 
-0x90, 0x70, 0x90, 0x38, 0xa4, 0x3d, 0x30, 0x37, 0xa7, 0xa4, 0x38, 0x10, 
-0x37, 0xa4, 0x90, 0x38, 0xa4, 0x51, 0xb8, 0x3a, 0x3d, 0xa4, 0x51, 0x60, 
-0x3a, 0x31, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x50, 0x38, 0x3a, 0x12, 0xa4, 
-0x50, 0x10, 0x3a, 0x0d, 0x80, 0xa4, 0x3d, 0x10, 0x37, 0xa3, 0x92, 0x18, 
-0x91, 0xc0, 0x80, 0x91, 0x80, 0x90, 0xf8, 0xdb, 0x84, 0x61, 0xc1, 0x80, 
-0xc0, 0xc0, 0x80, 0xa4, 0x5b, 0x80, 0x8c, 0x5c, 0xe0, 0x84, 0x3b, 0xa6, 
-0xc0, 0xc0, 0x80, 0xa4, 0x5b, 0x70, 0x8c, 0x5c, 0xc0, 0x84, 0x3b, 0xa4, 
-0xd3, 0x82, 0x40, 0x50, 0xc0, 0xc0, 0x81, 0x3b, 0x58, 0x50, 0xc0, 0xc0, 
-0x81, 0x3b, 0x56, 0xa4, 0x38, 0x20, 0x37, 0x05, 0x80, 0x90, 0x28, 0x80, 
-0x37, 0x01, 0x80, 0x37, 0xac, 0x81, 0x90, 0x38, 0xa4, 0x3d, 0xa0, 0x37, 
-0xaf, 0xa4, 0x3d, 0x68, 0x37, 0xa9, 0xc0, 0x40, 0x10, 0x10, 0x90, 0x38, 
-0xa4, 0x37, 0xe8, 0x36, 0xfe, 0xa4, 0x37, 0xd8, 0x36, 0xfc, 0x18, 0x24, 
-0x3e, 0x18, 0x83, 0x90, 0xa8, 0xd3, 0x82, 0xc0, 0xc0, 0xc0, 0x80, 0xa4, 
-0x5b, 0x50, 0x3b, 0x90, 0xc0, 0xc0, 0x80, 0xa4, 0x5b, 0x40, 0x3b, 0x8c, 
-0xd3, 0x82, 0x40, 0x50, 0xc0, 0xc0, 0x81, 0x3b, 0x52, 0x50, 0xc0, 0xc0, 
-0x81, 0x3b, 0x50, 0x92, 0xb8, 0x99, 0x84, 0x3d, 0x88, 0x90, 0x78, 0x90, 
-0x50, 0x10, 0x10, 0x80, 0xa4, 0x4f, 0xb0, 0x39, 0xfb, 0x82, 0x39, 0xf1, 
-0x90, 0x80, 0x10, 0x10, 0x90, 0x38, 0xa4, 0x51, 0xb0, 0x3a, 0x3c, 0xa4, 
-0x51, 0x58, 0x3a, 0x30, 0x80, 0x90, 0x38, 0xa4, 0x50, 0x30, 0x3a, 0x11, 
-0xa4, 0x50, 0x08, 0x3a, 0x0c, 0x83, 0x90, 0xa8, 0xd3, 0x82, 0xc0, 0xc0, 
-0xc0, 0x80, 0xa4, 0x5b, 0x20, 0x3b, 0x84, 0xc0, 0xc0, 0x80, 0xa4, 0x5b, 
-0x10, 0x3b, 0x80, 0xd3, 0x82, 0x40, 0x50, 0xc0, 0xc0, 0x81, 0x3b, 0x4c, 
-0x50, 0xc0, 0xc0, 0x81, 0x3b, 0x4a, 0x18, 0x24, 0x3d, 0x98, 0x83, 0x90, 
-0xa8, 0xd3, 0x82, 0xc0, 0xc0, 0xc0, 0x80, 0xa4, 0x5a, 0xf0, 0x3b, 0x78, 
-0xc0, 0xc0, 0x80, 0xa4, 0x5a, 0xe0, 0x3b, 0x74, 0xd3, 0x82, 0x40, 0x50, 
-0xc0, 0xc0, 0x81, 0x3b, 0x46, 0x50, 0xc0, 0xc0, 0x81, 0x3b, 0x44, 0x94, 
-0x50, 0x92, 0xf8, 0x99, 0x84, 0x38, 0x50, 0x90, 0x78, 0x90, 0x50, 0x10, 
-0x10, 0x80, 0xa4, 0x4f, 0xa8, 0x39, 0xfa, 0x82, 0x39, 0xf0, 0x90, 0x80, 
-0x10, 0x10, 0x90, 0x38, 0xa4, 0x51, 0xa8, 0x3a, 0x3b, 0xa4, 0x51, 0x50, 
-0x3a, 0x2f, 0x80, 0x90, 0x38, 0xa4, 0x50, 0x28, 0x3a, 0x10, 0xa4, 0x50, 
-0x00, 0x3a, 0x0b, 0x83, 0x90, 0xe8, 0xd3, 0x83, 0xc0, 0xc0, 0xc0, 0x80, 
-0xa4, 0x5b, 0x90, 0x8c, 0x5d, 0x00, 0x84, 0x3b, 0xa8, 0xc0, 0xc0, 0x80, 
-0xa4, 0x5b, 0x78, 0x8c, 0x5c, 0xd0, 0x84, 0x3b, 0xa5, 0xd3, 0x82, 0x40, 
-0x50, 0xc0, 0xc0, 0x81, 0x3b, 0x5a, 0x50, 0xc0, 0xc0, 0x81, 0x3b, 0x57, 
-0x18, 0x24, 0x38, 0x48, 0x83, 0x90, 0xa8, 0xd3, 0x82, 0xc0, 0xc0, 0xc0, 
-0x80, 0xa4, 0x5b, 0x60, 0x3b, 0x94, 0xc0, 0xc0, 0x80, 0xa4, 0x5b, 0x48, 
-0x3b, 0x8e, 0xd3, 0x82, 0x40, 0x50, 0xc0, 0xc0, 0x81, 0x3b, 0x54, 0x50, 
-0xc0, 0xc0, 0x81, 0x3b, 0x51, 0x92, 0xb8, 0x99, 0x84, 0x38, 0x40, 0x90, 
-0x78, 0x90, 0x50, 0x10, 0x10, 0x80, 0xa4, 0x4f, 0xa0, 0x39, 0xf9, 0x82, 
-0x39, 0xef, 0x90, 0x80, 0x10, 0x10, 0x90, 0x38, 0xa4, 0x51, 0xa0, 0x3a, 
-0x3a, 0xa4, 0x51, 0x48, 0x3a, 0x2e, 0x80, 0x90, 0x38, 0xa4, 0x50, 0x20, 
-0x3a, 0x0f, 0xa4, 0x4f, 0xf8, 0x3a, 0x0a, 0x83, 0x90, 0xa8, 0xd3, 0x82, 
-0xc0, 0xc0, 0xc0, 0x80, 0xa4, 0x5b, 0x30, 0x3b, 0x88, 0xc0, 0xc0, 0x80, 
-0xa4, 0x5b, 0x18, 0x3b, 0x82, 0xd3, 0x82, 0x40, 0x50, 0xc0, 0xc0, 0x81, 
-0x3b, 0x4e, 0x50, 0xc0, 0xc0, 0x81, 0x3b, 0x4b, 0x18, 0x20, 0x01, 0x48, 
-0x83, 0x90, 0xa8, 0xd3, 0x82, 0xc0, 0xc0, 0xc0, 0x80, 0xa4, 0x5b, 0x00, 
-0x3b, 0x7c, 0xc0, 0xc0, 0x80, 0xa4, 0x5a, 0xe8, 0x3b, 0x76, 0xd3, 0x82, 
-0x40, 0x50, 0xc0, 0xc0, 0x81, 0x3b, 0x48, 0x50, 0xc0, 0xc0, 0x81, 0x3b, 
-0x45, 0xda, 0x06, 0xe1, 0xc1, 0xc0, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x3e, 
-0x08, 0x37, 0xbf, 0x80, 0x37, 0xbc, 0x90, 0x38, 0xa4, 0x3d, 0xb0, 0x37, 
-0xba, 0x80, 0x37, 0xb7, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x3d, 0xf0, 0x37, 
-0xc0, 0x80, 0x37, 0xbd, 0x90, 0x38, 0xa4, 0x3d, 0xc8, 0x37, 0xbb, 0x80, 
-0x37, 0xb8, 0xc8, 0x40, 0x19, 0x00, 0x91, 0x58, 0x90, 0x60, 0x82, 0x90, 
-0x20, 0x39, 0xee, 0xa4, 0x4f, 0x60, 0x39, 0xed, 0x90, 0xc0, 0x80, 0x90, 
-0x90, 0x90, 0x48, 0xc9, 0xe2, 0x89, 0xc0, 0x85, 0x3a, 0x26, 0xc9, 0xe2, 
-0x89, 0x00, 0x85, 0x3a, 0x23, 0x80, 0x3a, 0x22, 0x10, 0x10, 0x81, 0x39, 
-0xfe, 0x90, 0xa8, 0x10, 0x10, 0x90, 0x28, 0x81, 0x3a, 0x1c, 0x90, 0x38, 
-0xa4, 0x50, 0xb8, 0x3a, 0x18, 0xa4, 0x50, 0xa8, 0x3a, 0x16, 0x90, 0x70, 
-0x10, 0x10, 0x90, 0x38, 0xa4, 0x50, 0xd0, 0x3a, 0x1b, 0x80, 0x3a, 0x19, 
-0x90, 0x60, 0x90, 0x28, 0x24, 0x51, 0x08, 0xa4, 0x50, 0xf8, 0x3a, 0x20, 
-0x80, 0xa4, 0x50, 0xe8, 0x3a, 0x1e, 0x80, 0x90, 0xf8, 0x90, 0x90, 0x90, 
-0x50, 0x90, 0x28, 0x80, 0x3b, 0x3a, 0x80, 0x3b, 0x43, 0x80, 0xa4, 0x5a, 
-0x08, 0x3b, 0x42, 0x90, 0x28, 0x81, 0x3b, 0x40, 0x80, 0xa4, 0x59, 0xf0, 
-0x3b, 0x3f, 0x90, 0x28, 0x82, 0x3b, 0x3d, 0x81, 0xa4, 0x59, 0xd8, 0x3b, 
-0x3c, 0x98, 0xe8, 0x01, 0xb0, 0x90, 0x88, 0x90, 0x60, 0xa4, 0x4f, 0x50, 
-0x10, 0x10, 0x10, 0x10, 0x83, 0x36, 0xd5, 0x24, 0x4f, 0x48, 0x90, 0x28, 
-0x24, 0x4f, 0x40, 0x24, 0x4f, 0x38, 0x90, 0x88, 0x90, 0x60, 0xa4, 0x4f, 
-0x28, 0x10, 0x10, 0x10, 0x10, 0x83, 0x36, 0xd4, 0x24, 0x4f, 0x20, 0x90, 
-0x28, 0x24, 0x4f, 0x18, 0x24, 0x4f, 0x10, 0xa8, 0x09, 0x10, 0x0e, 0x30, 
-0x96, 0x58, 0x95, 0xf8, 0x93, 0x38, 0x91, 0xa0, 0x90, 0xd0, 0x90, 0x70, 
-0x90, 0x38, 0xa4, 0x37, 0x58, 0x36, 0xec, 0xa4, 0x37, 0x48, 0x36, 0xea, 
-0x90, 0x38, 0xa4, 0x37, 0x38, 0x36, 0xe8, 0x80, 0x36, 0xe6, 0x90, 0x60, 
-0x90, 0x28, 0x24, 0x36, 0xf0, 0xa4, 0x36, 0xe0, 0x36, 0xdd, 0x90, 0x38, 
-0xa4, 0x36, 0xd0, 0x36, 0xdb, 0xa4, 0x37, 0x20, 0x36, 0xe5, 0x90, 0xe0, 
-0x90, 0x70, 0x90, 0x38, 0xa4, 0x37, 0x10, 0x36, 0xe3, 0xa4, 0x37, 0x00, 
-0x36, 0xe1, 0x90, 0x38, 0xa4, 0x4e, 0xc8, 0x39, 0xdf, 0xa4, 0x4e, 0x68, 
-0x39, 0xd3, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x4b, 0xa8, 0x39, 0x81, 0xa4, 
-0x4b, 0x78, 0x39, 0x7b, 0x10, 0x10, 0xa4, 0x36, 0xc0, 0x36, 0xd9, 0x99, 
-0x70, 0x02, 0x80, 0x90, 0xa0, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x37, 0x88, 
-0x36, 0xdf, 0x80, 0x36, 0xf9, 0x80, 0xa4, 0x37, 0x90, 0x36, 0xf7, 0x90, 
-0x50, 0x90, 0x28, 0x24, 0x37, 0x98, 0x80, 0x36, 0xfa, 0x90, 0x38, 0xa4, 
-0x37, 0xa0, 0x36, 0xf8, 0xa4, 0x37, 0x68, 0x36, 0xee, 0x90, 0xe0, 0x90, 
-0x70, 0x90, 0x38, 0xa4, 0x4e, 0x00, 0x39, 0xc8, 0xa4, 0x4d, 0x60, 0x39, 
-0xb5, 0x90, 0x38, 0xa4, 0x4c, 0xf8, 0x39, 0xa6, 0xa4, 0x4c, 0x68, 0x39, 
-0x95, 0x81, 0xa4, 0x37, 0x78, 0x36, 0xf0, 0xe4, 0xa2, 0xcd, 0x00, 0x3b, 
-0x36, 0x18, 0x24, 0x36, 0xb8, 0xe4, 0xe2, 0xcb, 0x80, 0x3b, 0x30, 0x92, 
-0x40, 0x91, 0x08, 0x10, 0x10, 0x90, 0x80, 0x10, 0x10, 0x90, 0x38, 0xa4, 
-0x4e, 0xc0, 0x39, 0xde, 0xa4, 0x4e, 0x60, 0x39, 0xd2, 0x80, 0x90, 0x38, 
-0xa4, 0x4b, 0xa0, 0x39, 0x80, 0xa4, 0x4b, 0x70, 0x39, 0x7a, 0x18, 0x20, 
-0x00, 0xf8, 0x80, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x4d, 0xf0, 0x39, 0xc7, 
-0xa4, 0x4d, 0x58, 0x39, 0xb3, 0x90, 0x38, 0xa4, 0x4c, 0xe8, 0x39, 0xa5, 
-0xa4, 0x4c, 0x60, 0x39, 0x93, 0xe4, 0xa2, 0xca, 0x00, 0x3b, 0x2a, 0x18, 
-0x24, 0x36, 0xb0, 0xe4, 0xe2, 0xc8, 0x80, 0x3b, 0x24, 0x92, 0x90, 0x92, 
-0x40, 0x91, 0x08, 0x10, 0x10, 0x90, 0x80, 0x10, 0x10, 0x90, 0x38, 0xa4, 
-0x4e, 0xb8, 0x39, 0xdd, 0xa4, 0x4e, 0x58, 0x39, 0xd1, 0x80, 0x90, 0x38, 
-0xa4, 0x4b, 0x98, 0x39, 0x7f, 0xa4, 0x4b, 0x68, 0x39, 0x79, 0x18, 0x20, 
-0x00, 0xf8, 0x80, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x4d, 0xe0, 0x39, 0xc6, 
-0xa4, 0x4d, 0x50, 0x39, 0xb1, 0x90, 0x38, 0xa4, 0x4c, 0xd8, 0x39, 0xa4, 
-0xa4, 0x4c, 0x58, 0x39, 0x91, 0xe4, 0xa2, 0xcd, 0x40, 0x3b, 0x38, 0x10, 
-0x10, 0xe4, 0xe2, 0xcb, 0xc0, 0x3b, 0x32, 0x92, 0x50, 0x99, 0x1c, 0x37, 
-0xa8, 0x10, 0x10, 0x90, 0x80, 0x10, 0x10, 0x90, 0x38, 0xa4, 0x4e, 0xb0, 
-0x39, 0xdc, 0xa4, 0x4e, 0x50, 0x39, 0xd0, 0x80, 0x90, 0x38, 0xa4, 0x4b, 
-0x90, 0x39, 0x7e, 0xa4, 0x4b, 0x60, 0x39, 0x78, 0x18, 0x20, 0x00, 0xf8, 
-0x80, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x4d, 0xd0, 0x39, 0xc5, 0xa4, 0x4d, 
-0x48, 0x39, 0xaf, 0x90, 0x38, 0xa4, 0x4c, 0xc8, 0x39, 0xa3, 0xa4, 0x4c, 
-0x50, 0x39, 0x8f, 0xe4, 0xa2, 0xca, 0x40, 0x3b, 0x2c, 0x10, 0x10, 0xe4, 
-0xe2, 0xc8, 0xc0, 0x3b, 0x26, 0xc0, 0x40, 0x80, 0x10, 0x10, 0x81, 0x90, 
-0x90, 0x90, 0x48, 0xc9, 0xe2, 0x61, 0x40, 0x85, 0x39, 0x89, 0xc9, 0xe2, 
-0x61, 0xc0, 0x85, 0x39, 0x86, 0x80, 0x39, 0x84, 0x80, 0xd8, 0x47, 0x80, 
-0x0d, 0xc0, 0xc0, 0x80, 0x10, 0x10, 0x82, 0x90, 0x58, 0xd5, 0x81, 0x80, 
-0x80, 0x3b, 0x20, 0x80, 0x3b, 0x1e, 0xd5, 0x81, 0x80, 0x80, 0x3b, 0x1c, 
-0x80, 0x3b, 0x1a, 0xc0, 0x80, 0x10, 0x10, 0x82, 0x90, 0x58, 0xd5, 0x81, 
-0x80, 0x80, 0x3b, 0x21, 0x80, 0x3b, 0x1f, 0xd5, 0x81, 0x80, 0x80, 0x3b, 
-0x1d, 0x80, 0x3b, 0x1b, 0xc0, 0x80, 0x83, 0xa4, 0x58, 0xc0, 0x3b, 0x19, 
-0xa0, 0x79, 0x20, 0xa0, 0x61, 0xa0, 0xa8, 0x3e, 0x70, 0x54, 0x48, 0xa0, 
-0x21, 0x30, 0xa0, 0x14, 0xe0, 0xa0, 0x0a, 0xd8, 0x9d, 0x60, 0x0a, 0x90, 
-0x92, 0xa0, 0x91, 0x50, 0x90, 0xb0, 0x90, 0x58, 0xa4, 0x20, 0x60, 0xe1, 
-0xe1, 0xb3, 0x00, 0x36, 0xd3, 0xa4, 0x20, 0x80, 0xe1, 0xe1, 0xb2, 0xc0, 
-0x36, 0xd1, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0xb2, 0x80, 0x36, 0xcf, 0xa4, 
-0x20, 0x70, 0xe1, 0xe1, 0xb2, 0x40, 0x36, 0xcd, 0x90, 0xb0, 0x90, 0x58, 
-0xa4, 0x20, 0x00, 0xe1, 0xe1, 0x9a, 0x40, 0x36, 0x70, 0xa4, 0x20, 0x20, 
-0xe1, 0xe1, 0x9a, 0x00, 0x36, 0x6e, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0x99, 
-0xc0, 0x36, 0x6c, 0xa4, 0x20, 0x10, 0xe1, 0xe1, 0x99, 0x80, 0x36, 0x6a, 
-0x91, 0x50, 0x90, 0xb0, 0x90, 0x58, 0xa4, 0x1f, 0xa0, 0xe1, 0xe1, 0x81, 
-0x80, 0x36, 0x0d, 0xa4, 0x1f, 0xc0, 0xe1, 0xe1, 0x81, 0x40, 0x36, 0x0b, 
-0x90, 0x48, 0x80, 0xe1, 0xe1, 0x81, 0x00, 0x36, 0x09, 0xa4, 0x1f, 0xb0, 
-0xe1, 0xe1, 0x80, 0xc0, 0x36, 0x07, 0x90, 0xc0, 0x90, 0x68, 0xa4, 0x1f, 
-0x40, 0xe9, 0xe1, 0x68, 0xe1, 0x44, 0x00, 0x35, 0xaa, 0xa4, 0x1f, 0x60, 
-0xe1, 0xe1, 0x68, 0x80, 0x35, 0xa8, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0x68, 
-0x40, 0x35, 0xa6, 0xa4, 0x1f, 0x50, 0xe1, 0xe1, 0x68, 0x00, 0x35, 0xa4, 
-0x92, 0xa0, 0x91, 0x50, 0x90, 0xb0, 0x90, 0x58, 0xa4, 0x20, 0x30, 0xe1, 
-0xe1, 0xb0, 0x80, 0x36, 0xbe, 0xa4, 0x20, 0x50, 0xe1, 0xe1, 0xb0, 0x40, 
-0x36, 0xc7, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0xb0, 0x00, 0x36, 0xc5, 0xa4, 
-0x20, 0x40, 0xe1, 0xe1, 0xaf, 0xc0, 0x36, 0xc3, 0x90, 0xb0, 0x90, 0x58, 
-0xa4, 0x1f, 0xd0, 0xe1, 0xe1, 0x97, 0xc0, 0x36, 0x5b, 0xa4, 0x1f, 0xf0, 
-0xe1, 0xe1, 0x97, 0x80, 0x36, 0x64, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0x97, 
-0x40, 0x36, 0x62, 0xa4, 0x1f, 0xe0, 0xe1, 0xe1, 0x97, 0x00, 0x36, 0x60, 
-0x91, 0x50, 0x90, 0xb0, 0x90, 0x58, 0xa4, 0x1f, 0x70, 0xe1, 0xe1, 0x7f, 
-0x00, 0x35, 0xf8, 0xa4, 0x1f, 0x90, 0xe1, 0xe1, 0x7e, 0xc0, 0x36, 0x01, 
-0x90, 0x48, 0x80, 0xe1, 0xe1, 0x7e, 0x80, 0x35, 0xff, 0xa4, 0x1f, 0x80, 
-0xe1, 0xe1, 0x7e, 0x40, 0x35, 0xfd, 0x90, 0xb0, 0x90, 0x58, 0xa4, 0x1f, 
-0x10, 0xe1, 0xe1, 0x66, 0x40, 0x35, 0x95, 0xa4, 0x1f, 0x30, 0xe1, 0xe1, 
-0x66, 0x00, 0x35, 0x9e, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0x65, 0xc0, 0x35, 
-0x9c, 0xa4, 0x1f, 0x20, 0xe1, 0xe1, 0x65, 0x80, 0x35, 0x9a, 0xe4, 0xe2, 
-0x54, 0x00, 0x39, 0x64, 0x9d, 0x50, 0x09, 0xc0, 0x92, 0xa0, 0x91, 0x50, 
-0x90, 0xb0, 0x90, 0x58, 0xa4, 0x1e, 0xa8, 0xe1, 0xe1, 0xad, 0xc0, 0x36, 
-0xb3, 0xa4, 0x1e, 0xa0, 0xe1, 0xe1, 0xad, 0x80, 0x36, 0xbc, 0x90, 0x48, 
-0x80, 0xe1, 0xe1, 0xad, 0x40, 0x36, 0xba, 0xa4, 0x1e, 0x98, 0xe1, 0xe1, 
-0xad, 0x00, 0x36, 0xb8, 0x90, 0xb0, 0x90, 0x58, 0xa4, 0x1e, 0x90, 0xe1, 
-0xe1, 0x95, 0x00, 0x36, 0x50, 0xa4, 0x1e, 0x88, 0xe1, 0xe1, 0x94, 0xc0, 
-0x36, 0x59, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0x94, 0x80, 0x36, 0x57, 0xa4, 
-0x1e, 0x80, 0xe1, 0xe1, 0x94, 0x40, 0x36, 0x55, 0x91, 0x50, 0x90, 0xb0, 
-0x90, 0x58, 0xa4, 0x1e, 0x78, 0xe1, 0xe1, 0x7c, 0x40, 0x35, 0xed, 0xa4, 
-0x1e, 0x70, 0xe1, 0xe1, 0x7c, 0x00, 0x35, 0xf6, 0x90, 0x48, 0x80, 0xe1, 
-0xe1, 0x7b, 0xc0, 0x35, 0xf4, 0xa4, 0x1e, 0x68, 0xe1, 0xe1, 0x7b, 0x80, 
-0x35, 0xf2, 0x90, 0xb0, 0x90, 0x58, 0xa4, 0x1e, 0x60, 0xe1, 0xe1, 0x63, 
-0x80, 0x35, 0x8a, 0xa4, 0x1e, 0x58, 0xe1, 0xe1, 0x63, 0x40, 0x35, 0x93, 
-0x90, 0x48, 0x80, 0xe1, 0xe1, 0x63, 0x00, 0x35, 0x91, 0xa4, 0x1e, 0x50, 
-0xe1, 0xe1, 0x62, 0xc0, 0x35, 0x8f, 0x92, 0x40, 0x91, 0x20, 0x90, 0x90, 
-0x90, 0x48, 0x80, 0xe1, 0xe1, 0xab, 0x00, 0x36, 0xa8, 0x80, 0xe1, 0xe1, 
-0xaa, 0xc0, 0x36, 0xb1, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0xaa, 0x80, 0x36, 
-0xaf, 0x80, 0xe1, 0xe1, 0xaa, 0x40, 0x36, 0xad, 0x90, 0x90, 0x90, 0x48, 
-0x80, 0xe1, 0xe1, 0x92, 0x40, 0x36, 0x45, 0x80, 0xe1, 0xe1, 0x92, 0x00, 
-0x36, 0x4e, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0x91, 0xc0, 0x36, 0x4c, 0x80, 
-0xe1, 0xe1, 0x91, 0x80, 0x36, 0x4a, 0x91, 0x20, 0x90, 0x90, 0x90, 0x48, 
-0x80, 0xe1, 0xe1, 0x79, 0x80, 0x35, 0xe2, 0x80, 0xe1, 0xe1, 0x79, 0x40, 
-0x35, 0xeb, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0x79, 0x00, 0x35, 0xe9, 0x80, 
-0xe1, 0xe1, 0x78, 0xc0, 0x35, 0xe7, 0x90, 0x90, 0x90, 0x48, 0x80, 0xe1, 
-0xe1, 0x60, 0xc0, 0x35, 0x7f, 0x80, 0xe1, 0xe1, 0x60, 0x80, 0x35, 0x88, 
-0x90, 0x48, 0x80, 0xe1, 0xe1, 0x60, 0x40, 0x35, 0x86, 0x80, 0xe1, 0xe1, 
-0x60, 0x00, 0x35, 0x84, 0xe4, 0xe2, 0x2f, 0x00, 0x38, 0xe4, 0xa0, 0x0a, 
-0x08, 0x9c, 0xf0, 0x09, 0xc0, 0x92, 0x40, 0x91, 0x20, 0x90, 0x90, 0x90, 
-0x48, 0x80, 0xe1, 0xe1, 0xa8, 0x40, 0x36, 0x9d, 0x80, 0xe1, 0xe1, 0xa8, 
-0x00, 0x36, 0xa6, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0xa7, 0xc0, 0x36, 0xa4, 
-0x80, 0xe1, 0xe1, 0xa7, 0x80, 0x36, 0xa2, 0x90, 0x90, 0x90, 0x48, 0x80, 
-0xe1, 0xe1, 0x8f, 0x80, 0x36, 0x3a, 0x80, 0xe1, 0xe1, 0x8f, 0x40, 0x36, 
-0x43, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0x8f, 0x00, 0x36, 0x41, 0x80, 0xe1, 
-0xe1, 0x8e, 0xc0, 0x36, 0x3f, 0x91, 0x50, 0x90, 0xb0, 0x90, 0x58, 0xa4, 
-0x1e, 0x38, 0xe1, 0xe1, 0x76, 0xc0, 0x35, 0xd7, 0xa4, 0x1e, 0x48, 0xe1, 
-0xe1, 0x76, 0x80, 0x35, 0xe0, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0x76, 0x40, 
-0x35, 0xde, 0xa4, 0x1e, 0x40, 0xe1, 0xe1, 0x76, 0x00, 0x35, 0xdc, 0x90, 
-0xb0, 0x90, 0x58, 0xa4, 0x1e, 0x08, 0xe1, 0xe1, 0x5e, 0x00, 0x35, 0x74, 
-0xa4, 0x1e, 0x18, 0xe1, 0xe1, 0x5d, 0xc0, 0x35, 0x7d, 0x90, 0x48, 0x80, 
-0xe1, 0xe1, 0x5d, 0x80, 0x35, 0x7b, 0xa4, 0x1e, 0x10, 0xe1, 0xe1, 0x5d, 
-0x40, 0x35, 0x79, 0x92, 0x40, 0x91, 0x20, 0x90, 0x90, 0x90, 0x48, 0x80, 
-0xe1, 0xe1, 0xa5, 0x80, 0x36, 0x92, 0x80, 0xe1, 0xe1, 0xa5, 0x40, 0x36, 
-0x9b, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0xa5, 0x00, 0x36, 0x99, 0x80, 0xe1, 
-0xe1, 0xa4, 0xc0, 0x36, 0x97, 0x90, 0x90, 0x90, 0x48, 0x80, 0xe1, 0xe1, 
-0x8c, 0xc0, 0x36, 0x2f, 0x80, 0xe1, 0xe1, 0x8c, 0x80, 0x36, 0x38, 0x90, 
-0x48, 0x80, 0xe1, 0xe1, 0x8c, 0x40, 0x36, 0x36, 0x80, 0xe1, 0xe1, 0x8c, 
-0x00, 0x36, 0x34, 0x91, 0x50, 0x90, 0xb0, 0x90, 0x58, 0xa4, 0x1e, 0x20, 
-0xe1, 0xe1, 0x74, 0x00, 0x35, 0xcc, 0xa4, 0x1e, 0x30, 0xe1, 0xe1, 0x73, 
-0xc0, 0x35, 0xd5, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0x73, 0x80, 0x35, 0xd3, 
-0xa4, 0x1e, 0x28, 0xe1, 0xe1, 0x73, 0x40, 0x35, 0xd1, 0x90, 0xb0, 0x90, 
-0x58, 0xa4, 0x1d, 0xf0, 0xe1, 0xe1, 0x5b, 0x40, 0x35, 0x69, 0xa4, 0x1e, 
-0x00, 0xe1, 0xe1, 0x5b, 0x00, 0x35, 0x72, 0x90, 0x48, 0x80, 0xe1, 0xe1, 
-0x5a, 0xc0, 0x35, 0x70, 0xa4, 0x1d, 0xf8, 0xe1, 0xe1, 0x5a, 0x80, 0x35, 
-0x6e, 0xe4, 0xe2, 0x53, 0x00, 0x39, 0x60, 0x99, 0x50, 0x02, 0x00, 0x10, 
-0x10, 0x10, 0x10, 0x90, 0x90, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0x58, 0x80, 
-0x35, 0x5e, 0x80, 0xe1, 0xe1, 0x58, 0x40, 0x35, 0x67, 0x90, 0x48, 0x80, 
-0xe1, 0xe1, 0x58, 0x00, 0x35, 0x65, 0x80, 0xe1, 0xe1, 0x57, 0xc0, 0x35, 
-0x63, 0x90, 0x60, 0x90, 0x30, 0x60, 0xa0, 0xef, 0x40, 0x60, 0xa0, 0xef, 
-0x00, 0x90, 0x30, 0x60, 0xa0, 0xee, 0xc0, 0x60, 0xa0, 0xee, 0x80, 0xe4, 
-0xe2, 0x2d, 0x00, 0x38, 0xdc, 0xa0, 0x10, 0x98, 0xa0, 0x09, 0xa8, 0x9c, 
-0xc0, 0x09, 0x60, 0x92, 0x70, 0x91, 0x50, 0x90, 0xb0, 0x90, 0x58, 0xa4, 
-0x1e, 0xe0, 0xe1, 0xe1, 0xa2, 0xc0, 0x36, 0x7c, 0xa4, 0x1f, 0x00, 0xe1, 
-0xe1, 0xa2, 0x80, 0x36, 0x90, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0xa2, 0x40, 
-0x36, 0x8e, 0xa4, 0x1e, 0xf0, 0xe1, 0xe1, 0xa2, 0x00, 0x36, 0x8c, 0x90, 
-0x90, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0x8a, 0x00, 0x36, 0x19, 0x80, 0xe1, 
-0xe1, 0x89, 0xc0, 0x36, 0x2d, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0x89, 0x80, 
-0x36, 0x2b, 0x80, 0xe1, 0xe1, 0x89, 0x40, 0x36, 0x29, 0x91, 0x20, 0x90, 
-0x90, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0x71, 0x40, 0x35, 0xb6, 0x80, 0xe1, 
-0xe1, 0x71, 0x00, 0x35, 0xca, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0x70, 0xc0, 
-0x35, 0xc8, 0x80, 0xe1, 0xe1, 0x70, 0x80, 0x35, 0xc6, 0x90, 0x90, 0x90, 
-0x48, 0x80, 0xe1, 0xe1, 0x55, 0xc0, 0x35, 0x48, 0x80, 0xe1, 0xe1, 0x55, 
-0x80, 0x35, 0x5c, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0x55, 0x40, 0x35, 0x5a, 
-0x80, 0xe1, 0xe1, 0x55, 0x00, 0x35, 0x58, 0x92, 0x70, 0x91, 0x50, 0x90, 
-0xb0, 0x90, 0x58, 0xa4, 0x1e, 0xb0, 0xe1, 0xe1, 0x9d, 0x40, 0x36, 0x71, 
-0xa4, 0x1e, 0xd0, 0xe1, 0xe1, 0x9d, 0x00, 0x36, 0x7a, 0x90, 0x48, 0x80, 
-0xe1, 0xe1, 0x9c, 0xc0, 0x36, 0x78, 0xa4, 0x1e, 0xc0, 0xe1, 0xe1, 0x9c, 
-0x80, 0x36, 0x76, 0x90, 0x90, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0x84, 0x80, 
-0x36, 0x0e, 0x80, 0xe1, 0xe1, 0x84, 0x40, 0x36, 0x17, 0x90, 0x48, 0x80, 
-0xe1, 0xe1, 0x84, 0x00, 0x36, 0x15, 0x80, 0xe1, 0xe1, 0x83, 0xc0, 0x36, 
-0x13, 0x91, 0x20, 0x90, 0x90, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0x6b, 0xc0, 
-0x35, 0xab, 0x80, 0xe1, 0xe1, 0x6b, 0x80, 0x35, 0xb4, 0x90, 0x48, 0x80, 
-0xe1, 0xe1, 0x6b, 0x40, 0x35, 0xb2, 0x80, 0xe1, 0xe1, 0x6b, 0x00, 0x35, 
-0xb0, 0x90, 0x90, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0x50, 0x40, 0x35, 0x3d, 
-0x80, 0xe1, 0xe1, 0x50, 0x00, 0x35, 0x46, 0x90, 0x48, 0x80, 0xe1, 0xe1, 
-0x4f, 0xc0, 0x35, 0x44, 0x80, 0xe1, 0xe1, 0x4f, 0x80, 0x35, 0x42, 0xe4, 
-0xe2, 0x52, 0x00, 0x39, 0x5c, 0x9d, 0x70, 0x06, 0xa8, 0x93, 0x20, 0x92, 
-0x00, 0x91, 0x00, 0x90, 0x80, 0x90, 0x40, 0xe1, 0xe1, 0xa0, 0x40, 0x36, 
-0x7d, 0xe1, 0xe1, 0x4b, 0x40, 0x35, 0x3b, 0x90, 0x40, 0xe1, 0xe1, 0xa0, 
-0x00, 0x36, 0x86, 0xe1, 0xe1, 0x4a, 0xc0, 0x35, 0x37, 0x90, 0x80, 0x90, 
-0x40, 0xe1, 0xe1, 0x9f, 0xc0, 0x36, 0x84, 0xe1, 0xe1, 0x4a, 0x40, 0x35, 
-0x33, 0x90, 0x40, 0xe1, 0xe1, 0x9f, 0x80, 0x36, 0x82, 0xe1, 0xe1, 0x49, 
-0xc0, 0x35, 0x2f, 0x90, 0x90, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0x87, 0x80, 
-0x36, 0x1a, 0x80, 0xe1, 0xe1, 0x87, 0x40, 0x36, 0x23, 0x90, 0x48, 0x80, 
-0xe1, 0xe1, 0x87, 0x00, 0x36, 0x21, 0x80, 0xe1, 0xe1, 0x86, 0xc0, 0x36, 
-0x1f, 0x91, 0x20, 0x90, 0x90, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0x6e, 0xc0, 
-0x35, 0xb7, 0x80, 0xe1, 0xe1, 0x6e, 0x80, 0x35, 0xc0, 0x90, 0x48, 0x80, 
-0xe1, 0xe1, 0x6e, 0x40, 0x35, 0xbe, 0x80, 0xe1, 0xe1, 0x6e, 0x00, 0x35, 
-0xbc, 0x90, 0x90, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0x53, 0x40, 0x35, 0x49, 
-0x80, 0xe1, 0xe1, 0x53, 0x00, 0x35, 0x52, 0x90, 0x48, 0x80, 0xe1, 0xe1, 
-0x52, 0xc0, 0x35, 0x50, 0x80, 0xe1, 0xe1, 0x52, 0x80, 0x35, 0x4e, 0x81, 
-0x90, 0xa0, 0x90, 0x50, 0x10, 0x10, 0xe1, 0xe1, 0x46, 0x40, 0x35, 0x11, 
-0x10, 0x10, 0xe1, 0xe1, 0x45, 0xc0, 0x35, 0x23, 0x90, 0x50, 0x10, 0x10, 
-0xe1, 0xe1, 0x45, 0x40, 0x35, 0x1f, 0x10, 0x10, 0xe1, 0xe1, 0x44, 0xc0, 
-0x35, 0x1b, 0xe4, 0xe2, 0x2b, 0x00, 0x38, 0xd4, 0xa0, 0x0b, 0x08, 0x9d, 
-0x70, 0x0a, 0xc0, 0x93, 0x20, 0x92, 0x00, 0x91, 0x00, 0x90, 0x80, 0x90, 
-0x40, 0xe3, 0xa1, 0x26, 0x40, 0x34, 0xa0, 0xe3, 0xa1, 0x0b, 0x80, 0x34, 
-0x3c, 0x90, 0x40, 0xe3, 0xa1, 0x26, 0x00, 0x34, 0x9e, 0xe3, 0xa1, 0x0b, 
-0x00, 0x34, 0x38, 0x90, 0x80, 0x90, 0x40, 0xe3, 0xa1, 0x25, 0xc0, 0x34, 
-0x9c, 0xe3, 0xa1, 0x0a, 0x80, 0x34, 0x34, 0x90, 0x40, 0xe3, 0xa1, 0x25, 
-0x80, 0x34, 0x9a, 0xe3, 0xa1, 0x0a, 0x00, 0x34, 0x30, 0x90, 0x90, 0x90, 
-0x48, 0x80, 0xe3, 0xa1, 0x20, 0xc0, 0x34, 0x8a, 0x80, 0xe3, 0xa1, 0x20, 
-0x80, 0x34, 0x88, 0x90, 0x48, 0x80, 0xe3, 0xa1, 0x20, 0x40, 0x34, 0x86, 
-0x80, 0xe3, 0xa1, 0x20, 0x00, 0x34, 0x84, 0x91, 0x20, 0x90, 0x90, 0x90, 
-0x48, 0x80, 0xe3, 0xa1, 0x1b, 0x40, 0x34, 0x74, 0x80, 0xe3, 0xa1, 0x1b, 
-0x00, 0x34, 0x72, 0x90, 0x48, 0x80, 0xe3, 0xa1, 0x1a, 0xc0, 0x34, 0x70, 
-0x80, 0xe3, 0xa1, 0x1a, 0x80, 0x34, 0x6e, 0x90, 0x90, 0x90, 0x48, 0x80, 
-0xe3, 0xa1, 0x15, 0xc0, 0x34, 0x5e, 0x80, 0xe3, 0xa1, 0x15, 0x80, 0x34, 
-0x5c, 0x90, 0x48, 0x80, 0xe3, 0xa1, 0x15, 0x40, 0x34, 0x5a, 0x80, 0xe3, 
-0xa1, 0x15, 0x00, 0x34, 0x58, 0x93, 0x20, 0x92, 0x00, 0x91, 0x00, 0x90, 
-0x80, 0x90, 0x40, 0xe3, 0xa1, 0x23, 0xc0, 0x34, 0x8b, 0xe3, 0xa1, 0x06, 
-0x80, 0x34, 0x12, 0x90, 0x40, 0xe3, 0xa1, 0x23, 0x80, 0x34, 0x94, 0xe3, 
-0xa1, 0x06, 0x00, 0x34, 0x24, 0x90, 0x80, 0x90, 0x40, 0xe3, 0xa1, 0x23, 
-0x40, 0x34, 0x92, 0xe3, 0xa1, 0x05, 0x80, 0x34, 0x20, 0x90, 0x40, 0xe3, 
-0xa1, 0x23, 0x00, 0x34, 0x90, 0xe3, 0xa1, 0x05, 0x00, 0x34, 0x1c, 0x90, 
-0x90, 0x90, 0x48, 0x80, 0xe3, 0xa1, 0x1e, 0x40, 0x34, 0x75, 0x80, 0xe3, 
-0xa1, 0x1e, 0x00, 0x34, 0x7e, 0x90, 0x48, 0x80, 0xe3, 0xa1, 0x1d, 0xc0, 
-0x34, 0x7c, 0x80, 0xe3, 0xa1, 0x1d, 0x80, 0x34, 0x7a, 0x91, 0x20, 0x90, 
-0x90, 0x90, 0x48, 0x80, 0xe3, 0xa1, 0x18, 0xc0, 0x34, 0x5f, 0x80, 0xe3, 
-0xa1, 0x18, 0x80, 0x34, 0x68, 0x90, 0x48, 0x80, 0xe3, 0xa1, 0x18, 0x40, 
-0x34, 0x66, 0x80, 0xe3, 0xa1, 0x18, 0x00, 0x34, 0x64, 0x90, 0x90, 0x90, 
-0x48, 0x80, 0xe3, 0xa1, 0x13, 0x40, 0x34, 0x49, 0x80, 0xe3, 0xa1, 0x13, 
-0x00, 0x34, 0x52, 0x90, 0x48, 0x80, 0xe3, 0xa1, 0x12, 0xc0, 0x34, 0x50, 
-0x80, 0xe3, 0xa1, 0x12, 0x80, 0x34, 0x4e, 0xe4, 0xe2, 0x51, 0x00, 0x39, 
-0x58, 0x88, 0x01, 0x48, 0x10, 0x10, 0x10, 0x10, 0x90, 0x90, 0x90, 0x48, 
-0x80, 0xe3, 0xa1, 0x10, 0x80, 0x34, 0x3e, 0x80, 0xe3, 0xa1, 0x10, 0x40, 
-0x34, 0x47, 0x90, 0x48, 0x80, 0xe3, 0xa1, 0x10, 0x00, 0x34, 0x45, 0x80, 
-0xe3, 0xa1, 0x0f, 0xc0, 0x34, 0x43, 0xe4, 0xe2, 0x29, 0x00, 0x38, 0xcc, 
-0xa0, 0x0e, 0x80, 0xa0, 0x09, 0x08, 0x94, 0x80, 0x9a, 0x30, 0x04, 0x40, 
-0x91, 0x10, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x35, 0x0f, 0x80, 
-0x35, 0x0e, 0x10, 0x10, 0x80, 0x35, 0x0d, 0x90, 0x50, 0x90, 0x28, 0x80, 
-0x34, 0xf4, 0x80, 0x34, 0xf3, 0x10, 0x10, 0x80, 0x34, 0xf2, 0x90, 0x88, 
-0x90, 0x50, 0x90, 0x28, 0x80, 0x34, 0xd9, 0x80, 0x34, 0xd8, 0x10, 0x10, 
-0x80, 0x34, 0xd7, 0x90, 0x50, 0x90, 0x28, 0x80, 0x34, 0xbe, 0x80, 0x34, 
-0xbd, 0x10, 0x10, 0x80, 0x34, 0xbc, 0x91, 0x10, 0x90, 0x88, 0x90, 0x50, 
-0x90, 0x28, 0x80, 0x35, 0x0a, 0x80, 0x35, 0x0c, 0x10, 0x10, 0x80, 0x35, 
-0x0b, 0x90, 0x50, 0x90, 0x28, 0x80, 0x34, 0xef, 0x80, 0x34, 0xf1, 0x10, 
-0x10, 0x80, 0x34, 0xf0, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x34, 
-0xd4, 0x80, 0x34, 0xd6, 0x10, 0x10, 0x80, 0x34, 0xd5, 0x90, 0x50, 0x90, 
-0x28, 0x80, 0x34, 0xb9, 0x80, 0x34, 0xbb, 0x10, 0x10, 0x80, 0x34, 0xba, 
-0xe4, 0xe2, 0x43, 0x00, 0x39, 0x34, 0x9a, 0x30, 0x04, 0x40, 0x91, 0x10, 
-0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x35, 0x07, 0x80, 0x35, 0x09, 
-0x10, 0x10, 0x80, 0x35, 0x08, 0x90, 0x50, 0x90, 0x28, 0x80, 0x34, 0xec, 
-0x80, 0x34, 0xee, 0x10, 0x10, 0x80, 0x34, 0xed, 0x90, 0x88, 0x90, 0x50, 
-0x90, 0x28, 0x80, 0x34, 0xd1, 0x80, 0x34, 0xd3, 0x10, 0x10, 0x80, 0x34, 
-0xd2, 0x90, 0x50, 0x90, 0x28, 0x80, 0x34, 0xb6, 0x80, 0x34, 0xb8, 0x10, 
-0x10, 0x80, 0x34, 0xb7, 0x91, 0x10, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 
-0x80, 0x35, 0x04, 0x80, 0x35, 0x06, 0x10, 0x10, 0x80, 0x35, 0x05, 0x90, 
-0x50, 0x90, 0x28, 0x80, 0x34, 0xe9, 0x80, 0x34, 0xeb, 0x10, 0x10, 0x80, 
-0x34, 0xea, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x34, 0xce, 0x80, 
-0x34, 0xd0, 0x10, 0x10, 0x80, 0x34, 0xcf, 0x90, 0x50, 0x90, 0x28, 0x80, 
-0x34, 0xb3, 0x80, 0x34, 0xb5, 0x10, 0x10, 0x80, 0x34, 0xb4, 0xe4, 0xe2, 
-0x22, 0x00, 0x38, 0x9c, 0x94, 0x80, 0x9a, 0x30, 0x04, 0x40, 0x91, 0x10, 
-0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x35, 0x01, 0x80, 0x35, 0x03, 
-0x10, 0x10, 0x80, 0x35, 0x02, 0x90, 0x50, 0x90, 0x28, 0x80, 0x34, 0xe6, 
-0x80, 0x34, 0xe8, 0x10, 0x10, 0x80, 0x34, 0xe7, 0x90, 0x88, 0x90, 0x50, 
-0x90, 0x28, 0x80, 0x34, 0xcb, 0x80, 0x34, 0xcd, 0x10, 0x10, 0x80, 0x34, 
-0xcc, 0x90, 0x50, 0x90, 0x28, 0x80, 0x34, 0xb0, 0x80, 0x34, 0xb2, 0x10, 
-0x10, 0x80, 0x34, 0xb1, 0x91, 0x10, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 
-0x80, 0x34, 0xfe, 0x80, 0x35, 0x00, 0x10, 0x10, 0x80, 0x34, 0xff, 0x90, 
-0x50, 0x90, 0x28, 0x80, 0x34, 0xe3, 0x80, 0x34, 0xe5, 0x10, 0x10, 0x80, 
-0x34, 0xe4, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x34, 0xc8, 0x80, 
-0x34, 0xca, 0x10, 0x10, 0x80, 0x34, 0xc9, 0x90, 0x50, 0x90, 0x28, 0x80, 
-0x34, 0xad, 0x80, 0x34, 0xaf, 0x10, 0x10, 0x80, 0x34, 0xae, 0xe4, 0xe2, 
-0x41, 0x00, 0x39, 0x2c, 0x88, 0x00, 0xb0, 0x10, 0x10, 0x10, 0x10, 0x90, 
-0x50, 0x90, 0x28, 0x80, 0x34, 0xaa, 0x80, 0x34, 0xac, 0x10, 0x10, 0x80, 
-0x34, 0xab, 0xe4, 0xe2, 0x21, 0x00, 0x38, 0x98, 0x96, 0xe8, 0x94, 0x80, 
-0x9a, 0x30, 0x04, 0x40, 0x91, 0x10, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 
-0x80, 0x34, 0xf8, 0x80, 0x34, 0xfd, 0x10, 0x10, 0x80, 0x34, 0xfc, 0x90, 
-0x50, 0x90, 0x28, 0x80, 0x34, 0xdd, 0x80, 0x34, 0xe2, 0x10, 0x10, 0x80, 
-0x34, 0xe1, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x34, 0xc2, 0x80, 
-0x34, 0xc7, 0x10, 0x10, 0x80, 0x34, 0xc6, 0x90, 0x50, 0x90, 0x28, 0x80, 
-0x34, 0xa4, 0x80, 0x34, 0xa9, 0x10, 0x10, 0x80, 0x34, 0xa8, 0x91, 0x10, 
-0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x34, 0xf5, 0x80, 0x34, 0xf7, 
-0x10, 0x10, 0x80, 0x34, 0xf6, 0x90, 0x50, 0x90, 0x28, 0x80, 0x34, 0xda, 
-0x80, 0x34, 0xdc, 0x10, 0x10, 0x80, 0x34, 0xdb, 0x90, 0x88, 0x90, 0x50, 
-0x90, 0x28, 0x80, 0x34, 0xbf, 0x80, 0x34, 0xc1, 0x10, 0x10, 0x80, 0x34, 
-0xc0, 0x90, 0x50, 0x90, 0x28, 0x80, 0x34, 0xa1, 0x80, 0x34, 0xa3, 0x10, 
-0x10, 0x80, 0x34, 0xa2, 0xe4, 0xe2, 0x3f, 0x00, 0x39, 0x24, 0x88, 0x02, 
-0x28, 0x91, 0x10, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x34, 0xf9, 
-0x80, 0x34, 0xfb, 0x10, 0x10, 0x80, 0x34, 0xfa, 0x90, 0x50, 0x90, 0x28, 
-0x80, 0x34, 0xde, 0x80, 0x34, 0xe0, 0x10, 0x10, 0x80, 0x34, 0xdf, 0x90, 
-0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x34, 0xc3, 0x80, 0x34, 0xc5, 0x10, 
-0x10, 0x80, 0x34, 0xc4, 0x90, 0x50, 0x90, 0x28, 0x80, 0x34, 0xa5, 0x80, 
-0x34, 0xa7, 0x10, 0x10, 0x80, 0x34, 0xa6, 0xe4, 0xe2, 0x20, 0x00, 0x38, 
-0x94, 0x90, 0x40, 0xe5, 0x22, 0x3d, 0x00, 0x39, 0x1c, 0xe5, 0x22, 0x1f, 
-0x00, 0x38, 0x90, 0x9e, 0xb4, 0x3d, 0x08, 0x93, 0x70, 0x91, 0xd8, 0xd5, 
-0x07, 0x80, 0xd0, 0xc4, 0x40, 0x90, 0x48, 0x80, 0x8c, 0x58, 0x50, 0x84, 
-0x3b, 0x14, 0xa4, 0x56, 0x30, 0x3a, 0xde, 0x90, 0x28, 0x24, 0x55, 0x70, 
-0xa4, 0x53, 0xf0, 0x3a, 0x96, 0xd0, 0xc4, 0x40, 0x90, 0x48, 0x80, 0x8c, 
-0x58, 0x30, 0x84, 0x3b, 0x12, 0xa4, 0x56, 0x20, 0x3a, 0xdc, 0x90, 0x28, 
-0x24, 0x55, 0x60, 0xa4, 0x53, 0xe0, 0x3a, 0x94, 0xd5, 0x06, 0x80, 0xd0, 
-0xc3, 0x40, 0x90, 0x28, 0x80, 0x3a, 0xfe, 0xa4, 0x56, 0x00, 0x3a, 0xd8, 
-0x90, 0x28, 0x24, 0x55, 0x40, 0xa4, 0x53, 0xc0, 0x3a, 0x90, 0xd0, 0xc3, 
-0x40, 0x90, 0x28, 0x80, 0x3a, 0xfa, 0xa4, 0x55, 0xf0, 0x3a, 0xd6, 0x90, 
-0x28, 0x24, 0x55, 0x30, 0xa4, 0x53, 0xb0, 0x3a, 0x8e, 0x91, 0x98, 0xd5, 
-0x06, 0x80, 0xd0, 0xc3, 0x40, 0x90, 0x28, 0x80, 0x3a, 0xf2, 0xa4, 0x55, 
-0xd0, 0x3a, 0xd2, 0x90, 0x28, 0x24, 0x55, 0x10, 0xa4, 0x53, 0x90, 0x3a, 
-0x8a, 0xd0, 0xc3, 0x40, 0x90, 0x28, 0x80, 0x3a, 0xee, 0xa4, 0x55, 0xc0, 
-0x3a, 0xd0, 0x90, 0x28, 0x24, 0x55, 0x00, 0xa4, 0x53, 0x80, 0x3a, 0x88, 
-0xd5, 0x06, 0x80, 0xd0, 0xc3, 0x40, 0x90, 0x28, 0x80, 0x3a, 0xe6, 0xa4, 
-0x55, 0xa0, 0x3a, 0xcc, 0x90, 0x28, 0x24, 0x54, 0xe0, 0xa4, 0x53, 0x60, 
-0x3a, 0x84, 0xd0, 0xc3, 0x40, 0x90, 0x28, 0x80, 0x3a, 0xe2, 0xa4, 0x55, 
-0x90, 0x3a, 0xca, 0x90, 0x28, 0x24, 0x54, 0xd0, 0xa4, 0x53, 0x50, 0x3a, 
-0x82, 0x93, 0x70, 0x91, 0xd8, 0xd5, 0x07, 0x80, 0xd0, 0xc4, 0x40, 0x90, 
-0x48, 0x80, 0x8c, 0x58, 0x70, 0x84, 0x3b, 0x16, 0xa4, 0x56, 0x40, 0x3a, 
-0xe0, 0x90, 0x28, 0x24, 0x55, 0x80, 0xa4, 0x54, 0x00, 0x3a, 0x98, 0xd0, 
-0xc4, 0x40, 0x90, 0x48, 0x80, 0x8c, 0x58, 0x40, 0x84, 0x3b, 0x13, 0xa4, 
-0x56, 0x28, 0x3a, 0xdd, 0x90, 0x28, 0x24, 0x55, 0x68, 0xa4, 0x53, 0xe8, 
-0x3a, 0x95, 0xd5, 0x06, 0x80, 0xd0, 0xc3, 0x40, 0x90, 0x28, 0x80, 0x3b, 
-0x02, 0xa4, 0x56, 0x10, 0x3a, 0xda, 0x90, 0x28, 0x24, 0x55, 0x50, 0xa4, 
-0x53, 0xd0, 0x3a, 0x92, 0xd0, 0xc3, 0x40, 0x90, 0x28, 0x80, 0x3a, 0xfc, 
-0xa4, 0x55, 0xf8, 0x3a, 0xd7, 0x90, 0x28, 0x24, 0x55, 0x38, 0xa4, 0x53, 
-0xb8, 0x3a, 0x8f, 0x91, 0x98, 0xd5, 0x06, 0x80, 0xd0, 0xc3, 0x40, 0x90, 
-0x28, 0x80, 0x3a, 0xf6, 0xa4, 0x55, 0xe0, 0x3a, 0xd4, 0x90, 0x28, 0x24, 
-0x55, 0x20, 0xa4, 0x53, 0xa0, 0x3a, 0x8c, 0xd0, 0xc3, 0x40, 0x90, 0x28, 
-0x80, 0x3a, 0xf0, 0xa4, 0x55, 0xc8, 0x3a, 0xd1, 0x90, 0x28, 0x24, 0x55, 
-0x08, 0xa4, 0x53, 0x88, 0x3a, 0x89, 0xd5, 0x06, 0x80, 0xd0, 0xc3, 0x40, 
-0x90, 0x28, 0x80, 0x3a, 0xea, 0xa4, 0x55, 0xb0, 0x3a, 0xce, 0x90, 0x28, 
-0x24, 0x54, 0xf0, 0xa4, 0x53, 0x70, 0x3a, 0x86, 0xd0, 0xc3, 0x40, 0x90, 
-0x28, 0x80, 0x3a, 0xe4, 0xa4, 0x55, 0x98, 0x3a, 0xcb, 0x90, 0x28, 0x24, 
-0x54, 0xd8, 0xa4, 0x53, 0x58, 0x3a, 0x83, 0x99, 0xd8, 0x03, 0x90, 0x81, 
-0x90, 0xe0, 0x5b, 0x41, 0x40, 0x03, 0x40, 0x51, 0x40, 0xc0, 0xa4, 0x3c, 
-0xa0, 0x37, 0x84, 0xd1, 0x42, 0x00, 0xa4, 0x3b, 0xa0, 0x37, 0x64, 0xa4, 
-0x3a, 0xa0, 0x37, 0x44, 0x5b, 0x41, 0x40, 0x03, 0x40, 0x51, 0x40, 0xc0, 
-0xa4, 0x3b, 0xc0, 0x37, 0x88, 0xd1, 0x42, 0x00, 0xa4, 0x3a, 0xc0, 0x37, 
-0x68, 0xa4, 0x39, 0xc0, 0x37, 0x48, 0x81, 0x90, 0xe0, 0x5b, 0x41, 0x40, 
-0x03, 0x40, 0x51, 0x40, 0xc0, 0xa4, 0x3c, 0x00, 0x37, 0x90, 0xd1, 0x42, 
-0x00, 0xa4, 0x3b, 0x00, 0x37, 0x70, 0xa4, 0x3a, 0x00, 0x37, 0x50, 0x5b, 
-0x41, 0x40, 0x03, 0x40, 0x51, 0x40, 0xc0, 0xa4, 0x3b, 0xe0, 0x37, 0x8c, 
-0xd1, 0x42, 0x00, 0xa4, 0x3a, 0xe0, 0x37, 0x6c, 0xa4, 0x39, 0xe0, 0x37, 
-0x4c, 0xa8, 0x0b, 0x18, 0x13, 0xa8, 0x96, 0x80, 0x93, 0x40, 0x99, 0x90, 
-0x03, 0x00, 0x90, 0xc0, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x1d, 0xc0, 0x33, 
-0xb9, 0x24, 0x1d, 0xb8, 0x90, 0x38, 0xa4, 0x1c, 0xe8, 0x33, 0x9e, 0x24, 
-0x1c, 0xe0, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x1c, 0x10, 0x33, 0x83, 0x24, 
-0x1c, 0x08, 0x90, 0x38, 0xa4, 0x1b, 0x38, 0x33, 0x68, 0x24, 0x1b, 0x30, 
-0x90, 0xc0, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x1d, 0xb0, 0x33, 0xb4, 0x24, 
-0x1d, 0xa8, 0x90, 0x38, 0xa4, 0x1c, 0xd8, 0x33, 0x99, 0x24, 0x1c, 0xd0, 
-0x90, 0x60, 0x90, 0x38, 0xa4, 0x1c, 0x00, 0x33, 0x7e, 0x24, 0x1b, 0xf8, 
-0x90, 0x38, 0xa4, 0x1b, 0x28, 0x33, 0x63, 0x24, 0x1b, 0x20, 0xe4, 0xe2, 
-0x99, 0x00, 0x3a, 0x66, 0x99, 0x90, 0x03, 0x00, 0x90, 0xc0, 0x90, 0x60, 
-0x90, 0x38, 0xa4, 0x1d, 0x98, 0x33, 0xb1, 0x24, 0x1d, 0x90, 0x90, 0x38, 
-0xa4, 0x1c, 0xc0, 0x33, 0x96, 0x24, 0x1c, 0xb8, 0x90, 0x60, 0x90, 0x38, 
-0xa4, 0x1b, 0xe8, 0x33, 0x7b, 0x24, 0x1b, 0xe0, 0x90, 0x38, 0xa4, 0x1b, 
-0x10, 0x33, 0x60, 0x24, 0x1b, 0x08, 0x90, 0xc0, 0x90, 0x60, 0x90, 0x38, 
-0xa4, 0x1d, 0x80, 0x33, 0xae, 0x24, 0x1d, 0x78, 0x90, 0x38, 0xa4, 0x1c, 
-0xa8, 0x33, 0x93, 0x24, 0x1c, 0xa0, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x1b, 
-0xd0, 0x33, 0x78, 0x24, 0x1b, 0xc8, 0x90, 0x38, 0xa4, 0x1a, 0xf8, 0x33, 
-0x5d, 0x24, 0x1a, 0xf0, 0xe4, 0xe2, 0x97, 0x80, 0x3a, 0x60, 0x93, 0x78, 
-0x99, 0x90, 0x03, 0x00, 0x90, 0xc0, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x1d, 
-0x68, 0x33, 0xab, 0x24, 0x1d, 0x60, 0x90, 0x38, 0xa4, 0x1c, 0x90, 0x33, 
-0x90, 0x24, 0x1c, 0x88, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x1b, 0xb8, 0x33, 
-0x75, 0x24, 0x1b, 0xb0, 0x90, 0x38, 0xa4, 0x1a, 0xe0, 0x33, 0x5a, 0x24, 
-0x1a, 0xd8, 0x90, 0xc0, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x1d, 0x50, 0x33, 
-0xa8, 0x24, 0x1d, 0x48, 0x90, 0x38, 0xa4, 0x1c, 0x78, 0x33, 0x8d, 0x24, 
-0x1c, 0x70, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x1b, 0xa0, 0x33, 0x72, 0x24, 
-0x1b, 0x98, 0x90, 0x38, 0xa4, 0x1a, 0xc8, 0x33, 0x57, 0x24, 0x1a, 0xc0, 
-0xec, 0xa1, 0xe7, 0x00, 0x02, 0x00, 0x37, 0x9e, 0xa4, 0x52, 0xc0, 0x3a, 
-0x5a, 0x88, 0x00, 0x88, 0x10, 0x10, 0x10, 0x10, 0x90, 0x38, 0xa4, 0x1a, 
-0xb0, 0x33, 0x54, 0x24, 0x1a, 0xa8, 0xe9, 0x61, 0xe6, 0x40, 0x02, 0x00, 
-0x37, 0x9a, 0xe3, 0x62, 0x94, 0x80, 0x3a, 0x54, 0x95, 0x08, 0x93, 0x40, 
-0x99, 0x90, 0x03, 0x00, 0x90, 0xc0, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x1d, 
-0x38, 0x33, 0xa2, 0x24, 0x1d, 0x30, 0x90, 0x38, 0xa4, 0x1c, 0x60, 0x33, 
-0x87, 0x24, 0x1c, 0x58, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x1b, 0x88, 0x33, 
-0x6c, 0x24, 0x1b, 0x80, 0x90, 0x38, 0xa4, 0x1a, 0x98, 0x33, 0x4e, 0x24, 
-0x1a, 0x90, 0x90, 0xc0, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x1d, 0x08, 0x33, 
-0x9f, 0x24, 0x1d, 0x00, 0x90, 0x38, 0xa4, 0x1c, 0x30, 0x33, 0x84, 0x24, 
-0x1c, 0x28, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x1b, 0x58, 0x33, 0x69, 0x24, 
-0x1b, 0x50, 0x90, 0x38, 0xa4, 0x1a, 0x68, 0x33, 0x4b, 0x24, 0x1a, 0x60, 
-0xe4, 0xe2, 0x99, 0x40, 0x3a, 0x68, 0x88, 0x01, 0x88, 0x90, 0xc0, 0x90, 
-0x60, 0x90, 0x38, 0xa4, 0x1d, 0x28, 0x33, 0xa3, 0x24, 0x1d, 0x20, 0x90, 
-0x38, 0xa4, 0x1c, 0x50, 0x33, 0x88, 0x24, 0x1c, 0x48, 0x90, 0x60, 0x90, 
-0x38, 0xa4, 0x1b, 0x78, 0x33, 0x6d, 0x24, 0x1b, 0x70, 0x90, 0x38, 0xa4, 
-0x1a, 0x88, 0x33, 0x4f, 0x24, 0x1a, 0x80, 0xe4, 0xe2, 0x97, 0xc0, 0x3a, 
-0x62, 0x92, 0xd0, 0x99, 0x50, 0x02, 0x80, 0x90, 0xa0, 0x90, 0x50, 0x90, 
-0x28, 0x80, 0x33, 0x4a, 0x24, 0x1a, 0x48, 0x90, 0x28, 0x80, 0x33, 0x46, 
-0x24, 0x1a, 0x28, 0x90, 0x50, 0x90, 0x28, 0x80, 0x33, 0x42, 0x24, 0x1a, 
-0x08, 0x90, 0x28, 0x80, 0x33, 0x3e, 0x24, 0x19, 0xe8, 0x90, 0xa0, 0x90, 
-0x50, 0x90, 0x28, 0x80, 0x33, 0x47, 0x24, 0x1a, 0x40, 0x90, 0x28, 0x80, 
-0x33, 0x43, 0x24, 0x1a, 0x20, 0x90, 0x50, 0x90, 0x28, 0x80, 0x33, 0x3f, 
-0x24, 0x1a, 0x00, 0x90, 0x28, 0x80, 0x33, 0x3b, 0x24, 0x19, 0xe0, 0xec, 
-0xe2, 0x96, 0x61, 0xe8, 0x00, 0x3a, 0x5c, 0x88, 0x00, 0x78, 0x10, 0x10, 
-0x10, 0x10, 0x90, 0x28, 0x80, 0x33, 0x39, 0x24, 0x19, 0xd0, 0xec, 0xe2, 
-0x94, 0xe1, 0xe6, 0x00, 0x3a, 0x56, 0xe5, 0xa2, 0x1e, 0x00, 0x38, 0x74, 
-0xa0, 0x41, 0xe0, 0xa8, 0x2c, 0x30, 0x41, 0xa8, 0xa0, 0x16, 0x68, 0xa0, 
-0x14, 0x50, 0xa0, 0x0a, 0x28, 0x95, 0x10, 0x92, 0x70, 0x91, 0x20, 0x90, 
-0x90, 0x90, 0x48, 0x80, 0xe1, 0xe0, 0x9a, 0xc0, 0x32, 0x72, 0x80, 0xe1, 
-0xe0, 0x9a, 0x80, 0x32, 0x70, 0x90, 0x48, 0x80, 0xe1, 0xe0, 0x9a, 0x40, 
-0x32, 0x6e, 0x80, 0xe1, 0xe0, 0x9a, 0x00, 0x32, 0x6c, 0x90, 0xb0, 0x90, 
-0x58, 0xa4, 0x0b, 0xf8, 0xe1, 0xe0, 0xab, 0x40, 0x32, 0xb4, 0xa4, 0x0b, 
-0xf0, 0xe1, 0xe0, 0xab, 0x00, 0x32, 0xb2, 0x90, 0x48, 0x80, 0xe1, 0xe0, 
-0xaa, 0xc0, 0x32, 0xb0, 0xa4, 0x0b, 0xe8, 0xe1, 0xe0, 0xaa, 0x80, 0x32, 
-0xae, 0x91, 0x50, 0x90, 0xb0, 0x90, 0x58, 0xa4, 0x0d, 0x18, 0xe1, 0xe0, 
-0xcc, 0x40, 0x33, 0x38, 0xa4, 0x0d, 0x10, 0xe1, 0xe0, 0xcc, 0x00, 0x33, 
-0x36, 0x90, 0x48, 0x80, 0xe1, 0xe0, 0xcb, 0xc0, 0x33, 0x34, 0xa4, 0x0d, 
-0x08, 0xe1, 0xe0, 0xcb, 0x80, 0x33, 0x32, 0x90, 0xb0, 0x90, 0x58, 0xa4, 
-0x0c, 0x88, 0xe1, 0xe0, 0xbb, 0xc0, 0x32, 0xf6, 0xa4, 0x0c, 0x80, 0xe1, 
-0xe0, 0xbb, 0x80, 0x32, 0xf4, 0x90, 0x48, 0x80, 0xe1, 0xe0, 0xbb, 0x40, 
-0x32, 0xf2, 0xa4, 0x0c, 0x78, 0xe1, 0xe0, 0xbb, 0x00, 0x32, 0xf0, 0x92, 
-0x70, 0x91, 0x20, 0x90, 0x90, 0x90, 0x48, 0x80, 0xe1, 0xe0, 0x98, 0x40, 
-0x32, 0x5d, 0x80, 0xe1, 0xe0, 0x98, 0x00, 0x32, 0x66, 0x90, 0x48, 0x80, 
-0xe1, 0xe0, 0x97, 0xc0, 0x32, 0x64, 0x80, 0xe1, 0xe0, 0x97, 0x80, 0x32, 
-0x62, 0x90, 0xb0, 0x90, 0x58, 0xa4, 0x0b, 0xd0, 0xe1, 0xe0, 0xa8, 0xc0, 
-0x32, 0x9f, 0xa4, 0x0b, 0xe0, 0xe1, 0xe0, 0xa8, 0x80, 0x32, 0xa8, 0x90, 
-0x48, 0x80, 0xe1, 0xe0, 0xa8, 0x40, 0x32, 0xa6, 0xa4, 0x0b, 0xd8, 0xe1, 
-0xe0, 0xa8, 0x00, 0x32, 0xa4, 0x91, 0x50, 0x90, 0xb0, 0x90, 0x58, 0xa4, 
-0x0c, 0xf0, 0xe1, 0xe0, 0xc9, 0xc0, 0x33, 0x23, 0xa4, 0x0d, 0x00, 0xe1, 
-0xe0, 0xc9, 0x80, 0x33, 0x2c, 0x90, 0x48, 0x80, 0xe1, 0xe0, 0xc9, 0x40, 
-0x33, 0x2a, 0xa4, 0x0c, 0xf8, 0xe1, 0xe0, 0xc9, 0x00, 0x33, 0x28, 0x90, 
-0xb0, 0x90, 0x58, 0xa4, 0x0c, 0x60, 0xe1, 0xe0, 0xb9, 0x40, 0x32, 0xe1, 
-0xa4, 0x0c, 0x70, 0xe1, 0xe0, 0xb9, 0x00, 0x32, 0xea, 0x90, 0x48, 0x80, 
-0xe1, 0xe0, 0xb8, 0xc0, 0x32, 0xe8, 0xa4, 0x0c, 0x68, 0xe1, 0xe0, 0xb8, 
-0x80, 0x32, 0xe6, 0x95, 0x10, 0x92, 0x70, 0x91, 0x20, 0x90, 0x90, 0x90, 
-0x48, 0x80, 0xe1, 0xe0, 0x95, 0x80, 0x32, 0x52, 0x80, 0xe1, 0xe0, 0x95, 
-0x40, 0x32, 0x5b, 0x90, 0x48, 0x80, 0xe1, 0xe0, 0x95, 0x00, 0x32, 0x59, 
-0x80, 0xe1, 0xe0, 0x94, 0xc0, 0x32, 0x57, 0x90, 0xb0, 0x90, 0x58, 0xa4, 
-0x0b, 0xb8, 0xe1, 0xe0, 0xa6, 0x00, 0x32, 0x94, 0xa4, 0x0b, 0xc8, 0xe1, 
-0xe0, 0xa5, 0xc0, 0x32, 0x9d, 0x90, 0x48, 0x80, 0xe1, 0xe0, 0xa5, 0x80, 
-0x32, 0x9b, 0xa4, 0x0b, 0xc0, 0xe1, 0xe0, 0xa5, 0x40, 0x32, 0x99, 0x91, 
-0x50, 0x90, 0xb0, 0x90, 0x58, 0xa4, 0x0c, 0xd8, 0xe1, 0xe0, 0xc7, 0x00, 
-0x33, 0x18, 0xa4, 0x0c, 0xe8, 0xe1, 0xe0, 0xc6, 0xc0, 0x33, 0x21, 0x90, 
-0x48, 0x80, 0xe1, 0xe0, 0xc6, 0x80, 0x33, 0x1f, 0xa4, 0x0c, 0xe0, 0xe1, 
-0xe0, 0xc6, 0x40, 0x33, 0x1d, 0x90, 0xb0, 0x90, 0x58, 0xa4, 0x0c, 0x48, 
-0xe1, 0xe0, 0xb6, 0x80, 0x32, 0xd6, 0xa4, 0x0c, 0x58, 0xe1, 0xe0, 0xb6, 
-0x40, 0x32, 0xdf, 0x90, 0x48, 0x80, 0xe1, 0xe0, 0xb6, 0x00, 0x32, 0xdd, 
-0xa4, 0x0c, 0x50, 0xe1, 0xe0, 0xb5, 0xc0, 0x32, 0xdb, 0x92, 0x70, 0x91, 
-0x20, 0x90, 0x90, 0x90, 0x48, 0x80, 0xe1, 0xe0, 0x92, 0xc0, 0x32, 0x47, 
-0x80, 0xe1, 0xe0, 0x92, 0x80, 0x32, 0x50, 0x90, 0x48, 0x80, 0xe1, 0xe0, 
-0x92, 0x40, 0x32, 0x4e, 0x80, 0xe1, 0xe0, 0x92, 0x00, 0x32, 0x4c, 0x90, 
-0xb0, 0x90, 0x58, 0xa4, 0x0b, 0xa0, 0xe1, 0xe0, 0xa3, 0x40, 0x32, 0x89, 
-0xa4, 0x0b, 0xb0, 0xe1, 0xe0, 0xa3, 0x00, 0x32, 0x92, 0x90, 0x48, 0x80, 
-0xe1, 0xe0, 0xa2, 0xc0, 0x32, 0x90, 0xa4, 0x0b, 0xa8, 0xe1, 0xe0, 0xa2, 
-0x80, 0x32, 0x8e, 0x91, 0x50, 0x90, 0xb0, 0x90, 0x58, 0xa4, 0x0c, 0xc0, 
-0xe1, 0xe0, 0xc4, 0x40, 0x33, 0x0d, 0xa4, 0x0c, 0xd0, 0xe1, 0xe0, 0xc4, 
-0x00, 0x33, 0x16, 0x90, 0x48, 0x80, 0xe1, 0xe0, 0xc3, 0xc0, 0x33, 0x14, 
-0xa4, 0x0c, 0xc8, 0xe1, 0xe0, 0xc3, 0x80, 0x33, 0x12, 0x90, 0xb0, 0x90, 
-0x58, 0xa4, 0x0c, 0x30, 0xe1, 0xe0, 0xb3, 0xc0, 0x32, 0xcb, 0xa4, 0x0c, 
-0x40, 0xe1, 0xe0, 0xb3, 0x80, 0x32, 0xd4, 0x90, 0x48, 0x80, 0xe1, 0xe0, 
-0xb3, 0x40, 0x32, 0xd2, 0xa4, 0x0c, 0x38, 0xe1, 0xe0, 0xb3, 0x00, 0x32, 
-0xd0, 0x10, 0x10, 0x91, 0x40, 0x10, 0x10, 0x10, 0x10, 0x90, 0x90, 0x90, 
-0x48, 0x80, 0xe1, 0xe0, 0x8a, 0x80, 0x32, 0x26, 0x80, 0xe1, 0xe0, 0x8a, 
-0x40, 0x32, 0x2f, 0x90, 0x48, 0x80, 0xe1, 0xe0, 0x8a, 0x00, 0x32, 0x2d, 
-0x80, 0xe1, 0xe0, 0x89, 0xc0, 0x32, 0x2b, 0x90, 0x60, 0x90, 0x30, 0x60, 
-0xa0, 0x32, 0xc0, 0x60, 0xa0, 0x32, 0x80, 0x90, 0x30, 0x60, 0xa0, 0x32, 
-0x40, 0x60, 0xa0, 0x32, 0x00, 0xa0, 0x0f, 0xe0, 0xa0, 0x0a, 0x28, 0x95, 
-0x10, 0x92, 0x70, 0x91, 0x20, 0x90, 0x90, 0x90, 0x48, 0x80, 0xe1, 0xe0, 
-0x90, 0x00, 0x32, 0x3c, 0x80, 0xe1, 0xe0, 0x8f, 0xc0, 0x32, 0x45, 0x90, 
-0x48, 0x80, 0xe1, 0xe0, 0x8f, 0x80, 0x32, 0x43, 0x80, 0xe1, 0xe0, 0x8f, 
-0x40, 0x32, 0x41, 0x90, 0xb0, 0x90, 0x58, 0xa4, 0x0b, 0x88, 0xe1, 0xe0, 
-0xa0, 0x80, 0x32, 0x7e, 0xa4, 0x0b, 0x98, 0xe1, 0xe0, 0xa0, 0x40, 0x32, 
-0x87, 0x90, 0x48, 0x80, 0xe1, 0xe0, 0xa0, 0x00, 0x32, 0x85, 0xa4, 0x0b, 
-0x90, 0xe1, 0xe0, 0x9f, 0xc0, 0x32, 0x83, 0x91, 0x50, 0x90, 0xb0, 0x90, 
-0x58, 0xa4, 0x0c, 0xa8, 0xe1, 0xe0, 0xc1, 0x80, 0x33, 0x02, 0xa4, 0x0c, 
-0xb8, 0xe1, 0xe0, 0xc1, 0x40, 0x33, 0x0b, 0x90, 0x48, 0x80, 0xe1, 0xe0, 
-0xc1, 0x00, 0x33, 0x09, 0xa4, 0x0c, 0xb0, 0xe1, 0xe0, 0xc0, 0xc0, 0x33, 
-0x07, 0x90, 0xb0, 0x90, 0x58, 0xa4, 0x0c, 0x18, 0xe1, 0xe0, 0xb1, 0x00, 
-0x32, 0xc0, 0xa4, 0x0c, 0x28, 0xe1, 0xe0, 0xb0, 0xc0, 0x32, 0xc9, 0x90, 
-0x48, 0x80, 0xe1, 0xe0, 0xb0, 0x80, 0x32, 0xc7, 0xa4, 0x0c, 0x20, 0xe1, 
-0xe0, 0xb0, 0x40, 0x32, 0xc5, 0x92, 0x70, 0x91, 0x20, 0x90, 0x90, 0x90, 
-0x48, 0x80, 0xe1, 0xe0, 0x8d, 0x40, 0x32, 0x31, 0x80, 0xe1, 0xe0, 0x8d, 
-0x00, 0x32, 0x3a, 0x90, 0x48, 0x80, 0xe1, 0xe0, 0x8c, 0xc0, 0x32, 0x38, 
-0x80, 0xe1, 0xe0, 0x8c, 0x80, 0x32, 0x36, 0x90, 0xb0, 0x90, 0x58, 0xa4, 
-0x0b, 0x70, 0xe1, 0xe0, 0x9d, 0xc0, 0x32, 0x73, 0xa4, 0x0b, 0x80, 0xe1, 
-0xe0, 0x9d, 0x80, 0x32, 0x7c, 0x90, 0x48, 0x80, 0xe1, 0xe0, 0x9d, 0x40, 
-0x32, 0x7a, 0xa4, 0x0b, 0x78, 0xe1, 0xe0, 0x9d, 0x00, 0x32, 0x78, 0x91, 
-0x50, 0x90, 0xb0, 0x90, 0x58, 0xa4, 0x0c, 0x90, 0xe1, 0xe0, 0xbe, 0xc0, 
-0x32, 0xf7, 0xa4, 0x0c, 0xa0, 0xe1, 0xe0, 0xbe, 0x80, 0x33, 0x00, 0x90, 
-0x48, 0x80, 0xe1, 0xe0, 0xbe, 0x40, 0x32, 0xfe, 0xa4, 0x0c, 0x98, 0xe1, 
-0xe0, 0xbe, 0x00, 0x32, 0xfc, 0x90, 0xb0, 0x90, 0x58, 0xa4, 0x0c, 0x00, 
-0xe1, 0xe0, 0xae, 0x40, 0x32, 0xb5, 0xa4, 0x0c, 0x10, 0xe1, 0xe0, 0xae, 
-0x00, 0x32, 0xbe, 0x90, 0x48, 0x80, 0xe1, 0xe0, 0xad, 0xc0, 0x32, 0xbc, 
-0xa4, 0x0c, 0x08, 0xe1, 0xe0, 0xad, 0x80, 0x32, 0xba, 0x10, 0x10, 0x93, 
-0x60, 0x92, 0x40, 0x91, 0x20, 0x90, 0x90, 0x80, 0xd1, 0xc2, 0x40, 0xe1, 
-0xa0, 0x4b, 0xc0, 0x31, 0x36, 0xe1, 0xa0, 0x40, 0x40, 0x30, 0xfc, 0x80, 
-0xd1, 0xc2, 0x40, 0xe1, 0xa0, 0x4b, 0x80, 0x31, 0x34, 0xe1, 0xa0, 0x40, 
-0x00, 0x31, 0x06, 0x90, 0x90, 0x80, 0xd1, 0xc2, 0x40, 0xe1, 0xa0, 0x4b, 
-0x40, 0x31, 0x32, 0xe1, 0xa0, 0x3f, 0xc0, 0x31, 0x04, 0x80, 0xd1, 0xc2, 
-0x40, 0xe1, 0xa0, 0x4b, 0x00, 0x31, 0x30, 0xe1, 0xa0, 0x3f, 0x80, 0x31, 
-0x02, 0x90, 0x90, 0x90, 0x48, 0x80, 0xe3, 0xa0, 0x49, 0x40, 0x31, 0x20, 
-0x80, 0xe3, 0xa0, 0x49, 0x00, 0x31, 0x2a, 0x90, 0x48, 0x80, 0xe3, 0xa0, 
-0x48, 0xc0, 0x31, 0x28, 0x80, 0xe3, 0xa0, 0x48, 0x80, 0x31, 0x26, 0x91, 
-0x20, 0x90, 0x90, 0x90, 0x48, 0x80, 0xe3, 0xa0, 0x46, 0x40, 0x31, 0x08, 
-0x80, 0xe3, 0xa0, 0x46, 0x00, 0x31, 0x1e, 0x90, 0x48, 0x80, 0xe3, 0xa0, 
-0x45, 0xc0, 0x31, 0x1c, 0x80, 0xe3, 0xa0, 0x45, 0x80, 0x31, 0x1a, 0x90, 
-0x90, 0x90, 0x48, 0x80, 0xe3, 0xa0, 0x43, 0xc0, 0x31, 0x0a, 0x80, 0xe3, 
-0xa0, 0x43, 0x80, 0x31, 0x14, 0x90, 0x48, 0x80, 0xe3, 0xa0, 0x43, 0x40, 
-0x31, 0x12, 0x80, 0xe3, 0xa0, 0x43, 0x00, 0x31, 0x10, 0x94, 0x88, 0x80, 
-0x92, 0x40, 0x91, 0x20, 0x90, 0x90, 0x90, 0x48, 0x80, 0xe3, 0xa0, 0x6c, 
-0x80, 0x31, 0xb9, 0x80, 0xe3, 0xa0, 0x6c, 0x40, 0x31, 0xb7, 0x90, 0x48, 
-0x80, 0xe3, 0xa0, 0x6c, 0x00, 0x31, 0xb5, 0x80, 0xe3, 0xa0, 0x6b, 0xc0, 
-0x31, 0xb3, 0x90, 0x90, 0x90, 0x48, 0x80, 0xe3, 0xa0, 0x6f, 0x40, 0x31, 
-0xc4, 0x80, 0xe3, 0xa0, 0x6f, 0x00, 0x31, 0xc2, 0x90, 0x48, 0x80, 0xe3, 
-0xa0, 0x6e, 0xc0, 0x31, 0xc0, 0x80, 0xe3, 0xa0, 0x6e, 0x80, 0x31, 0xbe, 
-0x91, 0x20, 0x90, 0x90, 0x90, 0x48, 0x80, 0xe3, 0xa0, 0x74, 0xc0, 0x31, 
-0xda, 0x80, 0xe3, 0xa0, 0x74, 0x80, 0x31, 0xd8, 0x90, 0x48, 0x80, 0xe3, 
-0xa0, 0x74, 0x40, 0x31, 0xd6, 0x80, 0xe3, 0xa0, 0x74, 0x00, 0x31, 0xd4, 
-0x90, 0x90, 0x90, 0x48, 0x80, 0xe3, 0xa0, 0x72, 0x00, 0x31, 0xcf, 0x80, 
-0xe3, 0xa0, 0x71, 0xc0, 0x31, 0xcd, 0x90, 0x48, 0x80, 0xe3, 0xa0, 0x71, 
-0x80, 0x31, 0xcb, 0x80, 0xe3, 0xa0, 0x71, 0x40, 0x31, 0xc9, 0x80, 0x10, 
-0x10, 0x10, 0x10, 0x90, 0x90, 0x90, 0x48, 0x80, 0xe3, 0xa0, 0x6a, 0x00, 
-0x31, 0xa4, 0x80, 0xe3, 0xa0, 0x69, 0xc0, 0x31, 0xad, 0x90, 0x48, 0x80, 
-0xe3, 0xa0, 0x69, 0x80, 0x31, 0xab, 0x80, 0xe3, 0xa0, 0x69, 0x40, 0x31, 
-0xa9, 0xa0, 0x0b, 0x90, 0xa0, 0x0a, 0xc8, 0x95, 0x60, 0x92, 0xb0, 0x91, 
-0x40, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x31, 0xef, 0x80, 0x31, 
-0xee, 0x10, 0x10, 0x80, 0x31, 0xed, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x0a, 
-0x48, 0x32, 0x01, 0xa4, 0x0a, 0x40, 0x32, 0x00, 0x10, 0x10, 0xa4, 0x0a, 
-0x38, 0x31, 0xff, 0x90, 0xb8, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x0b, 0x68, 
-0x32, 0x25, 0xa4, 0x0b, 0x60, 0x32, 0x24, 0x10, 0x10, 0xa4, 0x0b, 0x58, 
-0x32, 0x23, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x0a, 0xd8, 0x32, 0x13, 0xa4, 
-0x0a, 0xd0, 0x32, 0x12, 0x10, 0x10, 0xa4, 0x0a, 0xc8, 0x32, 0x11, 0x91, 
-0x40, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x31, 0xea, 0x80, 0x31, 
-0xec, 0x10, 0x10, 0x80, 0x31, 0xeb, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x0a, 
-0x20, 0x31, 0xfc, 0xa4, 0x0a, 0x30, 0x31, 0xfe, 0x10, 0x10, 0xa4, 0x0a, 
-0x28, 0x31, 0xfd, 0x90, 0xb8, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x0b, 0x40, 
-0x32, 0x20, 0xa4, 0x0b, 0x50, 0x32, 0x22, 0x10, 0x10, 0xa4, 0x0b, 0x48, 
-0x32, 0x21, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x0a, 0xb0, 0x32, 0x0e, 0xa4, 
-0x0a, 0xc0, 0x32, 0x10, 0x10, 0x10, 0xa4, 0x0a, 0xb8, 0x32, 0x0f, 0x92, 
-0xb0, 0x91, 0x40, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x31, 0xe7, 
-0x80, 0x31, 0xe9, 0x10, 0x10, 0x80, 0x31, 0xe8, 0x90, 0x70, 0x90, 0x38, 
-0xa4, 0x0a, 0x08, 0x31, 0xf9, 0xa4, 0x0a, 0x18, 0x31, 0xfb, 0x10, 0x10, 
-0xa4, 0x0a, 0x10, 0x31, 0xfa, 0x90, 0xb8, 0x90, 0x70, 0x90, 0x38, 0xa4, 
-0x0b, 0x28, 0x32, 0x1d, 0xa4, 0x0b, 0x38, 0x32, 0x1f, 0x10, 0x10, 0xa4, 
-0x0b, 0x30, 0x32, 0x1e, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x0a, 0x98, 0x32, 
-0x0b, 0xa4, 0x0a, 0xa8, 0x32, 0x0d, 0x10, 0x10, 0xa4, 0x0a, 0xa0, 0x32, 
-0x0c, 0x91, 0x40, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x31, 0xe4, 
-0x80, 0x31, 0xe6, 0x10, 0x10, 0x80, 0x31, 0xe5, 0x90, 0x70, 0x90, 0x38, 
-0xa4, 0x09, 0xf0, 0x31, 0xf6, 0xa4, 0x0a, 0x00, 0x31, 0xf8, 0x10, 0x10, 
-0xa4, 0x09, 0xf8, 0x31, 0xf7, 0x90, 0xb8, 0x90, 0x70, 0x90, 0x38, 0xa4, 
-0x0b, 0x10, 0x32, 0x1a, 0xa4, 0x0b, 0x20, 0x32, 0x1c, 0x10, 0x10, 0xa4, 
-0x0b, 0x18, 0x32, 0x1b, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x0a, 0x80, 0x32, 
-0x08, 0xa4, 0x0a, 0x90, 0x32, 0x0a, 0x10, 0x10, 0xa4, 0x0a, 0x88, 0x32, 
-0x09, 0x10, 0x10, 0x80, 0x10, 0x10, 0x10, 0x10, 0x90, 0x50, 0x90, 0x28, 
-0x80, 0x31, 0xdb, 0x80, 0x31, 0xdd, 0x10, 0x10, 0x80, 0x31, 0xdc, 0x80, 
-0x95, 0x60, 0x92, 0xb0, 0x91, 0x40, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 
-0x80, 0x31, 0xe1, 0x80, 0x31, 0xe3, 0x10, 0x10, 0x80, 0x31, 0xe2, 0x90, 
-0x70, 0x90, 0x38, 0xa4, 0x09, 0xd8, 0x31, 0xf3, 0xa4, 0x09, 0xe8, 0x31, 
-0xf5, 0x10, 0x10, 0xa4, 0x09, 0xe0, 0x31, 0xf4, 0x90, 0xb8, 0x90, 0x70, 
-0x90, 0x38, 0xa4, 0x0a, 0xf8, 0x32, 0x17, 0xa4, 0x0b, 0x08, 0x32, 0x19, 
-0x10, 0x10, 0xa4, 0x0b, 0x00, 0x32, 0x18, 0x90, 0x70, 0x90, 0x38, 0xa4, 
-0x0a, 0x68, 0x32, 0x05, 0xa4, 0x0a, 0x78, 0x32, 0x07, 0x10, 0x10, 0xa4, 
-0x0a, 0x70, 0x32, 0x06, 0x91, 0x40, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 
-0x80, 0x31, 0xde, 0x80, 0x31, 0xe0, 0x10, 0x10, 0x80, 0x31, 0xdf, 0x90, 
-0x70, 0x90, 0x38, 0xa4, 0x09, 0xc0, 0x31, 0xf0, 0xa4, 0x09, 0xd0, 0x31, 
-0xf2, 0x10, 0x10, 0xa4, 0x09, 0xc8, 0x31, 0xf1, 0x90, 0xb8, 0x90, 0x70, 
-0x90, 0x38, 0xa4, 0x0a, 0xe0, 0x32, 0x14, 0xa4, 0x0a, 0xf0, 0x32, 0x16, 
-0x10, 0x10, 0xa4, 0x0a, 0xe8, 0x32, 0x15, 0x90, 0x70, 0x90, 0x38, 0xa4, 
-0x0a, 0x50, 0x32, 0x02, 0xa4, 0x0a, 0x60, 0x32, 0x04, 0x10, 0x10, 0xa4, 
-0x0a, 0x58, 0x32, 0x03, 0x10, 0x10, 0x92, 0x40, 0x91, 0x20, 0x90, 0x90, 
-0x90, 0x48, 0x80, 0xe3, 0xa0, 0x3c, 0xc0, 0x30, 0xfa, 0x80, 0xe3, 0xa0, 
-0x3c, 0x80, 0x30, 0xf8, 0x90, 0x48, 0x80, 0xe3, 0xa0, 0x3c, 0x40, 0x30, 
-0xf6, 0x80, 0xe3, 0xa0, 0x3c, 0x00, 0x30, 0xf4, 0x90, 0x90, 0x90, 0x48, 
-0x80, 0xe3, 0xa0, 0x3a, 0x40, 0x30, 0xe4, 0x80, 0xe3, 0xa0, 0x3a, 0x00, 
-0x30, 0xee, 0x90, 0x48, 0x80, 0xe3, 0xa0, 0x39, 0xc0, 0x30, 0xec, 0x80, 
-0xe3, 0xa0, 0x39, 0x80, 0x30, 0xea, 0x91, 0x20, 0x90, 0x90, 0x90, 0x48, 
-0x80, 0xe3, 0xa0, 0x37, 0x40, 0x30, 0xcc, 0x80, 0xe3, 0xa0, 0x37, 0x00, 
-0x30, 0xe2, 0x90, 0x48, 0x80, 0xe3, 0xa0, 0x36, 0xc0, 0x30, 0xe0, 0x80, 
-0xe3, 0xa0, 0x36, 0x80, 0x30, 0xde, 0x90, 0x90, 0x90, 0x48, 0x80, 0xe3, 
-0xa0, 0x34, 0xc0, 0x30, 0xce, 0x80, 0xe3, 0xa0, 0x34, 0x80, 0x30, 0xd8, 
-0x90, 0x48, 0x80, 0xe3, 0xa0, 0x34, 0x40, 0x30, 0xd6, 0x80, 0xe3, 0xa0, 
-0x34, 0x00, 0x30, 0xd4, 0xc3, 0xc0, 0x30, 0x42, 0x9d, 0x18, 0x07, 0xf0, 
-0x91, 0xc0, 0x90, 0xf0, 0x10, 0x10, 0x80, 0x88, 0x00, 0x80, 0x90, 0x50, 
-0x90, 0x28, 0x80, 0x37, 0x1c, 0x80, 0x37, 0x1d, 0x81, 0x37, 0x13, 0xd0, 
-0x41, 0x80, 0x24, 0x39, 0xb0, 0x24, 0x39, 0xb8, 0x10, 0x10, 0x80, 0x90, 
-0x58, 0x80, 0x90, 0x28, 0x24, 0x38, 0xb0, 0x24, 0x38, 0xb8, 0x90, 0x30, 
-0x80, 0x24, 0x38, 0x60, 0x80, 0x24, 0x38, 0x58, 0x92, 0x68, 0x91, 0x00, 
-0x80, 0x90, 0x90, 0x90, 0x30, 0x80, 0x24, 0x39, 0x20, 0x90, 0x38, 0xa4, 
-0x39, 0x18, 0x37, 0x2a, 0x80, 0x37, 0x29, 0x80, 0x90, 0x28, 0x80, 0x37, 
-0x33, 0xa4, 0x39, 0x00, 0x37, 0x32, 0x80, 0x90, 0xc0, 0x90, 0x60, 0x90, 
-0x28, 0x80, 0x37, 0x2d, 0xa4, 0x39, 0x10, 0x37, 0x2c, 0x90, 0x28, 0x80, 
-0x37, 0x28, 0xa4, 0x39, 0x08, 0x37, 0x27, 0x90, 0x50, 0x90, 0x28, 0x80, 
-0x37, 0x31, 0x80, 0x37, 0x30, 0x90, 0x28, 0x24, 0x39, 0xa8, 0x24, 0x39, 
-0xa0, 0x90, 0x58, 0x80, 0x10, 0x10, 0x80, 0x10, 0x10, 0x80, 0x37, 0x1f, 
-0x80, 0x90, 0x40, 0x10, 0x10, 0x80, 0x24, 0x38, 0x70, 0x80, 0x10, 0x10, 
-0x80, 0x37, 0x1e, 0x91, 0xb8, 0x91, 0x60, 0x90, 0xe0, 0x80, 0x90, 0x78, 
-0x90, 0x50, 0x90, 0x28, 0x80, 0x37, 0x1a, 0x80, 0x37, 0x1b, 0x81, 0x37, 
-0x12, 0x10, 0x10, 0x90, 0x28, 0x24, 0x38, 0x80, 0x24, 0x38, 0x78, 0x81, 
-0x90, 0x50, 0x90, 0x28, 0x80, 0x37, 0x18, 0x80, 0x37, 0x19, 0x81, 0x37, 
-0x11, 0x83, 0x90, 0x28, 0x24, 0x38, 0xa0, 0x24, 0x38, 0xa8, 0x90, 0xe8, 
-0x81, 0x90, 0x88, 0x90, 0x38, 0x10, 0x10, 0x80, 0x37, 0x2b, 0x90, 0x28, 
-0x80, 0x37, 0x26, 0x80, 0x37, 0x25, 0x80, 0x90, 0x28, 0x80, 0x37, 0x2f, 
-0x80, 0x37, 0x2e, 0x82, 0x10, 0x10, 0x80, 0x24, 0x38, 0x68, 0x97, 0x10, 
-0x9e, 0x10, 0x06, 0x98, 0x93, 0x00, 0x91, 0x80, 0x90, 0xc0, 0x90, 0x60, 
-0x90, 0x38, 0xa4, 0x04, 0x80, 0x30, 0x91, 0x24, 0x04, 0x78, 0x90, 0x38, 
-0xa4, 0x05, 0x10, 0x30, 0xa3, 0x24, 0x05, 0x08, 0x90, 0x60, 0x90, 0x38, 
-0xa4, 0x06, 0x30, 0x30, 0xc7, 0x24, 0x06, 0x28, 0x90, 0x38, 0xa4, 0x05, 
-0xa0, 0x30, 0xb5, 0x24, 0x05, 0x98, 0x90, 0xc0, 0x90, 0x60, 0x90, 0x38, 
-0xa4, 0x04, 0x70, 0x30, 0x8c, 0x24, 0x04, 0x68, 0x90, 0x38, 0xa4, 0x05, 
-0x00, 0x30, 0x9e, 0x24, 0x04, 0xf8, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x06, 
-0x20, 0x30, 0xc2, 0x24, 0x06, 0x18, 0x90, 0x38, 0xa4, 0x05, 0x90, 0x30, 
-0xb0, 0x24, 0x05, 0x88, 0x91, 0x80, 0x90, 0xc0, 0x90, 0x60, 0x90, 0x38, 
-0xa4, 0x04, 0x58, 0x30, 0x89, 0x24, 0x04, 0x50, 0x90, 0x38, 0xa4, 0x04, 
-0xe8, 0x30, 0x9b, 0x24, 0x04, 0xe0, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x06, 
-0x08, 0x30, 0xbf, 0x24, 0x06, 0x00, 0x90, 0x38, 0xa4, 0x05, 0x78, 0x30, 
-0xad, 0x24, 0x05, 0x70, 0x90, 0xc0, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x04, 
-0x40, 0x30, 0x86, 0x24, 0x04, 0x38, 0x90, 0x38, 0xa4, 0x04, 0xd0, 0x30, 
-0x98, 0x24, 0x04, 0xc8, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x05, 0xf0, 0x30, 
-0xbc, 0x24, 0x05, 0xe8, 0x90, 0x38, 0xa4, 0x05, 0x60, 0x30, 0xaa, 0x24, 
-0x05, 0x58, 0x10, 0x10, 0x80, 0x10, 0x10, 0x10, 0x10, 0x90, 0x38, 0xa4, 
-0x03, 0xf8, 0x30, 0x7d, 0x24, 0x03, 0xf0, 0xd7, 0x42, 0x00, 0xa4, 0x52, 
-0x70, 0x3a, 0x50, 0xa4, 0x52, 0x50, 0x3a, 0x4c, 0x9f, 0x20, 0x08, 0xd0, 
-0x93, 0x00, 0x91, 0x80, 0x90, 0xc0, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x04, 
-0x28, 0x30, 0x83, 0x24, 0x04, 0x20, 0x90, 0x38, 0xa4, 0x04, 0xb8, 0x30, 
-0x95, 0x24, 0x04, 0xb0, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x05, 0xd8, 0x30, 
-0xb9, 0x24, 0x05, 0xd0, 0x90, 0x38, 0xa4, 0x05, 0x48, 0x30, 0xa7, 0x24, 
-0x05, 0x40, 0x90, 0xc0, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x04, 0x10, 0x30, 
-0x80, 0x24, 0x04, 0x08, 0x90, 0x38, 0xa4, 0x04, 0xa0, 0x30, 0x92, 0x24, 
-0x04, 0x98, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x05, 0xc0, 0x30, 0xb6, 0x24, 
-0x05, 0xb8, 0x90, 0x38, 0xa4, 0x05, 0x30, 0x30, 0xa4, 0x24, 0x05, 0x28, 
-0x10, 0x10, 0x92, 0x00, 0x91, 0x00, 0x90, 0x80, 0x90, 0x40, 0xe3, 0xe0, 
-0x1a, 0x80, 0x30, 0x71, 0xe3, 0xe0, 0x1a, 0x40, 0x30, 0x6f, 0x90, 0x40, 
-0xe3, 0xe0, 0x1a, 0x00, 0x30, 0x6d, 0xe3, 0xe0, 0x19, 0xc0, 0x30, 0x6b, 
-0x90, 0x80, 0x90, 0x40, 0xe3, 0xe0, 0x18, 0x00, 0x30, 0x5b, 0xe3, 0xe0, 
-0x17, 0xc0, 0x30, 0x65, 0x90, 0x40, 0xe3, 0xe0, 0x17, 0x80, 0x30, 0x63, 
-0xe3, 0xe0, 0x17, 0x40, 0x30, 0x61, 0x91, 0x00, 0x90, 0x80, 0x90, 0x40, 
-0xe3, 0xe0, 0x15, 0x00, 0x30, 0x43, 0xe3, 0xe0, 0x14, 0xc0, 0x30, 0x59, 
-0x90, 0x40, 0xe3, 0xe0, 0x14, 0x80, 0x30, 0x57, 0xe3, 0xe0, 0x14, 0x40, 
-0x30, 0x55, 0x90, 0x80, 0x90, 0x40, 0xe3, 0xe0, 0x12, 0x80, 0x30, 0x45, 
-0xe3, 0xe0, 0x12, 0x40, 0x30, 0x4f, 0x90, 0x40, 0xe3, 0xe0, 0x12, 0x00, 
-0x30, 0x4d, 0xe3, 0xe0, 0x11, 0xc0, 0x30, 0x4b, 0x91, 0x48, 0x80, 0x90, 
-0xa0, 0x90, 0x50, 0x90, 0x28, 0x80, 0x30, 0x76, 0x24, 0x03, 0xa8, 0x90, 
-0x28, 0x80, 0x30, 0x78, 0x24, 0x03, 0xb8, 0x90, 0x50, 0x90, 0x28, 0x80, 
-0x30, 0x7c, 0x24, 0x03, 0xd8, 0x90, 0x28, 0x80, 0x30, 0x7a, 0x24, 0x03, 
-0xc8, 0x80, 0x10, 0x10, 0x10, 0x10, 0x90, 0x28, 0x80, 0x30, 0x73, 0x24, 
-0x03, 0xa0, 0xd7, 0x42, 0x00, 0xa4, 0x52, 0x78, 0x3a, 0x51, 0xa4, 0x52, 
-0x58, 0x3a, 0x4d, 0xa0, 0x14, 0x68, 0xa0, 0x10, 0x90, 0xa0, 0x0c, 0x60, 
-0x9e, 0x88, 0x09, 0xd0, 0x94, 0xf0, 0x90, 0xb0, 0x88, 0x00, 0x68, 0x84, 
-0x10, 0x10, 0xc9, 0xe2, 0x15, 0x00, 0x85, 0x38, 0x70, 0xcb, 0x62, 0x0d, 
-0xc0, 0x85, 0x38, 0x46, 0x9a, 0x00, 0x03, 0xf8, 0x91, 0x98, 0x80, 0x91, 
-0x10, 0x90, 0xa0, 0x90, 0x68, 0x90, 0x20, 0x3d, 0x98, 0xc9, 0xe3, 0x65, 
-0x80, 0x85, 0x38, 0x6e, 0xa4, 0x6c, 0xa0, 0x3d, 0x95, 0x90, 0x38, 0xa4, 
-0x6c, 0x68, 0x3d, 0x8e, 0xa4, 0x6c, 0x58, 0x3d, 0x8c, 0x90, 0x48, 0x10, 
-0x10, 0xa4, 0x6c, 0x20, 0x3d, 0x85, 0x10, 0x10, 0x80, 0x3d, 0x81, 0x81, 
-0x10, 0x10, 0x80, 0xa4, 0x6b, 0xf0, 0x3d, 0x7f, 0x91, 0xb0, 0x91, 0x60, 
-0x90, 0xe0, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x6c, 0x90, 0x3d, 0x93, 0xa4, 
-0x6c, 0x80, 0x3d, 0x91, 0x90, 0x38, 0xa4, 0x6c, 0x48, 0x3d, 0x8a, 0xa4, 
-0x6c, 0x38, 0x3d, 0x88, 0x90, 0x48, 0x10, 0x10, 0xa4, 0x6c, 0x10, 0x3d, 
-0x83, 0x10, 0x10, 0x80, 0x3d, 0x80, 0x90, 0x28, 0x80, 0x3d, 0x79, 0x80, 
-0x3d, 0x78, 0x81, 0x10, 0x10, 0x80, 0xa4, 0x6b, 0xe0, 0x3d, 0x7d, 0xcb, 
-0x62, 0x0d, 0x80, 0x85, 0x38, 0x45, 0x90, 0xd8, 0x88, 0x00, 0x90, 0x84, 
-0x90, 0x38, 0xc1, 0xc0, 0x85, 0x3d, 0x9b, 0xc9, 0xe2, 0x14, 0xc0, 0x85, 
-0x38, 0x6c, 0xcb, 0x62, 0x0d, 0x40, 0x85, 0x38, 0x44, 0x88, 0x00, 0x68, 
-0x84, 0x10, 0x10, 0xc9, 0xe2, 0x14, 0x80, 0x85, 0x38, 0x6a, 0xcb, 0x62, 
-0x0d, 0x00, 0x85, 0x38, 0x43, 0x91, 0xf8, 0x90, 0xb0, 0x88, 0x00, 0x68, 
-0x84, 0x10, 0x10, 0xc9, 0xe2, 0x14, 0x00, 0x85, 0x38, 0x66, 0xcb, 0x62, 
-0x0c, 0x80, 0x85, 0x38, 0x41, 0x88, 0x01, 0x00, 0x90, 0xa0, 0x81, 0x90, 
-0x70, 0x80, 0x90, 0x20, 0x3d, 0x8f, 0xc9, 0xe2, 0x13, 0xc0, 0x85, 0x38, 
-0x64, 0x81, 0x3d, 0x86, 0x81, 0x10, 0x10, 0x80, 0xa4, 0x6b, 0xd0, 0x3d, 
-0x7b, 0xcb, 0x62, 0x0c, 0x40, 0x85, 0x38, 0x40, 0x90, 0xb0, 0x88, 0x00, 
-0x68, 0x84, 0x10, 0x10, 0xc9, 0xe2, 0x13, 0x80, 0x85, 0x38, 0x62, 0xcb, 
-0x62, 0x0c, 0x00, 0x85, 0x38, 0x3f, 0x88, 0x00, 0x68, 0x84, 0x10, 0x10, 
-0xc9, 0xe2, 0x13, 0x40, 0x85, 0x38, 0x60, 0xcb, 0x62, 0x0b, 0xc0, 0x85, 
-0x38, 0x3e, 0x92, 0x38, 0x81, 0x91, 0x68, 0x91, 0x18, 0x90, 0x80, 0x90, 
-0x40, 0x80, 0xa4, 0x6d, 0x50, 0x3d, 0xab, 0x80, 0xa4, 0x6d, 0x48, 0x3d, 
-0xa8, 0x90, 0x28, 0x81, 0x3d, 0xa7, 0x90, 0x38, 0xa4, 0x6d, 0x28, 0x3d, 
-0xa6, 0xa4, 0x6d, 0x18, 0x3d, 0xa4, 0x90, 0x28, 0x80, 0x3d, 0xa2, 0x80, 
-0x3d, 0xa1, 0x80, 0x90, 0x40, 0x10, 0x10, 0x80, 0x24, 0x6d, 0x00, 0x10, 
-0x10, 0x90, 0x38, 0xa4, 0x6c, 0xf0, 0x3d, 0x9f, 0xa4, 0x6c, 0xe0, 0x3d, 
-0x9d, 0x90, 0x28, 0x80, 0x3d, 0x9a, 0x80, 0x3d, 0x99, 0x9a, 0xd0, 0x03, 
-0xe0, 0x91, 0x60, 0x90, 0xb0, 0x88, 0x00, 0x68, 0x84, 0x10, 0x10, 0xc9, 
-0xe2, 0x12, 0xc0, 0x85, 0x38, 0x5c, 0xcb, 0x62, 0x0b, 0x40, 0x85, 0x38, 
-0x3c, 0x88, 0x00, 0x68, 0x84, 0x10, 0x10, 0xc9, 0xe2, 0x12, 0x80, 0x85, 
-0x38, 0x5a, 0xcb, 0x62, 0x0b, 0x00, 0x85, 0x38, 0x3b, 0x90, 0xb0, 0x88, 
-0x00, 0x68, 0x84, 0x10, 0x10, 0xc9, 0xe2, 0x12, 0x40, 0x85, 0x38, 0x58, 
-0xcb, 0x62, 0x0a, 0xc0, 0x85, 0x38, 0x3a, 0x88, 0x00, 0x68, 0x84, 0x10, 
-0x10, 0xc9, 0xe2, 0x12, 0x00, 0x85, 0x38, 0x56, 0xcb, 0x62, 0x0a, 0x80, 
-0x85, 0x38, 0x39, 0x90, 0x90, 0x90, 0x48, 0xcb, 0xa2, 0x08, 0xc0, 0x85, 
-0x38, 0x28, 0xcb, 0xa2, 0x08, 0x80, 0x85, 0x38, 0x27, 0x90, 0x48, 0xcb, 
-0xa2, 0x08, 0x40, 0x85, 0x38, 0x26, 0xcb, 0xa2, 0x08, 0x00, 0x85, 0x38, 
-0x25, 0xcb, 0xa3, 0x5d, 0x80, 0x80, 0x3d, 0x77, 0x92, 0x40, 0x91, 0x20, 
-0x90, 0x90, 0x90, 0x48, 0x8c, 0x40, 0x78, 0x84, 0x24, 0x40, 0xf0, 0x8c, 
-0x40, 0x70, 0x84, 0x24, 0x40, 0xe8, 0x90, 0x48, 0x8c, 0x40, 0x68, 0x84, 
-0x24, 0x40, 0xe0, 0x8c, 0x40, 0x60, 0x84, 0x24, 0x40, 0xd8, 0x90, 0x90, 
-0x90, 0x48, 0x8c, 0x40, 0x50, 0x84, 0x24, 0x40, 0xc8, 0x8c, 0x40, 0x48, 
-0x84, 0x24, 0x40, 0xc0, 0x90, 0x48, 0x8c, 0x40, 0x40, 0x84, 0x24, 0x40, 
-0xb8, 0x8c, 0x40, 0x38, 0x84, 0x24, 0x40, 0xb0, 0x91, 0x20, 0x90, 0x90, 
-0x90, 0x48, 0x8c, 0x40, 0x28, 0x84, 0x24, 0x40, 0xa0, 0x8c, 0x40, 0x20, 
-0x84, 0x24, 0x40, 0x98, 0x90, 0x48, 0x8c, 0x40, 0x18, 0x84, 0x24, 0x40, 
-0x90, 0x8c, 0x40, 0x10, 0x84, 0x24, 0x40, 0x88, 0x90, 0x38, 0xa4, 0x3f, 
-0xf8, 0x38, 0x00, 0xa4, 0x3f, 0xe8, 0x37, 0xfe, 0xa0, 0x0f, 0x50, 0xa0, 
-0x09, 0x08, 0x9a, 0x30, 0x04, 0x40, 0x91, 0x90, 0x90, 0xc8, 0x98, 0x50, 
-0x00, 0x80, 0xe5, 0x23, 0x5b, 0x80, 0x3d, 0x66, 0xe5, 0x23, 0x53, 0x80, 
-0x3d, 0x62, 0xcb, 0x61, 0xfb, 0x00, 0x85, 0x37, 0xfb, 0x98, 0x50, 0x00, 
-0x80, 0xe5, 0x23, 0x4b, 0x80, 0x3d, 0x26, 0xe5, 0x23, 0x43, 0x80, 0x3d, 
-0x22, 0xcb, 0x61, 0xfa, 0xc0, 0x85, 0x37, 0xfa, 0x90, 0x48, 0xcb, 0xa1, 
-0xfa, 0x80, 0x85, 0x37, 0xf9, 0xcb, 0xa1, 0xfa, 0x40, 0x85, 0x37, 0xf8, 
-0x91, 0x90, 0x90, 0xc8, 0x98, 0x50, 0x00, 0x80, 0xe5, 0x23, 0x35, 0x80, 
-0x3c, 0xee, 0xe5, 0x23, 0x29, 0x80, 0x3c, 0xbe, 0xcb, 0x61, 0xf9, 0xc0, 
-0x85, 0x37, 0xf6, 0x98, 0x50, 0x00, 0x80, 0xe5, 0x23, 0x1d, 0x80, 0x3c, 
-0x8e, 0xe5, 0x23, 0x11, 0x80, 0x3c, 0x5e, 0xcb, 0x61, 0xf9, 0x80, 0x85, 
-0x37, 0xf5, 0x90, 0x48, 0xcb, 0xa1, 0xf9, 0x40, 0x85, 0x37, 0xf4, 0xcb, 
-0xa1, 0xf9, 0x00, 0x85, 0x37, 0xf3, 0x92, 0x20, 0x91, 0x30, 0x90, 0xb8, 
-0xd5, 0x03, 0x00, 0xc0, 0xc0, 0x81, 0x8c, 0x01, 0xa0, 0x84, 0x30, 0x3e, 
-0xc0, 0xc0, 0x81, 0x8c, 0x01, 0x80, 0x84, 0x30, 0x3c, 0xd5, 0x02, 0x00, 
-0xc0, 0xc0, 0x81, 0x30, 0x28, 0xc0, 0xc0, 0x81, 0x30, 0x24, 0x90, 0x78, 
-0xd5, 0x02, 0x00, 0xc0, 0xc0, 0x81, 0x30, 0x1c, 0xc0, 0xc0, 0x81, 0x30, 
-0x18, 0xd5, 0x02, 0x00, 0xc0, 0xc0, 0x81, 0x30, 0x10, 0xc0, 0xc0, 0x81, 
-0x30, 0x0c, 0x91, 0x70, 0x90, 0xd8, 0xd5, 0x03, 0x80, 0xc8, 0xe3, 0x09, 
-0x80, 0x81, 0x8c, 0x01, 0xc0, 0x84, 0x30, 0x40, 0xc8, 0xe3, 0x0b, 0x80, 
-0x81, 0x8c, 0x01, 0x90, 0x84, 0x30, 0x3d, 0xd5, 0x02, 0x80, 0xc8, 0xe3, 
-0x08, 0x80, 0x81, 0x30, 0x2c, 0xc8, 0xe3, 0x03, 0x00, 0x81, 0x30, 0x26, 
-0x90, 0x98, 0xd5, 0x02, 0x80, 0xc8, 0xe2, 0xf8, 0x00, 0x81, 0x30, 0x20, 
-0xc8, 0xe2, 0xfa, 0x00, 0x81, 0x30, 0x1a, 0xd5, 0x02, 0x80, 0xc8, 0xe2, 
-0xf7, 0x00, 0x81, 0x30, 0x14, 0xc8, 0xe2, 0xf1, 0x80, 0x81, 0x30, 0x0e, 
-0x9a, 0x30, 0x04, 0x40, 0x91, 0x90, 0x90, 0xc8, 0x98, 0x50, 0x00, 0x80, 
-0xe5, 0x23, 0x4f, 0x80, 0x3d, 0x36, 0xe5, 0x23, 0x51, 0x80, 0x3d, 0x5a, 
-0xcb, 0x61, 0xf8, 0x80, 0x85, 0x37, 0xf1, 0x98, 0x50, 0x00, 0x80, 0xe5, 
-0x23, 0x3f, 0x80, 0x3c, 0xf6, 0xe5, 0x23, 0x41, 0x80, 0x3d, 0x1a, 0xcb, 
-0x61, 0xf8, 0x40, 0x85, 0x37, 0xf0, 0x90, 0x48, 0xcb, 0xa1, 0xf8, 0x00, 
-0x85, 0x37, 0xef, 0xcb, 0xa1, 0xf7, 0xc0, 0x85, 0x37, 0xee, 0x91, 0x90, 
-0x90, 0xc8, 0x98, 0x50, 0x00, 0x80, 0xe5, 0x23, 0x31, 0x80, 0x3c, 0xde, 
-0xe5, 0x23, 0x25, 0x80, 0x3c, 0xae, 0xcb, 0x61, 0xf6, 0x00, 0x85, 0x37, 
-0xdd, 0x98, 0x50, 0x00, 0x80, 0xe5, 0x23, 0x19, 0x80, 0x3c, 0x7e, 0xe5, 
-0x23, 0x0d, 0x80, 0x3c, 0x4e, 0xcb, 0x61, 0xf5, 0xc0, 0x85, 0x37, 0xdc, 
-0x90, 0x48, 0xcb, 0xa1, 0xf5, 0x80, 0x85, 0x37, 0xdb, 0xcb, 0xa1, 0xf5, 
-0x40, 0x85, 0x37, 0xda, 0x91, 0x00, 0x90, 0x80, 0x90, 0x40, 0xe5, 0x20, 
-0x02, 0x40, 0x30, 0x0a, 0xe5, 0x20, 0x01, 0x80, 0x30, 0x07, 0x90, 0x40, 
-0xe5, 0x20, 0x00, 0xc0, 0x30, 0x04, 0xe5, 0x20, 0x00, 0x00, 0x30, 0x01, 
-0x90, 0x80, 0x90, 0x40, 0xe5, 0x22, 0xfe, 0x80, 0x3b, 0xf0, 0xe5, 0x23, 
-0x00, 0xc0, 0x3c, 0x18, 0x90, 0x40, 0xe5, 0x22, 0xed, 0x00, 0x3b, 0xaa, 
-0xe5, 0x22, 0xef, 0x40, 0x3b, 0xd2, 0x80, 0x99, 0x28, 0x02, 0xf0, 0x8c, 
-0x3e, 0x60, 0x90, 0x80, 0x90, 0x40, 0xe5, 0x23, 0x55, 0x80, 0x3d, 0x52, 
-0xe5, 0x23, 0x52, 0x80, 0x3d, 0x5e, 0x90, 0x40, 0xe5, 0x23, 0x45, 0x80, 
-0x3d, 0x12, 0xe5, 0x23, 0x42, 0x80, 0x3d, 0x1e, 0x91, 0x48, 0x90, 0xc8, 
-0x98, 0x50, 0x00, 0x80, 0xe5, 0x23, 0x33, 0x80, 0x3c, 0xe6, 0xe5, 0x23, 
-0x27, 0x80, 0x3c, 0xb6, 0xcb, 0x61, 0xf3, 0xc0, 0x85, 0x37, 0xd3, 0x90, 
-0x40, 0xe5, 0x23, 0x1b, 0x80, 0x3c, 0x86, 0xe5, 0x23, 0x0f, 0x80, 0x3c, 
-0x56, 0x90, 0x48, 0xcb, 0xa1, 0xf3, 0x40, 0x85, 0x37, 0xd1, 0xcb, 0xa1, 
-0xf3, 0x80, 0x85, 0x37, 0xd2, 0x10, 0x10, 0x90, 0x80, 0x90, 0x40, 0xe5, 
-0x23, 0x05, 0x00, 0x3c, 0x10, 0xe5, 0x23, 0x02, 0x00, 0x3c, 0x1e, 0x90, 
-0x40, 0xe5, 0x22, 0xf3, 0x80, 0x3b, 0xca, 0xe5, 0x22, 0xf0, 0x80, 0x3b, 
-0xd8, 
+0xa1, 0x02, 0x78, 0xa0, 0x2f, 0x28, 0xa0, 0x2d, 0x10, 0xa0, 0x1c, 0x40,
+0x98, 0xb0, 0x02, 0x50, 0x90, 0x50, 0x90, 0x28, 0x24, 0x52, 0x40, 0x24,
+0x52, 0x38, 0x90, 0x28, 0x24, 0x52, 0x30, 0x24, 0x52, 0x28, 0x91, 0x60,
+0x90, 0x28, 0x24, 0x52, 0x18, 0x10, 0x10, 0x58, 0x41, 0x62, 0x90, 0x80,
+0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
+0x10, 0x10, 0x52, 0xc0, 0xc0, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
+0x10, 0x10, 0x10, 0x24, 0x3d, 0x90, 0x90, 0x28, 0x24, 0x52, 0x08, 0x24,
+0x52, 0x00, 0xa8, 0x0b, 0x88, 0x15, 0x60, 0x97, 0x60, 0x96, 0x08, 0x9a,
+0xf8, 0x05, 0x78, 0x91, 0x58, 0x90, 0xe0, 0x90, 0xa0, 0x80, 0x90, 0x20,
+0x37, 0xc9, 0x90, 0x20, 0x37, 0xc6, 0xcb, 0xa1, 0xf1, 0x00, 0xa4, 0x37,
+0xf8, 0x37, 0x00, 0x80, 0xa4, 0x4f, 0xb8, 0x39, 0xfc, 0x90, 0x50, 0x90,
+0x28, 0x80, 0x39, 0xf2, 0x80, 0x37, 0xaa, 0x81, 0x37, 0x03, 0x90, 0xe0,
+0x90, 0x70, 0x90, 0x38, 0xa4, 0x3d, 0x30, 0x37, 0xa7, 0xa4, 0x38, 0x10,
+0x37, 0xa4, 0x90, 0x38, 0xa4, 0x51, 0xb8, 0x3a, 0x3d, 0xa4, 0x51, 0x60,
+0x3a, 0x31, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x50, 0x38, 0x3a, 0x12, 0xa4,
+0x50, 0x10, 0x3a, 0x0d, 0x80, 0xa4, 0x3d, 0x10, 0x37, 0xa3, 0x92, 0x18,
+0x91, 0xc0, 0x80, 0x91, 0x80, 0x90, 0xf8, 0xdb, 0x84, 0x61, 0xc1, 0x80,
+0xc0, 0xc0, 0x80, 0xa4, 0x5b, 0x80, 0x8c, 0x5c, 0xe0, 0x84, 0x3b, 0xa6,
+0xc0, 0xc0, 0x80, 0xa4, 0x5b, 0x70, 0x8c, 0x5c, 0xc0, 0x84, 0x3b, 0xa4,
+0xd3, 0x82, 0x40, 0x50, 0xc0, 0xc0, 0x81, 0x3b, 0x58, 0x50, 0xc0, 0xc0,
+0x81, 0x3b, 0x56, 0xa4, 0x38, 0x20, 0x37, 0x05, 0x80, 0x90, 0x28, 0x80,
+0x37, 0x01, 0x80, 0x37, 0xac, 0x81, 0x90, 0x38, 0xa4, 0x3d, 0xa0, 0x37,
+0xaf, 0xa4, 0x3d, 0x68, 0x37, 0xa9, 0xc0, 0x40, 0x10, 0x10, 0x90, 0x38,
+0xa4, 0x37, 0xe8, 0x36, 0xfe, 0xa4, 0x37, 0xd8, 0x36, 0xfc, 0x18, 0x24,
+0x3e, 0x18, 0x83, 0x90, 0xa8, 0xd3, 0x82, 0xc0, 0xc0, 0xc0, 0x80, 0xa4,
+0x5b, 0x50, 0x3b, 0x90, 0xc0, 0xc0, 0x80, 0xa4, 0x5b, 0x40, 0x3b, 0x8c,
+0xd3, 0x82, 0x40, 0x50, 0xc0, 0xc0, 0x81, 0x3b, 0x52, 0x50, 0xc0, 0xc0,
+0x81, 0x3b, 0x50, 0x92, 0xb8, 0x99, 0x84, 0x3d, 0x88, 0x90, 0x78, 0x90,
+0x50, 0x10, 0x10, 0x80, 0xa4, 0x4f, 0xb0, 0x39, 0xfb, 0x82, 0x39, 0xf1,
+0x90, 0x80, 0x10, 0x10, 0x90, 0x38, 0xa4, 0x51, 0xb0, 0x3a, 0x3c, 0xa4,
+0x51, 0x58, 0x3a, 0x30, 0x80, 0x90, 0x38, 0xa4, 0x50, 0x30, 0x3a, 0x11,
+0xa4, 0x50, 0x08, 0x3a, 0x0c, 0x83, 0x90, 0xa8, 0xd3, 0x82, 0xc0, 0xc0,
+0xc0, 0x80, 0xa4, 0x5b, 0x20, 0x3b, 0x84, 0xc0, 0xc0, 0x80, 0xa4, 0x5b,
+0x10, 0x3b, 0x80, 0xd3, 0x82, 0x40, 0x50, 0xc0, 0xc0, 0x81, 0x3b, 0x4c,
+0x50, 0xc0, 0xc0, 0x81, 0x3b, 0x4a, 0x18, 0x24, 0x3d, 0x98, 0x83, 0x90,
+0xa8, 0xd3, 0x82, 0xc0, 0xc0, 0xc0, 0x80, 0xa4, 0x5a, 0xf0, 0x3b, 0x78,
+0xc0, 0xc0, 0x80, 0xa4, 0x5a, 0xe0, 0x3b, 0x74, 0xd3, 0x82, 0x40, 0x50,
+0xc0, 0xc0, 0x81, 0x3b, 0x46, 0x50, 0xc0, 0xc0, 0x81, 0x3b, 0x44, 0x94,
+0x50, 0x92, 0xf8, 0x99, 0x84, 0x38, 0x50, 0x90, 0x78, 0x90, 0x50, 0x10,
+0x10, 0x80, 0xa4, 0x4f, 0xa8, 0x39, 0xfa, 0x82, 0x39, 0xf0, 0x90, 0x80,
+0x10, 0x10, 0x90, 0x38, 0xa4, 0x51, 0xa8, 0x3a, 0x3b, 0xa4, 0x51, 0x50,
+0x3a, 0x2f, 0x80, 0x90, 0x38, 0xa4, 0x50, 0x28, 0x3a, 0x10, 0xa4, 0x50,
+0x00, 0x3a, 0x0b, 0x83, 0x90, 0xe8, 0xd3, 0x83, 0xc0, 0xc0, 0xc0, 0x80,
+0xa4, 0x5b, 0x90, 0x8c, 0x5d, 0x00, 0x84, 0x3b, 0xa8, 0xc0, 0xc0, 0x80,
+0xa4, 0x5b, 0x78, 0x8c, 0x5c, 0xd0, 0x84, 0x3b, 0xa5, 0xd3, 0x82, 0x40,
+0x50, 0xc0, 0xc0, 0x81, 0x3b, 0x5a, 0x50, 0xc0, 0xc0, 0x81, 0x3b, 0x57,
+0x18, 0x24, 0x38, 0x48, 0x83, 0x90, 0xa8, 0xd3, 0x82, 0xc0, 0xc0, 0xc0,
+0x80, 0xa4, 0x5b, 0x60, 0x3b, 0x94, 0xc0, 0xc0, 0x80, 0xa4, 0x5b, 0x48,
+0x3b, 0x8e, 0xd3, 0x82, 0x40, 0x50, 0xc0, 0xc0, 0x81, 0x3b, 0x54, 0x50,
+0xc0, 0xc0, 0x81, 0x3b, 0x51, 0x92, 0xb8, 0x99, 0x84, 0x38, 0x40, 0x90,
+0x78, 0x90, 0x50, 0x10, 0x10, 0x80, 0xa4, 0x4f, 0xa0, 0x39, 0xf9, 0x82,
+0x39, 0xef, 0x90, 0x80, 0x10, 0x10, 0x90, 0x38, 0xa4, 0x51, 0xa0, 0x3a,
+0x3a, 0xa4, 0x51, 0x48, 0x3a, 0x2e, 0x80, 0x90, 0x38, 0xa4, 0x50, 0x20,
+0x3a, 0x0f, 0xa4, 0x4f, 0xf8, 0x3a, 0x0a, 0x83, 0x90, 0xa8, 0xd3, 0x82,
+0xc0, 0xc0, 0xc0, 0x80, 0xa4, 0x5b, 0x30, 0x3b, 0x88, 0xc0, 0xc0, 0x80,
+0xa4, 0x5b, 0x18, 0x3b, 0x82, 0xd3, 0x82, 0x40, 0x50, 0xc0, 0xc0, 0x81,
+0x3b, 0x4e, 0x50, 0xc0, 0xc0, 0x81, 0x3b, 0x4b, 0x18, 0x20, 0x01, 0x48,
+0x83, 0x90, 0xa8, 0xd3, 0x82, 0xc0, 0xc0, 0xc0, 0x80, 0xa4, 0x5b, 0x00,
+0x3b, 0x7c, 0xc0, 0xc0, 0x80, 0xa4, 0x5a, 0xe8, 0x3b, 0x76, 0xd3, 0x82,
+0x40, 0x50, 0xc0, 0xc0, 0x81, 0x3b, 0x48, 0x50, 0xc0, 0xc0, 0x81, 0x3b,
+0x45, 0xda, 0x06, 0xe1, 0xc1, 0xc0, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x3e,
+0x08, 0x37, 0xbf, 0x80, 0x37, 0xbc, 0x90, 0x38, 0xa4, 0x3d, 0xb0, 0x37,
+0xba, 0x80, 0x37, 0xb7, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x3d, 0xf0, 0x37,
+0xc0, 0x80, 0x37, 0xbd, 0x90, 0x38, 0xa4, 0x3d, 0xc8, 0x37, 0xbb, 0x80,
+0x37, 0xb8, 0xc8, 0x40, 0x19, 0x00, 0x91, 0x58, 0x90, 0x60, 0x82, 0x90,
+0x20, 0x39, 0xee, 0xa4, 0x4f, 0x60, 0x39, 0xed, 0x90, 0xc0, 0x80, 0x90,
+0x90, 0x90, 0x48, 0xc9, 0xe2, 0x89, 0xc0, 0x85, 0x3a, 0x26, 0xc9, 0xe2,
+0x89, 0x00, 0x85, 0x3a, 0x23, 0x80, 0x3a, 0x22, 0x10, 0x10, 0x81, 0x39,
+0xfe, 0x90, 0xa8, 0x10, 0x10, 0x90, 0x28, 0x81, 0x3a, 0x1c, 0x90, 0x38,
+0xa4, 0x50, 0xb8, 0x3a, 0x18, 0xa4, 0x50, 0xa8, 0x3a, 0x16, 0x90, 0x70,
+0x10, 0x10, 0x90, 0x38, 0xa4, 0x50, 0xd0, 0x3a, 0x1b, 0x80, 0x3a, 0x19,
+0x90, 0x60, 0x90, 0x28, 0x24, 0x51, 0x08, 0xa4, 0x50, 0xf8, 0x3a, 0x20,
+0x80, 0xa4, 0x50, 0xe8, 0x3a, 0x1e, 0x80, 0x90, 0xf8, 0x90, 0x90, 0x90,
+0x50, 0x90, 0x28, 0x80, 0x3b, 0x3a, 0x80, 0x3b, 0x43, 0x80, 0xa4, 0x5a,
+0x08, 0x3b, 0x42, 0x90, 0x28, 0x81, 0x3b, 0x40, 0x80, 0xa4, 0x59, 0xf0,
+0x3b, 0x3f, 0x90, 0x28, 0x82, 0x3b, 0x3d, 0x81, 0xa4, 0x59, 0xd8, 0x3b,
+0x3c, 0x98, 0xe8, 0x01, 0xb0, 0x90, 0x88, 0x90, 0x60, 0xa4, 0x4f, 0x50,
+0x10, 0x10, 0x10, 0x10, 0x83, 0x36, 0xd5, 0x24, 0x4f, 0x48, 0x90, 0x28,
+0x24, 0x4f, 0x40, 0x24, 0x4f, 0x38, 0x90, 0x88, 0x90, 0x60, 0xa4, 0x4f,
+0x28, 0x10, 0x10, 0x10, 0x10, 0x83, 0x36, 0xd4, 0x24, 0x4f, 0x20, 0x90,
+0x28, 0x24, 0x4f, 0x18, 0x24, 0x4f, 0x10, 0xa8, 0x09, 0x10, 0x0e, 0x30,
+0x96, 0x58, 0x95, 0xf8, 0x93, 0x38, 0x91, 0xa0, 0x90, 0xd0, 0x90, 0x70,
+0x90, 0x38, 0xa4, 0x37, 0x58, 0x36, 0xec, 0xa4, 0x37, 0x48, 0x36, 0xea,
+0x90, 0x38, 0xa4, 0x37, 0x38, 0x36, 0xe8, 0x80, 0x36, 0xe6, 0x90, 0x60,
+0x90, 0x28, 0x24, 0x36, 0xf0, 0xa4, 0x36, 0xe0, 0x36, 0xdd, 0x90, 0x38,
+0xa4, 0x36, 0xd0, 0x36, 0xdb, 0xa4, 0x37, 0x20, 0x36, 0xe5, 0x90, 0xe0,
+0x90, 0x70, 0x90, 0x38, 0xa4, 0x37, 0x10, 0x36, 0xe3, 0xa4, 0x37, 0x00,
+0x36, 0xe1, 0x90, 0x38, 0xa4, 0x4e, 0xc8, 0x39, 0xdf, 0xa4, 0x4e, 0x68,
+0x39, 0xd3, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x4b, 0xa8, 0x39, 0x81, 0xa4,
+0x4b, 0x78, 0x39, 0x7b, 0x10, 0x10, 0xa4, 0x36, 0xc0, 0x36, 0xd9, 0x99,
+0x70, 0x02, 0x80, 0x90, 0xa0, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x37, 0x88,
+0x36, 0xdf, 0x80, 0x36, 0xf9, 0x80, 0xa4, 0x37, 0x90, 0x36, 0xf7, 0x90,
+0x50, 0x90, 0x28, 0x24, 0x37, 0x98, 0x80, 0x36, 0xfa, 0x90, 0x38, 0xa4,
+0x37, 0xa0, 0x36, 0xf8, 0xa4, 0x37, 0x68, 0x36, 0xee, 0x90, 0xe0, 0x90,
+0x70, 0x90, 0x38, 0xa4, 0x4e, 0x00, 0x39, 0xc8, 0xa4, 0x4d, 0x60, 0x39,
+0xb5, 0x90, 0x38, 0xa4, 0x4c, 0xf8, 0x39, 0xa6, 0xa4, 0x4c, 0x68, 0x39,
+0x95, 0x81, 0xa4, 0x37, 0x78, 0x36, 0xf0, 0xe4, 0xa2, 0xcd, 0x00, 0x3b,
+0x36, 0x18, 0x24, 0x36, 0xb8, 0xe4, 0xe2, 0xcb, 0x80, 0x3b, 0x30, 0x92,
+0x40, 0x91, 0x08, 0x10, 0x10, 0x90, 0x80, 0x10, 0x10, 0x90, 0x38, 0xa4,
+0x4e, 0xc0, 0x39, 0xde, 0xa4, 0x4e, 0x60, 0x39, 0xd2, 0x80, 0x90, 0x38,
+0xa4, 0x4b, 0xa0, 0x39, 0x80, 0xa4, 0x4b, 0x70, 0x39, 0x7a, 0x18, 0x20,
+0x00, 0xf8, 0x80, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x4d, 0xf0, 0x39, 0xc7,
+0xa4, 0x4d, 0x58, 0x39, 0xb3, 0x90, 0x38, 0xa4, 0x4c, 0xe8, 0x39, 0xa5,
+0xa4, 0x4c, 0x60, 0x39, 0x93, 0xe4, 0xa2, 0xca, 0x00, 0x3b, 0x2a, 0x18,
+0x24, 0x36, 0xb0, 0xe4, 0xe2, 0xc8, 0x80, 0x3b, 0x24, 0x92, 0x90, 0x92,
+0x40, 0x91, 0x08, 0x10, 0x10, 0x90, 0x80, 0x10, 0x10, 0x90, 0x38, 0xa4,
+0x4e, 0xb8, 0x39, 0xdd, 0xa4, 0x4e, 0x58, 0x39, 0xd1, 0x80, 0x90, 0x38,
+0xa4, 0x4b, 0x98, 0x39, 0x7f, 0xa4, 0x4b, 0x68, 0x39, 0x79, 0x18, 0x20,
+0x00, 0xf8, 0x80, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x4d, 0xe0, 0x39, 0xc6,
+0xa4, 0x4d, 0x50, 0x39, 0xb1, 0x90, 0x38, 0xa4, 0x4c, 0xd8, 0x39, 0xa4,
+0xa4, 0x4c, 0x58, 0x39, 0x91, 0xe4, 0xa2, 0xcd, 0x40, 0x3b, 0x38, 0x10,
+0x10, 0xe4, 0xe2, 0xcb, 0xc0, 0x3b, 0x32, 0x92, 0x50, 0x99, 0x1c, 0x37,
+0xa8, 0x10, 0x10, 0x90, 0x80, 0x10, 0x10, 0x90, 0x38, 0xa4, 0x4e, 0xb0,
+0x39, 0xdc, 0xa4, 0x4e, 0x50, 0x39, 0xd0, 0x80, 0x90, 0x38, 0xa4, 0x4b,
+0x90, 0x39, 0x7e, 0xa4, 0x4b, 0x60, 0x39, 0x78, 0x18, 0x20, 0x00, 0xf8,
+0x80, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x4d, 0xd0, 0x39, 0xc5, 0xa4, 0x4d,
+0x48, 0x39, 0xaf, 0x90, 0x38, 0xa4, 0x4c, 0xc8, 0x39, 0xa3, 0xa4, 0x4c,
+0x50, 0x39, 0x8f, 0xe4, 0xa2, 0xca, 0x40, 0x3b, 0x2c, 0x10, 0x10, 0xe4,
+0xe2, 0xc8, 0xc0, 0x3b, 0x26, 0xc0, 0x40, 0x80, 0x10, 0x10, 0x81, 0x90,
+0x90, 0x90, 0x48, 0xc9, 0xe2, 0x61, 0x40, 0x85, 0x39, 0x89, 0xc9, 0xe2,
+0x61, 0xc0, 0x85, 0x39, 0x86, 0x80, 0x39, 0x84, 0x80, 0xd8, 0x47, 0x80,
+0x0d, 0xc0, 0xc0, 0x80, 0x10, 0x10, 0x82, 0x90, 0x58, 0xd5, 0x81, 0x80,
+0x80, 0x3b, 0x20, 0x80, 0x3b, 0x1e, 0xd5, 0x81, 0x80, 0x80, 0x3b, 0x1c,
+0x80, 0x3b, 0x1a, 0xc0, 0x80, 0x10, 0x10, 0x82, 0x90, 0x58, 0xd5, 0x81,
+0x80, 0x80, 0x3b, 0x21, 0x80, 0x3b, 0x1f, 0xd5, 0x81, 0x80, 0x80, 0x3b,
+0x1d, 0x80, 0x3b, 0x1b, 0xc0, 0x80, 0x83, 0xa4, 0x58, 0xc0, 0x3b, 0x19,
+0xa0, 0x79, 0x20, 0xa0, 0x61, 0xa0, 0xa8, 0x3e, 0x70, 0x54, 0x48, 0xa0,
+0x21, 0x30, 0xa0, 0x14, 0xe0, 0xa0, 0x0a, 0xd8, 0x9d, 0x60, 0x0a, 0x90,
+0x92, 0xa0, 0x91, 0x50, 0x90, 0xb0, 0x90, 0x58, 0xa4, 0x20, 0x60, 0xe1,
+0xe1, 0xb3, 0x00, 0x36, 0xd3, 0xa4, 0x20, 0x80, 0xe1, 0xe1, 0xb2, 0xc0,
+0x36, 0xd1, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0xb2, 0x80, 0x36, 0xcf, 0xa4,
+0x20, 0x70, 0xe1, 0xe1, 0xb2, 0x40, 0x36, 0xcd, 0x90, 0xb0, 0x90, 0x58,
+0xa4, 0x20, 0x00, 0xe1, 0xe1, 0x9a, 0x40, 0x36, 0x70, 0xa4, 0x20, 0x20,
+0xe1, 0xe1, 0x9a, 0x00, 0x36, 0x6e, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0x99,
+0xc0, 0x36, 0x6c, 0xa4, 0x20, 0x10, 0xe1, 0xe1, 0x99, 0x80, 0x36, 0x6a,
+0x91, 0x50, 0x90, 0xb0, 0x90, 0x58, 0xa4, 0x1f, 0xa0, 0xe1, 0xe1, 0x81,
+0x80, 0x36, 0x0d, 0xa4, 0x1f, 0xc0, 0xe1, 0xe1, 0x81, 0x40, 0x36, 0x0b,
+0x90, 0x48, 0x80, 0xe1, 0xe1, 0x81, 0x00, 0x36, 0x09, 0xa4, 0x1f, 0xb0,
+0xe1, 0xe1, 0x80, 0xc0, 0x36, 0x07, 0x90, 0xc0, 0x90, 0x68, 0xa4, 0x1f,
+0x40, 0xe9, 0xe1, 0x68, 0xe1, 0x44, 0x00, 0x35, 0xaa, 0xa4, 0x1f, 0x60,
+0xe1, 0xe1, 0x68, 0x80, 0x35, 0xa8, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0x68,
+0x40, 0x35, 0xa6, 0xa4, 0x1f, 0x50, 0xe1, 0xe1, 0x68, 0x00, 0x35, 0xa4,
+0x92, 0xa0, 0x91, 0x50, 0x90, 0xb0, 0x90, 0x58, 0xa4, 0x20, 0x30, 0xe1,
+0xe1, 0xb0, 0x80, 0x36, 0xbe, 0xa4, 0x20, 0x50, 0xe1, 0xe1, 0xb0, 0x40,
+0x36, 0xc7, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0xb0, 0x00, 0x36, 0xc5, 0xa4,
+0x20, 0x40, 0xe1, 0xe1, 0xaf, 0xc0, 0x36, 0xc3, 0x90, 0xb0, 0x90, 0x58,
+0xa4, 0x1f, 0xd0, 0xe1, 0xe1, 0x97, 0xc0, 0x36, 0x5b, 0xa4, 0x1f, 0xf0,
+0xe1, 0xe1, 0x97, 0x80, 0x36, 0x64, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0x97,
+0x40, 0x36, 0x62, 0xa4, 0x1f, 0xe0, 0xe1, 0xe1, 0x97, 0x00, 0x36, 0x60,
+0x91, 0x50, 0x90, 0xb0, 0x90, 0x58, 0xa4, 0x1f, 0x70, 0xe1, 0xe1, 0x7f,
+0x00, 0x35, 0xf8, 0xa4, 0x1f, 0x90, 0xe1, 0xe1, 0x7e, 0xc0, 0x36, 0x01,
+0x90, 0x48, 0x80, 0xe1, 0xe1, 0x7e, 0x80, 0x35, 0xff, 0xa4, 0x1f, 0x80,
+0xe1, 0xe1, 0x7e, 0x40, 0x35, 0xfd, 0x90, 0xb0, 0x90, 0x58, 0xa4, 0x1f,
+0x10, 0xe1, 0xe1, 0x66, 0x40, 0x35, 0x95, 0xa4, 0x1f, 0x30, 0xe1, 0xe1,
+0x66, 0x00, 0x35, 0x9e, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0x65, 0xc0, 0x35,
+0x9c, 0xa4, 0x1f, 0x20, 0xe1, 0xe1, 0x65, 0x80, 0x35, 0x9a, 0xe4, 0xe2,
+0x54, 0x00, 0x39, 0x64, 0x9d, 0x50, 0x09, 0xc0, 0x92, 0xa0, 0x91, 0x50,
+0x90, 0xb0, 0x90, 0x58, 0xa4, 0x1e, 0xa8, 0xe1, 0xe1, 0xad, 0xc0, 0x36,
+0xb3, 0xa4, 0x1e, 0xa0, 0xe1, 0xe1, 0xad, 0x80, 0x36, 0xbc, 0x90, 0x48,
+0x80, 0xe1, 0xe1, 0xad, 0x40, 0x36, 0xba, 0xa4, 0x1e, 0x98, 0xe1, 0xe1,
+0xad, 0x00, 0x36, 0xb8, 0x90, 0xb0, 0x90, 0x58, 0xa4, 0x1e, 0x90, 0xe1,
+0xe1, 0x95, 0x00, 0x36, 0x50, 0xa4, 0x1e, 0x88, 0xe1, 0xe1, 0x94, 0xc0,
+0x36, 0x59, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0x94, 0x80, 0x36, 0x57, 0xa4,
+0x1e, 0x80, 0xe1, 0xe1, 0x94, 0x40, 0x36, 0x55, 0x91, 0x50, 0x90, 0xb0,
+0x90, 0x58, 0xa4, 0x1e, 0x78, 0xe1, 0xe1, 0x7c, 0x40, 0x35, 0xed, 0xa4,
+0x1e, 0x70, 0xe1, 0xe1, 0x7c, 0x00, 0x35, 0xf6, 0x90, 0x48, 0x80, 0xe1,
+0xe1, 0x7b, 0xc0, 0x35, 0xf4, 0xa4, 0x1e, 0x68, 0xe1, 0xe1, 0x7b, 0x80,
+0x35, 0xf2, 0x90, 0xb0, 0x90, 0x58, 0xa4, 0x1e, 0x60, 0xe1, 0xe1, 0x63,
+0x80, 0x35, 0x8a, 0xa4, 0x1e, 0x58, 0xe1, 0xe1, 0x63, 0x40, 0x35, 0x93,
+0x90, 0x48, 0x80, 0xe1, 0xe1, 0x63, 0x00, 0x35, 0x91, 0xa4, 0x1e, 0x50,
+0xe1, 0xe1, 0x62, 0xc0, 0x35, 0x8f, 0x92, 0x40, 0x91, 0x20, 0x90, 0x90,
+0x90, 0x48, 0x80, 0xe1, 0xe1, 0xab, 0x00, 0x36, 0xa8, 0x80, 0xe1, 0xe1,
+0xaa, 0xc0, 0x36, 0xb1, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0xaa, 0x80, 0x36,
+0xaf, 0x80, 0xe1, 0xe1, 0xaa, 0x40, 0x36, 0xad, 0x90, 0x90, 0x90, 0x48,
+0x80, 0xe1, 0xe1, 0x92, 0x40, 0x36, 0x45, 0x80, 0xe1, 0xe1, 0x92, 0x00,
+0x36, 0x4e, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0x91, 0xc0, 0x36, 0x4c, 0x80,
+0xe1, 0xe1, 0x91, 0x80, 0x36, 0x4a, 0x91, 0x20, 0x90, 0x90, 0x90, 0x48,
+0x80, 0xe1, 0xe1, 0x79, 0x80, 0x35, 0xe2, 0x80, 0xe1, 0xe1, 0x79, 0x40,
+0x35, 0xeb, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0x79, 0x00, 0x35, 0xe9, 0x80,
+0xe1, 0xe1, 0x78, 0xc0, 0x35, 0xe7, 0x90, 0x90, 0x90, 0x48, 0x80, 0xe1,
+0xe1, 0x60, 0xc0, 0x35, 0x7f, 0x80, 0xe1, 0xe1, 0x60, 0x80, 0x35, 0x88,
+0x90, 0x48, 0x80, 0xe1, 0xe1, 0x60, 0x40, 0x35, 0x86, 0x80, 0xe1, 0xe1,
+0x60, 0x00, 0x35, 0x84, 0xe4, 0xe2, 0x2f, 0x00, 0x38, 0xe4, 0xa0, 0x0a,
+0x08, 0x9c, 0xf0, 0x09, 0xc0, 0x92, 0x40, 0x91, 0x20, 0x90, 0x90, 0x90,
+0x48, 0x80, 0xe1, 0xe1, 0xa8, 0x40, 0x36, 0x9d, 0x80, 0xe1, 0xe1, 0xa8,
+0x00, 0x36, 0xa6, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0xa7, 0xc0, 0x36, 0xa4,
+0x80, 0xe1, 0xe1, 0xa7, 0x80, 0x36, 0xa2, 0x90, 0x90, 0x90, 0x48, 0x80,
+0xe1, 0xe1, 0x8f, 0x80, 0x36, 0x3a, 0x80, 0xe1, 0xe1, 0x8f, 0x40, 0x36,
+0x43, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0x8f, 0x00, 0x36, 0x41, 0x80, 0xe1,
+0xe1, 0x8e, 0xc0, 0x36, 0x3f, 0x91, 0x50, 0x90, 0xb0, 0x90, 0x58, 0xa4,
+0x1e, 0x38, 0xe1, 0xe1, 0x76, 0xc0, 0x35, 0xd7, 0xa4, 0x1e, 0x48, 0xe1,
+0xe1, 0x76, 0x80, 0x35, 0xe0, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0x76, 0x40,
+0x35, 0xde, 0xa4, 0x1e, 0x40, 0xe1, 0xe1, 0x76, 0x00, 0x35, 0xdc, 0x90,
+0xb0, 0x90, 0x58, 0xa4, 0x1e, 0x08, 0xe1, 0xe1, 0x5e, 0x00, 0x35, 0x74,
+0xa4, 0x1e, 0x18, 0xe1, 0xe1, 0x5d, 0xc0, 0x35, 0x7d, 0x90, 0x48, 0x80,
+0xe1, 0xe1, 0x5d, 0x80, 0x35, 0x7b, 0xa4, 0x1e, 0x10, 0xe1, 0xe1, 0x5d,
+0x40, 0x35, 0x79, 0x92, 0x40, 0x91, 0x20, 0x90, 0x90, 0x90, 0x48, 0x80,
+0xe1, 0xe1, 0xa5, 0x80, 0x36, 0x92, 0x80, 0xe1, 0xe1, 0xa5, 0x40, 0x36,
+0x9b, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0xa5, 0x00, 0x36, 0x99, 0x80, 0xe1,
+0xe1, 0xa4, 0xc0, 0x36, 0x97, 0x90, 0x90, 0x90, 0x48, 0x80, 0xe1, 0xe1,
+0x8c, 0xc0, 0x36, 0x2f, 0x80, 0xe1, 0xe1, 0x8c, 0x80, 0x36, 0x38, 0x90,
+0x48, 0x80, 0xe1, 0xe1, 0x8c, 0x40, 0x36, 0x36, 0x80, 0xe1, 0xe1, 0x8c,
+0x00, 0x36, 0x34, 0x91, 0x50, 0x90, 0xb0, 0x90, 0x58, 0xa4, 0x1e, 0x20,
+0xe1, 0xe1, 0x74, 0x00, 0x35, 0xcc, 0xa4, 0x1e, 0x30, 0xe1, 0xe1, 0x73,
+0xc0, 0x35, 0xd5, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0x73, 0x80, 0x35, 0xd3,
+0xa4, 0x1e, 0x28, 0xe1, 0xe1, 0x73, 0x40, 0x35, 0xd1, 0x90, 0xb0, 0x90,
+0x58, 0xa4, 0x1d, 0xf0, 0xe1, 0xe1, 0x5b, 0x40, 0x35, 0x69, 0xa4, 0x1e,
+0x00, 0xe1, 0xe1, 0x5b, 0x00, 0x35, 0x72, 0x90, 0x48, 0x80, 0xe1, 0xe1,
+0x5a, 0xc0, 0x35, 0x70, 0xa4, 0x1d, 0xf8, 0xe1, 0xe1, 0x5a, 0x80, 0x35,
+0x6e, 0xe4, 0xe2, 0x53, 0x00, 0x39, 0x60, 0x99, 0x50, 0x02, 0x00, 0x10,
+0x10, 0x10, 0x10, 0x90, 0x90, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0x58, 0x80,
+0x35, 0x5e, 0x80, 0xe1, 0xe1, 0x58, 0x40, 0x35, 0x67, 0x90, 0x48, 0x80,
+0xe1, 0xe1, 0x58, 0x00, 0x35, 0x65, 0x80, 0xe1, 0xe1, 0x57, 0xc0, 0x35,
+0x63, 0x90, 0x60, 0x90, 0x30, 0x60, 0xa0, 0xef, 0x40, 0x60, 0xa0, 0xef,
+0x00, 0x90, 0x30, 0x60, 0xa0, 0xee, 0xc0, 0x60, 0xa0, 0xee, 0x80, 0xe4,
+0xe2, 0x2d, 0x00, 0x38, 0xdc, 0xa0, 0x10, 0x98, 0xa0, 0x09, 0xa8, 0x9c,
+0xc0, 0x09, 0x60, 0x92, 0x70, 0x91, 0x50, 0x90, 0xb0, 0x90, 0x58, 0xa4,
+0x1e, 0xe0, 0xe1, 0xe1, 0xa2, 0xc0, 0x36, 0x7c, 0xa4, 0x1f, 0x00, 0xe1,
+0xe1, 0xa2, 0x80, 0x36, 0x90, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0xa2, 0x40,
+0x36, 0x8e, 0xa4, 0x1e, 0xf0, 0xe1, 0xe1, 0xa2, 0x00, 0x36, 0x8c, 0x90,
+0x90, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0x8a, 0x00, 0x36, 0x19, 0x80, 0xe1,
+0xe1, 0x89, 0xc0, 0x36, 0x2d, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0x89, 0x80,
+0x36, 0x2b, 0x80, 0xe1, 0xe1, 0x89, 0x40, 0x36, 0x29, 0x91, 0x20, 0x90,
+0x90, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0x71, 0x40, 0x35, 0xb6, 0x80, 0xe1,
+0xe1, 0x71, 0x00, 0x35, 0xca, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0x70, 0xc0,
+0x35, 0xc8, 0x80, 0xe1, 0xe1, 0x70, 0x80, 0x35, 0xc6, 0x90, 0x90, 0x90,
+0x48, 0x80, 0xe1, 0xe1, 0x55, 0xc0, 0x35, 0x48, 0x80, 0xe1, 0xe1, 0x55,
+0x80, 0x35, 0x5c, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0x55, 0x40, 0x35, 0x5a,
+0x80, 0xe1, 0xe1, 0x55, 0x00, 0x35, 0x58, 0x92, 0x70, 0x91, 0x50, 0x90,
+0xb0, 0x90, 0x58, 0xa4, 0x1e, 0xb0, 0xe1, 0xe1, 0x9d, 0x40, 0x36, 0x71,
+0xa4, 0x1e, 0xd0, 0xe1, 0xe1, 0x9d, 0x00, 0x36, 0x7a, 0x90, 0x48, 0x80,
+0xe1, 0xe1, 0x9c, 0xc0, 0x36, 0x78, 0xa4, 0x1e, 0xc0, 0xe1, 0xe1, 0x9c,
+0x80, 0x36, 0x76, 0x90, 0x90, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0x84, 0x80,
+0x36, 0x0e, 0x80, 0xe1, 0xe1, 0x84, 0x40, 0x36, 0x17, 0x90, 0x48, 0x80,
+0xe1, 0xe1, 0x84, 0x00, 0x36, 0x15, 0x80, 0xe1, 0xe1, 0x83, 0xc0, 0x36,
+0x13, 0x91, 0x20, 0x90, 0x90, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0x6b, 0xc0,
+0x35, 0xab, 0x80, 0xe1, 0xe1, 0x6b, 0x80, 0x35, 0xb4, 0x90, 0x48, 0x80,
+0xe1, 0xe1, 0x6b, 0x40, 0x35, 0xb2, 0x80, 0xe1, 0xe1, 0x6b, 0x00, 0x35,
+0xb0, 0x90, 0x90, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0x50, 0x40, 0x35, 0x3d,
+0x80, 0xe1, 0xe1, 0x50, 0x00, 0x35, 0x46, 0x90, 0x48, 0x80, 0xe1, 0xe1,
+0x4f, 0xc0, 0x35, 0x44, 0x80, 0xe1, 0xe1, 0x4f, 0x80, 0x35, 0x42, 0xe4,
+0xe2, 0x52, 0x00, 0x39, 0x5c, 0x9d, 0x70, 0x06, 0xa8, 0x93, 0x20, 0x92,
+0x00, 0x91, 0x00, 0x90, 0x80, 0x90, 0x40, 0xe1, 0xe1, 0xa0, 0x40, 0x36,
+0x7d, 0xe1, 0xe1, 0x4b, 0x40, 0x35, 0x3b, 0x90, 0x40, 0xe1, 0xe1, 0xa0,
+0x00, 0x36, 0x86, 0xe1, 0xe1, 0x4a, 0xc0, 0x35, 0x37, 0x90, 0x80, 0x90,
+0x40, 0xe1, 0xe1, 0x9f, 0xc0, 0x36, 0x84, 0xe1, 0xe1, 0x4a, 0x40, 0x35,
+0x33, 0x90, 0x40, 0xe1, 0xe1, 0x9f, 0x80, 0x36, 0x82, 0xe1, 0xe1, 0x49,
+0xc0, 0x35, 0x2f, 0x90, 0x90, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0x87, 0x80,
+0x36, 0x1a, 0x80, 0xe1, 0xe1, 0x87, 0x40, 0x36, 0x23, 0x90, 0x48, 0x80,
+0xe1, 0xe1, 0x87, 0x00, 0x36, 0x21, 0x80, 0xe1, 0xe1, 0x86, 0xc0, 0x36,
+0x1f, 0x91, 0x20, 0x90, 0x90, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0x6e, 0xc0,
+0x35, 0xb7, 0x80, 0xe1, 0xe1, 0x6e, 0x80, 0x35, 0xc0, 0x90, 0x48, 0x80,
+0xe1, 0xe1, 0x6e, 0x40, 0x35, 0xbe, 0x80, 0xe1, 0xe1, 0x6e, 0x00, 0x35,
+0xbc, 0x90, 0x90, 0x90, 0x48, 0x80, 0xe1, 0xe1, 0x53, 0x40, 0x35, 0x49,
+0x80, 0xe1, 0xe1, 0x53, 0x00, 0x35, 0x52, 0x90, 0x48, 0x80, 0xe1, 0xe1,
+0x52, 0xc0, 0x35, 0x50, 0x80, 0xe1, 0xe1, 0x52, 0x80, 0x35, 0x4e, 0x81,
+0x90, 0xa0, 0x90, 0x50, 0x10, 0x10, 0xe1, 0xe1, 0x46, 0x40, 0x35, 0x11,
+0x10, 0x10, 0xe1, 0xe1, 0x45, 0xc0, 0x35, 0x23, 0x90, 0x50, 0x10, 0x10,
+0xe1, 0xe1, 0x45, 0x40, 0x35, 0x1f, 0x10, 0x10, 0xe1, 0xe1, 0x44, 0xc0,
+0x35, 0x1b, 0xe4, 0xe2, 0x2b, 0x00, 0x38, 0xd4, 0xa0, 0x0b, 0x08, 0x9d,
+0x70, 0x0a, 0xc0, 0x93, 0x20, 0x92, 0x00, 0x91, 0x00, 0x90, 0x80, 0x90,
+0x40, 0xe3, 0xa1, 0x26, 0x40, 0x34, 0xa0, 0xe3, 0xa1, 0x0b, 0x80, 0x34,
+0x3c, 0x90, 0x40, 0xe3, 0xa1, 0x26, 0x00, 0x34, 0x9e, 0xe3, 0xa1, 0x0b,
+0x00, 0x34, 0x38, 0x90, 0x80, 0x90, 0x40, 0xe3, 0xa1, 0x25, 0xc0, 0x34,
+0x9c, 0xe3, 0xa1, 0x0a, 0x80, 0x34, 0x34, 0x90, 0x40, 0xe3, 0xa1, 0x25,
+0x80, 0x34, 0x9a, 0xe3, 0xa1, 0x0a, 0x00, 0x34, 0x30, 0x90, 0x90, 0x90,
+0x48, 0x80, 0xe3, 0xa1, 0x20, 0xc0, 0x34, 0x8a, 0x80, 0xe3, 0xa1, 0x20,
+0x80, 0x34, 0x88, 0x90, 0x48, 0x80, 0xe3, 0xa1, 0x20, 0x40, 0x34, 0x86,
+0x80, 0xe3, 0xa1, 0x20, 0x00, 0x34, 0x84, 0x91, 0x20, 0x90, 0x90, 0x90,
+0x48, 0x80, 0xe3, 0xa1, 0x1b, 0x40, 0x34, 0x74, 0x80, 0xe3, 0xa1, 0x1b,
+0x00, 0x34, 0x72, 0x90, 0x48, 0x80, 0xe3, 0xa1, 0x1a, 0xc0, 0x34, 0x70,
+0x80, 0xe3, 0xa1, 0x1a, 0x80, 0x34, 0x6e, 0x90, 0x90, 0x90, 0x48, 0x80,
+0xe3, 0xa1, 0x15, 0xc0, 0x34, 0x5e, 0x80, 0xe3, 0xa1, 0x15, 0x80, 0x34,
+0x5c, 0x90, 0x48, 0x80, 0xe3, 0xa1, 0x15, 0x40, 0x34, 0x5a, 0x80, 0xe3,
+0xa1, 0x15, 0x00, 0x34, 0x58, 0x93, 0x20, 0x92, 0x00, 0x91, 0x00, 0x90,
+0x80, 0x90, 0x40, 0xe3, 0xa1, 0x23, 0xc0, 0x34, 0x8b, 0xe3, 0xa1, 0x06,
+0x80, 0x34, 0x12, 0x90, 0x40, 0xe3, 0xa1, 0x23, 0x80, 0x34, 0x94, 0xe3,
+0xa1, 0x06, 0x00, 0x34, 0x24, 0x90, 0x80, 0x90, 0x40, 0xe3, 0xa1, 0x23,
+0x40, 0x34, 0x92, 0xe3, 0xa1, 0x05, 0x80, 0x34, 0x20, 0x90, 0x40, 0xe3,
+0xa1, 0x23, 0x00, 0x34, 0x90, 0xe3, 0xa1, 0x05, 0x00, 0x34, 0x1c, 0x90,
+0x90, 0x90, 0x48, 0x80, 0xe3, 0xa1, 0x1e, 0x40, 0x34, 0x75, 0x80, 0xe3,
+0xa1, 0x1e, 0x00, 0x34, 0x7e, 0x90, 0x48, 0x80, 0xe3, 0xa1, 0x1d, 0xc0,
+0x34, 0x7c, 0x80, 0xe3, 0xa1, 0x1d, 0x80, 0x34, 0x7a, 0x91, 0x20, 0x90,
+0x90, 0x90, 0x48, 0x80, 0xe3, 0xa1, 0x18, 0xc0, 0x34, 0x5f, 0x80, 0xe3,
+0xa1, 0x18, 0x80, 0x34, 0x68, 0x90, 0x48, 0x80, 0xe3, 0xa1, 0x18, 0x40,
+0x34, 0x66, 0x80, 0xe3, 0xa1, 0x18, 0x00, 0x34, 0x64, 0x90, 0x90, 0x90,
+0x48, 0x80, 0xe3, 0xa1, 0x13, 0x40, 0x34, 0x49, 0x80, 0xe3, 0xa1, 0x13,
+0x00, 0x34, 0x52, 0x90, 0x48, 0x80, 0xe3, 0xa1, 0x12, 0xc0, 0x34, 0x50,
+0x80, 0xe3, 0xa1, 0x12, 0x80, 0x34, 0x4e, 0xe4, 0xe2, 0x51, 0x00, 0x39,
+0x58, 0x88, 0x01, 0x48, 0x10, 0x10, 0x10, 0x10, 0x90, 0x90, 0x90, 0x48,
+0x80, 0xe3, 0xa1, 0x10, 0x80, 0x34, 0x3e, 0x80, 0xe3, 0xa1, 0x10, 0x40,
+0x34, 0x47, 0x90, 0x48, 0x80, 0xe3, 0xa1, 0x10, 0x00, 0x34, 0x45, 0x80,
+0xe3, 0xa1, 0x0f, 0xc0, 0x34, 0x43, 0xe4, 0xe2, 0x29, 0x00, 0x38, 0xcc,
+0xa0, 0x0e, 0x80, 0xa0, 0x09, 0x08, 0x94, 0x80, 0x9a, 0x30, 0x04, 0x40,
+0x91, 0x10, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x35, 0x0f, 0x80,
+0x35, 0x0e, 0x10, 0x10, 0x80, 0x35, 0x0d, 0x90, 0x50, 0x90, 0x28, 0x80,
+0x34, 0xf4, 0x80, 0x34, 0xf3, 0x10, 0x10, 0x80, 0x34, 0xf2, 0x90, 0x88,
+0x90, 0x50, 0x90, 0x28, 0x80, 0x34, 0xd9, 0x80, 0x34, 0xd8, 0x10, 0x10,
+0x80, 0x34, 0xd7, 0x90, 0x50, 0x90, 0x28, 0x80, 0x34, 0xbe, 0x80, 0x34,
+0xbd, 0x10, 0x10, 0x80, 0x34, 0xbc, 0x91, 0x10, 0x90, 0x88, 0x90, 0x50,
+0x90, 0x28, 0x80, 0x35, 0x0a, 0x80, 0x35, 0x0c, 0x10, 0x10, 0x80, 0x35,
+0x0b, 0x90, 0x50, 0x90, 0x28, 0x80, 0x34, 0xef, 0x80, 0x34, 0xf1, 0x10,
+0x10, 0x80, 0x34, 0xf0, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x34,
+0xd4, 0x80, 0x34, 0xd6, 0x10, 0x10, 0x80, 0x34, 0xd5, 0x90, 0x50, 0x90,
+0x28, 0x80, 0x34, 0xb9, 0x80, 0x34, 0xbb, 0x10, 0x10, 0x80, 0x34, 0xba,
+0xe4, 0xe2, 0x43, 0x00, 0x39, 0x34, 0x9a, 0x30, 0x04, 0x40, 0x91, 0x10,
+0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x35, 0x07, 0x80, 0x35, 0x09,
+0x10, 0x10, 0x80, 0x35, 0x08, 0x90, 0x50, 0x90, 0x28, 0x80, 0x34, 0xec,
+0x80, 0x34, 0xee, 0x10, 0x10, 0x80, 0x34, 0xed, 0x90, 0x88, 0x90, 0x50,
+0x90, 0x28, 0x80, 0x34, 0xd1, 0x80, 0x34, 0xd3, 0x10, 0x10, 0x80, 0x34,
+0xd2, 0x90, 0x50, 0x90, 0x28, 0x80, 0x34, 0xb6, 0x80, 0x34, 0xb8, 0x10,
+0x10, 0x80, 0x34, 0xb7, 0x91, 0x10, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28,
+0x80, 0x35, 0x04, 0x80, 0x35, 0x06, 0x10, 0x10, 0x80, 0x35, 0x05, 0x90,
+0x50, 0x90, 0x28, 0x80, 0x34, 0xe9, 0x80, 0x34, 0xeb, 0x10, 0x10, 0x80,
+0x34, 0xea, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x34, 0xce, 0x80,
+0x34, 0xd0, 0x10, 0x10, 0x80, 0x34, 0xcf, 0x90, 0x50, 0x90, 0x28, 0x80,
+0x34, 0xb3, 0x80, 0x34, 0xb5, 0x10, 0x10, 0x80, 0x34, 0xb4, 0xe4, 0xe2,
+0x22, 0x00, 0x38, 0x9c, 0x94, 0x80, 0x9a, 0x30, 0x04, 0x40, 0x91, 0x10,
+0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x35, 0x01, 0x80, 0x35, 0x03,
+0x10, 0x10, 0x80, 0x35, 0x02, 0x90, 0x50, 0x90, 0x28, 0x80, 0x34, 0xe6,
+0x80, 0x34, 0xe8, 0x10, 0x10, 0x80, 0x34, 0xe7, 0x90, 0x88, 0x90, 0x50,
+0x90, 0x28, 0x80, 0x34, 0xcb, 0x80, 0x34, 0xcd, 0x10, 0x10, 0x80, 0x34,
+0xcc, 0x90, 0x50, 0x90, 0x28, 0x80, 0x34, 0xb0, 0x80, 0x34, 0xb2, 0x10,
+0x10, 0x80, 0x34, 0xb1, 0x91, 0x10, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28,
+0x80, 0x34, 0xfe, 0x80, 0x35, 0x00, 0x10, 0x10, 0x80, 0x34, 0xff, 0x90,
+0x50, 0x90, 0x28, 0x80, 0x34, 0xe3, 0x80, 0x34, 0xe5, 0x10, 0x10, 0x80,
+0x34, 0xe4, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x34, 0xc8, 0x80,
+0x34, 0xca, 0x10, 0x10, 0x80, 0x34, 0xc9, 0x90, 0x50, 0x90, 0x28, 0x80,
+0x34, 0xad, 0x80, 0x34, 0xaf, 0x10, 0x10, 0x80, 0x34, 0xae, 0xe4, 0xe2,
+0x41, 0x00, 0x39, 0x2c, 0x88, 0x00, 0xb0, 0x10, 0x10, 0x10, 0x10, 0x90,
+0x50, 0x90, 0x28, 0x80, 0x34, 0xaa, 0x80, 0x34, 0xac, 0x10, 0x10, 0x80,
+0x34, 0xab, 0xe4, 0xe2, 0x21, 0x00, 0x38, 0x98, 0x96, 0xe8, 0x94, 0x80,
+0x9a, 0x30, 0x04, 0x40, 0x91, 0x10, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28,
+0x80, 0x34, 0xf8, 0x80, 0x34, 0xfd, 0x10, 0x10, 0x80, 0x34, 0xfc, 0x90,
+0x50, 0x90, 0x28, 0x80, 0x34, 0xdd, 0x80, 0x34, 0xe2, 0x10, 0x10, 0x80,
+0x34, 0xe1, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x34, 0xc2, 0x80,
+0x34, 0xc7, 0x10, 0x10, 0x80, 0x34, 0xc6, 0x90, 0x50, 0x90, 0x28, 0x80,
+0x34, 0xa4, 0x80, 0x34, 0xa9, 0x10, 0x10, 0x80, 0x34, 0xa8, 0x91, 0x10,
+0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x34, 0xf5, 0x80, 0x34, 0xf7,
+0x10, 0x10, 0x80, 0x34, 0xf6, 0x90, 0x50, 0x90, 0x28, 0x80, 0x34, 0xda,
+0x80, 0x34, 0xdc, 0x10, 0x10, 0x80, 0x34, 0xdb, 0x90, 0x88, 0x90, 0x50,
+0x90, 0x28, 0x80, 0x34, 0xbf, 0x80, 0x34, 0xc1, 0x10, 0x10, 0x80, 0x34,
+0xc0, 0x90, 0x50, 0x90, 0x28, 0x80, 0x34, 0xa1, 0x80, 0x34, 0xa3, 0x10,
+0x10, 0x80, 0x34, 0xa2, 0xe4, 0xe2, 0x3f, 0x00, 0x39, 0x24, 0x88, 0x02,
+0x28, 0x91, 0x10, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x34, 0xf9,
+0x80, 0x34, 0xfb, 0x10, 0x10, 0x80, 0x34, 0xfa, 0x90, 0x50, 0x90, 0x28,
+0x80, 0x34, 0xde, 0x80, 0x34, 0xe0, 0x10, 0x10, 0x80, 0x34, 0xdf, 0x90,
+0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x34, 0xc3, 0x80, 0x34, 0xc5, 0x10,
+0x10, 0x80, 0x34, 0xc4, 0x90, 0x50, 0x90, 0x28, 0x80, 0x34, 0xa5, 0x80,
+0x34, 0xa7, 0x10, 0x10, 0x80, 0x34, 0xa6, 0xe4, 0xe2, 0x20, 0x00, 0x38,
+0x94, 0x90, 0x40, 0xe5, 0x22, 0x3d, 0x00, 0x39, 0x1c, 0xe5, 0x22, 0x1f,
+0x00, 0x38, 0x90, 0x9e, 0xb4, 0x3d, 0x08, 0x93, 0x70, 0x91, 0xd8, 0xd5,
+0x07, 0x80, 0xd0, 0xc4, 0x40, 0x90, 0x48, 0x80, 0x8c, 0x58, 0x50, 0x84,
+0x3b, 0x14, 0xa4, 0x56, 0x30, 0x3a, 0xde, 0x90, 0x28, 0x24, 0x55, 0x70,
+0xa4, 0x53, 0xf0, 0x3a, 0x96, 0xd0, 0xc4, 0x40, 0x90, 0x48, 0x80, 0x8c,
+0x58, 0x30, 0x84, 0x3b, 0x12, 0xa4, 0x56, 0x20, 0x3a, 0xdc, 0x90, 0x28,
+0x24, 0x55, 0x60, 0xa4, 0x53, 0xe0, 0x3a, 0x94, 0xd5, 0x06, 0x80, 0xd0,
+0xc3, 0x40, 0x90, 0x28, 0x80, 0x3a, 0xfe, 0xa4, 0x56, 0x00, 0x3a, 0xd8,
+0x90, 0x28, 0x24, 0x55, 0x40, 0xa4, 0x53, 0xc0, 0x3a, 0x90, 0xd0, 0xc3,
+0x40, 0x90, 0x28, 0x80, 0x3a, 0xfa, 0xa4, 0x55, 0xf0, 0x3a, 0xd6, 0x90,
+0x28, 0x24, 0x55, 0x30, 0xa4, 0x53, 0xb0, 0x3a, 0x8e, 0x91, 0x98, 0xd5,
+0x06, 0x80, 0xd0, 0xc3, 0x40, 0x90, 0x28, 0x80, 0x3a, 0xf2, 0xa4, 0x55,
+0xd0, 0x3a, 0xd2, 0x90, 0x28, 0x24, 0x55, 0x10, 0xa4, 0x53, 0x90, 0x3a,
+0x8a, 0xd0, 0xc3, 0x40, 0x90, 0x28, 0x80, 0x3a, 0xee, 0xa4, 0x55, 0xc0,
+0x3a, 0xd0, 0x90, 0x28, 0x24, 0x55, 0x00, 0xa4, 0x53, 0x80, 0x3a, 0x88,
+0xd5, 0x06, 0x80, 0xd0, 0xc3, 0x40, 0x90, 0x28, 0x80, 0x3a, 0xe6, 0xa4,
+0x55, 0xa0, 0x3a, 0xcc, 0x90, 0x28, 0x24, 0x54, 0xe0, 0xa4, 0x53, 0x60,
+0x3a, 0x84, 0xd0, 0xc3, 0x40, 0x90, 0x28, 0x80, 0x3a, 0xe2, 0xa4, 0x55,
+0x90, 0x3a, 0xca, 0x90, 0x28, 0x24, 0x54, 0xd0, 0xa4, 0x53, 0x50, 0x3a,
+0x82, 0x93, 0x70, 0x91, 0xd8, 0xd5, 0x07, 0x80, 0xd0, 0xc4, 0x40, 0x90,
+0x48, 0x80, 0x8c, 0x58, 0x70, 0x84, 0x3b, 0x16, 0xa4, 0x56, 0x40, 0x3a,
+0xe0, 0x90, 0x28, 0x24, 0x55, 0x80, 0xa4, 0x54, 0x00, 0x3a, 0x98, 0xd0,
+0xc4, 0x40, 0x90, 0x48, 0x80, 0x8c, 0x58, 0x40, 0x84, 0x3b, 0x13, 0xa4,
+0x56, 0x28, 0x3a, 0xdd, 0x90, 0x28, 0x24, 0x55, 0x68, 0xa4, 0x53, 0xe8,
+0x3a, 0x95, 0xd5, 0x06, 0x80, 0xd0, 0xc3, 0x40, 0x90, 0x28, 0x80, 0x3b,
+0x02, 0xa4, 0x56, 0x10, 0x3a, 0xda, 0x90, 0x28, 0x24, 0x55, 0x50, 0xa4,
+0x53, 0xd0, 0x3a, 0x92, 0xd0, 0xc3, 0x40, 0x90, 0x28, 0x80, 0x3a, 0xfc,
+0xa4, 0x55, 0xf8, 0x3a, 0xd7, 0x90, 0x28, 0x24, 0x55, 0x38, 0xa4, 0x53,
+0xb8, 0x3a, 0x8f, 0x91, 0x98, 0xd5, 0x06, 0x80, 0xd0, 0xc3, 0x40, 0x90,
+0x28, 0x80, 0x3a, 0xf6, 0xa4, 0x55, 0xe0, 0x3a, 0xd4, 0x90, 0x28, 0x24,
+0x55, 0x20, 0xa4, 0x53, 0xa0, 0x3a, 0x8c, 0xd0, 0xc3, 0x40, 0x90, 0x28,
+0x80, 0x3a, 0xf0, 0xa4, 0x55, 0xc8, 0x3a, 0xd1, 0x90, 0x28, 0x24, 0x55,
+0x08, 0xa4, 0x53, 0x88, 0x3a, 0x89, 0xd5, 0x06, 0x80, 0xd0, 0xc3, 0x40,
+0x90, 0x28, 0x80, 0x3a, 0xea, 0xa4, 0x55, 0xb0, 0x3a, 0xce, 0x90, 0x28,
+0x24, 0x54, 0xf0, 0xa4, 0x53, 0x70, 0x3a, 0x86, 0xd0, 0xc3, 0x40, 0x90,
+0x28, 0x80, 0x3a, 0xe4, 0xa4, 0x55, 0x98, 0x3a, 0xcb, 0x90, 0x28, 0x24,
+0x54, 0xd8, 0xa4, 0x53, 0x58, 0x3a, 0x83, 0x99, 0xd8, 0x03, 0x90, 0x81,
+0x90, 0xe0, 0x5b, 0x41, 0x40, 0x03, 0x40, 0x51, 0x40, 0xc0, 0xa4, 0x3c,
+0xa0, 0x37, 0x84, 0xd1, 0x42, 0x00, 0xa4, 0x3b, 0xa0, 0x37, 0x64, 0xa4,
+0x3a, 0xa0, 0x37, 0x44, 0x5b, 0x41, 0x40, 0x03, 0x40, 0x51, 0x40, 0xc0,
+0xa4, 0x3b, 0xc0, 0x37, 0x88, 0xd1, 0x42, 0x00, 0xa4, 0x3a, 0xc0, 0x37,
+0x68, 0xa4, 0x39, 0xc0, 0x37, 0x48, 0x81, 0x90, 0xe0, 0x5b, 0x41, 0x40,
+0x03, 0x40, 0x51, 0x40, 0xc0, 0xa4, 0x3c, 0x00, 0x37, 0x90, 0xd1, 0x42,
+0x00, 0xa4, 0x3b, 0x00, 0x37, 0x70, 0xa4, 0x3a, 0x00, 0x37, 0x50, 0x5b,
+0x41, 0x40, 0x03, 0x40, 0x51, 0x40, 0xc0, 0xa4, 0x3b, 0xe0, 0x37, 0x8c,
+0xd1, 0x42, 0x00, 0xa4, 0x3a, 0xe0, 0x37, 0x6c, 0xa4, 0x39, 0xe0, 0x37,
+0x4c, 0xa8, 0x0b, 0x18, 0x13, 0xa8, 0x96, 0x80, 0x93, 0x40, 0x99, 0x90,
+0x03, 0x00, 0x90, 0xc0, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x1d, 0xc0, 0x33,
+0xb9, 0x24, 0x1d, 0xb8, 0x90, 0x38, 0xa4, 0x1c, 0xe8, 0x33, 0x9e, 0x24,
+0x1c, 0xe0, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x1c, 0x10, 0x33, 0x83, 0x24,
+0x1c, 0x08, 0x90, 0x38, 0xa4, 0x1b, 0x38, 0x33, 0x68, 0x24, 0x1b, 0x30,
+0x90, 0xc0, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x1d, 0xb0, 0x33, 0xb4, 0x24,
+0x1d, 0xa8, 0x90, 0x38, 0xa4, 0x1c, 0xd8, 0x33, 0x99, 0x24, 0x1c, 0xd0,
+0x90, 0x60, 0x90, 0x38, 0xa4, 0x1c, 0x00, 0x33, 0x7e, 0x24, 0x1b, 0xf8,
+0x90, 0x38, 0xa4, 0x1b, 0x28, 0x33, 0x63, 0x24, 0x1b, 0x20, 0xe4, 0xe2,
+0x99, 0x00, 0x3a, 0x66, 0x99, 0x90, 0x03, 0x00, 0x90, 0xc0, 0x90, 0x60,
+0x90, 0x38, 0xa4, 0x1d, 0x98, 0x33, 0xb1, 0x24, 0x1d, 0x90, 0x90, 0x38,
+0xa4, 0x1c, 0xc0, 0x33, 0x96, 0x24, 0x1c, 0xb8, 0x90, 0x60, 0x90, 0x38,
+0xa4, 0x1b, 0xe8, 0x33, 0x7b, 0x24, 0x1b, 0xe0, 0x90, 0x38, 0xa4, 0x1b,
+0x10, 0x33, 0x60, 0x24, 0x1b, 0x08, 0x90, 0xc0, 0x90, 0x60, 0x90, 0x38,
+0xa4, 0x1d, 0x80, 0x33, 0xae, 0x24, 0x1d, 0x78, 0x90, 0x38, 0xa4, 0x1c,
+0xa8, 0x33, 0x93, 0x24, 0x1c, 0xa0, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x1b,
+0xd0, 0x33, 0x78, 0x24, 0x1b, 0xc8, 0x90, 0x38, 0xa4, 0x1a, 0xf8, 0x33,
+0x5d, 0x24, 0x1a, 0xf0, 0xe4, 0xe2, 0x97, 0x80, 0x3a, 0x60, 0x93, 0x78,
+0x99, 0x90, 0x03, 0x00, 0x90, 0xc0, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x1d,
+0x68, 0x33, 0xab, 0x24, 0x1d, 0x60, 0x90, 0x38, 0xa4, 0x1c, 0x90, 0x33,
+0x90, 0x24, 0x1c, 0x88, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x1b, 0xb8, 0x33,
+0x75, 0x24, 0x1b, 0xb0, 0x90, 0x38, 0xa4, 0x1a, 0xe0, 0x33, 0x5a, 0x24,
+0x1a, 0xd8, 0x90, 0xc0, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x1d, 0x50, 0x33,
+0xa8, 0x24, 0x1d, 0x48, 0x90, 0x38, 0xa4, 0x1c, 0x78, 0x33, 0x8d, 0x24,
+0x1c, 0x70, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x1b, 0xa0, 0x33, 0x72, 0x24,
+0x1b, 0x98, 0x90, 0x38, 0xa4, 0x1a, 0xc8, 0x33, 0x57, 0x24, 0x1a, 0xc0,
+0xec, 0xa1, 0xe7, 0x00, 0x02, 0x00, 0x37, 0x9e, 0xa4, 0x52, 0xc0, 0x3a,
+0x5a, 0x88, 0x00, 0x88, 0x10, 0x10, 0x10, 0x10, 0x90, 0x38, 0xa4, 0x1a,
+0xb0, 0x33, 0x54, 0x24, 0x1a, 0xa8, 0xe9, 0x61, 0xe6, 0x40, 0x02, 0x00,
+0x37, 0x9a, 0xe3, 0x62, 0x94, 0x80, 0x3a, 0x54, 0x95, 0x08, 0x93, 0x40,
+0x99, 0x90, 0x03, 0x00, 0x90, 0xc0, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x1d,
+0x38, 0x33, 0xa2, 0x24, 0x1d, 0x30, 0x90, 0x38, 0xa4, 0x1c, 0x60, 0x33,
+0x87, 0x24, 0x1c, 0x58, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x1b, 0x88, 0x33,
+0x6c, 0x24, 0x1b, 0x80, 0x90, 0x38, 0xa4, 0x1a, 0x98, 0x33, 0x4e, 0x24,
+0x1a, 0x90, 0x90, 0xc0, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x1d, 0x08, 0x33,
+0x9f, 0x24, 0x1d, 0x00, 0x90, 0x38, 0xa4, 0x1c, 0x30, 0x33, 0x84, 0x24,
+0x1c, 0x28, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x1b, 0x58, 0x33, 0x69, 0x24,
+0x1b, 0x50, 0x90, 0x38, 0xa4, 0x1a, 0x68, 0x33, 0x4b, 0x24, 0x1a, 0x60,
+0xe4, 0xe2, 0x99, 0x40, 0x3a, 0x68, 0x88, 0x01, 0x88, 0x90, 0xc0, 0x90,
+0x60, 0x90, 0x38, 0xa4, 0x1d, 0x28, 0x33, 0xa3, 0x24, 0x1d, 0x20, 0x90,
+0x38, 0xa4, 0x1c, 0x50, 0x33, 0x88, 0x24, 0x1c, 0x48, 0x90, 0x60, 0x90,
+0x38, 0xa4, 0x1b, 0x78, 0x33, 0x6d, 0x24, 0x1b, 0x70, 0x90, 0x38, 0xa4,
+0x1a, 0x88, 0x33, 0x4f, 0x24, 0x1a, 0x80, 0xe4, 0xe2, 0x97, 0xc0, 0x3a,
+0x62, 0x92, 0xd0, 0x99, 0x50, 0x02, 0x80, 0x90, 0xa0, 0x90, 0x50, 0x90,
+0x28, 0x80, 0x33, 0x4a, 0x24, 0x1a, 0x48, 0x90, 0x28, 0x80, 0x33, 0x46,
+0x24, 0x1a, 0x28, 0x90, 0x50, 0x90, 0x28, 0x80, 0x33, 0x42, 0x24, 0x1a,
+0x08, 0x90, 0x28, 0x80, 0x33, 0x3e, 0x24, 0x19, 0xe8, 0x90, 0xa0, 0x90,
+0x50, 0x90, 0x28, 0x80, 0x33, 0x47, 0x24, 0x1a, 0x40, 0x90, 0x28, 0x80,
+0x33, 0x43, 0x24, 0x1a, 0x20, 0x90, 0x50, 0x90, 0x28, 0x80, 0x33, 0x3f,
+0x24, 0x1a, 0x00, 0x90, 0x28, 0x80, 0x33, 0x3b, 0x24, 0x19, 0xe0, 0xec,
+0xe2, 0x96, 0x61, 0xe8, 0x00, 0x3a, 0x5c, 0x88, 0x00, 0x78, 0x10, 0x10,
+0x10, 0x10, 0x90, 0x28, 0x80, 0x33, 0x39, 0x24, 0x19, 0xd0, 0xec, 0xe2,
+0x94, 0xe1, 0xe6, 0x00, 0x3a, 0x56, 0xe5, 0xa2, 0x1e, 0x00, 0x38, 0x74,
+0xa0, 0x41, 0xe0, 0xa8, 0x2c, 0x30, 0x41, 0xa8, 0xa0, 0x16, 0x68, 0xa0,
+0x14, 0x50, 0xa0, 0x0a, 0x28, 0x95, 0x10, 0x92, 0x70, 0x91, 0x20, 0x90,
+0x90, 0x90, 0x48, 0x80, 0xe1, 0xe0, 0x9a, 0xc0, 0x32, 0x72, 0x80, 0xe1,
+0xe0, 0x9a, 0x80, 0x32, 0x70, 0x90, 0x48, 0x80, 0xe1, 0xe0, 0x9a, 0x40,
+0x32, 0x6e, 0x80, 0xe1, 0xe0, 0x9a, 0x00, 0x32, 0x6c, 0x90, 0xb0, 0x90,
+0x58, 0xa4, 0x0b, 0xf8, 0xe1, 0xe0, 0xab, 0x40, 0x32, 0xb4, 0xa4, 0x0b,
+0xf0, 0xe1, 0xe0, 0xab, 0x00, 0x32, 0xb2, 0x90, 0x48, 0x80, 0xe1, 0xe0,
+0xaa, 0xc0, 0x32, 0xb0, 0xa4, 0x0b, 0xe8, 0xe1, 0xe0, 0xaa, 0x80, 0x32,
+0xae, 0x91, 0x50, 0x90, 0xb0, 0x90, 0x58, 0xa4, 0x0d, 0x18, 0xe1, 0xe0,
+0xcc, 0x40, 0x33, 0x38, 0xa4, 0x0d, 0x10, 0xe1, 0xe0, 0xcc, 0x00, 0x33,
+0x36, 0x90, 0x48, 0x80, 0xe1, 0xe0, 0xcb, 0xc0, 0x33, 0x34, 0xa4, 0x0d,
+0x08, 0xe1, 0xe0, 0xcb, 0x80, 0x33, 0x32, 0x90, 0xb0, 0x90, 0x58, 0xa4,
+0x0c, 0x88, 0xe1, 0xe0, 0xbb, 0xc0, 0x32, 0xf6, 0xa4, 0x0c, 0x80, 0xe1,
+0xe0, 0xbb, 0x80, 0x32, 0xf4, 0x90, 0x48, 0x80, 0xe1, 0xe0, 0xbb, 0x40,
+0x32, 0xf2, 0xa4, 0x0c, 0x78, 0xe1, 0xe0, 0xbb, 0x00, 0x32, 0xf0, 0x92,
+0x70, 0x91, 0x20, 0x90, 0x90, 0x90, 0x48, 0x80, 0xe1, 0xe0, 0x98, 0x40,
+0x32, 0x5d, 0x80, 0xe1, 0xe0, 0x98, 0x00, 0x32, 0x66, 0x90, 0x48, 0x80,
+0xe1, 0xe0, 0x97, 0xc0, 0x32, 0x64, 0x80, 0xe1, 0xe0, 0x97, 0x80, 0x32,
+0x62, 0x90, 0xb0, 0x90, 0x58, 0xa4, 0x0b, 0xd0, 0xe1, 0xe0, 0xa8, 0xc0,
+0x32, 0x9f, 0xa4, 0x0b, 0xe0, 0xe1, 0xe0, 0xa8, 0x80, 0x32, 0xa8, 0x90,
+0x48, 0x80, 0xe1, 0xe0, 0xa8, 0x40, 0x32, 0xa6, 0xa4, 0x0b, 0xd8, 0xe1,
+0xe0, 0xa8, 0x00, 0x32, 0xa4, 0x91, 0x50, 0x90, 0xb0, 0x90, 0x58, 0xa4,
+0x0c, 0xf0, 0xe1, 0xe0, 0xc9, 0xc0, 0x33, 0x23, 0xa4, 0x0d, 0x00, 0xe1,
+0xe0, 0xc9, 0x80, 0x33, 0x2c, 0x90, 0x48, 0x80, 0xe1, 0xe0, 0xc9, 0x40,
+0x33, 0x2a, 0xa4, 0x0c, 0xf8, 0xe1, 0xe0, 0xc9, 0x00, 0x33, 0x28, 0x90,
+0xb0, 0x90, 0x58, 0xa4, 0x0c, 0x60, 0xe1, 0xe0, 0xb9, 0x40, 0x32, 0xe1,
+0xa4, 0x0c, 0x70, 0xe1, 0xe0, 0xb9, 0x00, 0x32, 0xea, 0x90, 0x48, 0x80,
+0xe1, 0xe0, 0xb8, 0xc0, 0x32, 0xe8, 0xa4, 0x0c, 0x68, 0xe1, 0xe0, 0xb8,
+0x80, 0x32, 0xe6, 0x95, 0x10, 0x92, 0x70, 0x91, 0x20, 0x90, 0x90, 0x90,
+0x48, 0x80, 0xe1, 0xe0, 0x95, 0x80, 0x32, 0x52, 0x80, 0xe1, 0xe0, 0x95,
+0x40, 0x32, 0x5b, 0x90, 0x48, 0x80, 0xe1, 0xe0, 0x95, 0x00, 0x32, 0x59,
+0x80, 0xe1, 0xe0, 0x94, 0xc0, 0x32, 0x57, 0x90, 0xb0, 0x90, 0x58, 0xa4,
+0x0b, 0xb8, 0xe1, 0xe0, 0xa6, 0x00, 0x32, 0x94, 0xa4, 0x0b, 0xc8, 0xe1,
+0xe0, 0xa5, 0xc0, 0x32, 0x9d, 0x90, 0x48, 0x80, 0xe1, 0xe0, 0xa5, 0x80,
+0x32, 0x9b, 0xa4, 0x0b, 0xc0, 0xe1, 0xe0, 0xa5, 0x40, 0x32, 0x99, 0x91,
+0x50, 0x90, 0xb0, 0x90, 0x58, 0xa4, 0x0c, 0xd8, 0xe1, 0xe0, 0xc7, 0x00,
+0x33, 0x18, 0xa4, 0x0c, 0xe8, 0xe1, 0xe0, 0xc6, 0xc0, 0x33, 0x21, 0x90,
+0x48, 0x80, 0xe1, 0xe0, 0xc6, 0x80, 0x33, 0x1f, 0xa4, 0x0c, 0xe0, 0xe1,
+0xe0, 0xc6, 0x40, 0x33, 0x1d, 0x90, 0xb0, 0x90, 0x58, 0xa4, 0x0c, 0x48,
+0xe1, 0xe0, 0xb6, 0x80, 0x32, 0xd6, 0xa4, 0x0c, 0x58, 0xe1, 0xe0, 0xb6,
+0x40, 0x32, 0xdf, 0x90, 0x48, 0x80, 0xe1, 0xe0, 0xb6, 0x00, 0x32, 0xdd,
+0xa4, 0x0c, 0x50, 0xe1, 0xe0, 0xb5, 0xc0, 0x32, 0xdb, 0x92, 0x70, 0x91,
+0x20, 0x90, 0x90, 0x90, 0x48, 0x80, 0xe1, 0xe0, 0x92, 0xc0, 0x32, 0x47,
+0x80, 0xe1, 0xe0, 0x92, 0x80, 0x32, 0x50, 0x90, 0x48, 0x80, 0xe1, 0xe0,
+0x92, 0x40, 0x32, 0x4e, 0x80, 0xe1, 0xe0, 0x92, 0x00, 0x32, 0x4c, 0x90,
+0xb0, 0x90, 0x58, 0xa4, 0x0b, 0xa0, 0xe1, 0xe0, 0xa3, 0x40, 0x32, 0x89,
+0xa4, 0x0b, 0xb0, 0xe1, 0xe0, 0xa3, 0x00, 0x32, 0x92, 0x90, 0x48, 0x80,
+0xe1, 0xe0, 0xa2, 0xc0, 0x32, 0x90, 0xa4, 0x0b, 0xa8, 0xe1, 0xe0, 0xa2,
+0x80, 0x32, 0x8e, 0x91, 0x50, 0x90, 0xb0, 0x90, 0x58, 0xa4, 0x0c, 0xc0,
+0xe1, 0xe0, 0xc4, 0x40, 0x33, 0x0d, 0xa4, 0x0c, 0xd0, 0xe1, 0xe0, 0xc4,
+0x00, 0x33, 0x16, 0x90, 0x48, 0x80, 0xe1, 0xe0, 0xc3, 0xc0, 0x33, 0x14,
+0xa4, 0x0c, 0xc8, 0xe1, 0xe0, 0xc3, 0x80, 0x33, 0x12, 0x90, 0xb0, 0x90,
+0x58, 0xa4, 0x0c, 0x30, 0xe1, 0xe0, 0xb3, 0xc0, 0x32, 0xcb, 0xa4, 0x0c,
+0x40, 0xe1, 0xe0, 0xb3, 0x80, 0x32, 0xd4, 0x90, 0x48, 0x80, 0xe1, 0xe0,
+0xb3, 0x40, 0x32, 0xd2, 0xa4, 0x0c, 0x38, 0xe1, 0xe0, 0xb3, 0x00, 0x32,
+0xd0, 0x10, 0x10, 0x91, 0x40, 0x10, 0x10, 0x10, 0x10, 0x90, 0x90, 0x90,
+0x48, 0x80, 0xe1, 0xe0, 0x8a, 0x80, 0x32, 0x26, 0x80, 0xe1, 0xe0, 0x8a,
+0x40, 0x32, 0x2f, 0x90, 0x48, 0x80, 0xe1, 0xe0, 0x8a, 0x00, 0x32, 0x2d,
+0x80, 0xe1, 0xe0, 0x89, 0xc0, 0x32, 0x2b, 0x90, 0x60, 0x90, 0x30, 0x60,
+0xa0, 0x32, 0xc0, 0x60, 0xa0, 0x32, 0x80, 0x90, 0x30, 0x60, 0xa0, 0x32,
+0x40, 0x60, 0xa0, 0x32, 0x00, 0xa0, 0x0f, 0xe0, 0xa0, 0x0a, 0x28, 0x95,
+0x10, 0x92, 0x70, 0x91, 0x20, 0x90, 0x90, 0x90, 0x48, 0x80, 0xe1, 0xe0,
+0x90, 0x00, 0x32, 0x3c, 0x80, 0xe1, 0xe0, 0x8f, 0xc0, 0x32, 0x45, 0x90,
+0x48, 0x80, 0xe1, 0xe0, 0x8f, 0x80, 0x32, 0x43, 0x80, 0xe1, 0xe0, 0x8f,
+0x40, 0x32, 0x41, 0x90, 0xb0, 0x90, 0x58, 0xa4, 0x0b, 0x88, 0xe1, 0xe0,
+0xa0, 0x80, 0x32, 0x7e, 0xa4, 0x0b, 0x98, 0xe1, 0xe0, 0xa0, 0x40, 0x32,
+0x87, 0x90, 0x48, 0x80, 0xe1, 0xe0, 0xa0, 0x00, 0x32, 0x85, 0xa4, 0x0b,
+0x90, 0xe1, 0xe0, 0x9f, 0xc0, 0x32, 0x83, 0x91, 0x50, 0x90, 0xb0, 0x90,
+0x58, 0xa4, 0x0c, 0xa8, 0xe1, 0xe0, 0xc1, 0x80, 0x33, 0x02, 0xa4, 0x0c,
+0xb8, 0xe1, 0xe0, 0xc1, 0x40, 0x33, 0x0b, 0x90, 0x48, 0x80, 0xe1, 0xe0,
+0xc1, 0x00, 0x33, 0x09, 0xa4, 0x0c, 0xb0, 0xe1, 0xe0, 0xc0, 0xc0, 0x33,
+0x07, 0x90, 0xb0, 0x90, 0x58, 0xa4, 0x0c, 0x18, 0xe1, 0xe0, 0xb1, 0x00,
+0x32, 0xc0, 0xa4, 0x0c, 0x28, 0xe1, 0xe0, 0xb0, 0xc0, 0x32, 0xc9, 0x90,
+0x48, 0x80, 0xe1, 0xe0, 0xb0, 0x80, 0x32, 0xc7, 0xa4, 0x0c, 0x20, 0xe1,
+0xe0, 0xb0, 0x40, 0x32, 0xc5, 0x92, 0x70, 0x91, 0x20, 0x90, 0x90, 0x90,
+0x48, 0x80, 0xe1, 0xe0, 0x8d, 0x40, 0x32, 0x31, 0x80, 0xe1, 0xe0, 0x8d,
+0x00, 0x32, 0x3a, 0x90, 0x48, 0x80, 0xe1, 0xe0, 0x8c, 0xc0, 0x32, 0x38,
+0x80, 0xe1, 0xe0, 0x8c, 0x80, 0x32, 0x36, 0x90, 0xb0, 0x90, 0x58, 0xa4,
+0x0b, 0x70, 0xe1, 0xe0, 0x9d, 0xc0, 0x32, 0x73, 0xa4, 0x0b, 0x80, 0xe1,
+0xe0, 0x9d, 0x80, 0x32, 0x7c, 0x90, 0x48, 0x80, 0xe1, 0xe0, 0x9d, 0x40,
+0x32, 0x7a, 0xa4, 0x0b, 0x78, 0xe1, 0xe0, 0x9d, 0x00, 0x32, 0x78, 0x91,
+0x50, 0x90, 0xb0, 0x90, 0x58, 0xa4, 0x0c, 0x90, 0xe1, 0xe0, 0xbe, 0xc0,
+0x32, 0xf7, 0xa4, 0x0c, 0xa0, 0xe1, 0xe0, 0xbe, 0x80, 0x33, 0x00, 0x90,
+0x48, 0x80, 0xe1, 0xe0, 0xbe, 0x40, 0x32, 0xfe, 0xa4, 0x0c, 0x98, 0xe1,
+0xe0, 0xbe, 0x00, 0x32, 0xfc, 0x90, 0xb0, 0x90, 0x58, 0xa4, 0x0c, 0x00,
+0xe1, 0xe0, 0xae, 0x40, 0x32, 0xb5, 0xa4, 0x0c, 0x10, 0xe1, 0xe0, 0xae,
+0x00, 0x32, 0xbe, 0x90, 0x48, 0x80, 0xe1, 0xe0, 0xad, 0xc0, 0x32, 0xbc,
+0xa4, 0x0c, 0x08, 0xe1, 0xe0, 0xad, 0x80, 0x32, 0xba, 0x10, 0x10, 0x93,
+0x60, 0x92, 0x40, 0x91, 0x20, 0x90, 0x90, 0x80, 0xd1, 0xc2, 0x40, 0xe1,
+0xa0, 0x4b, 0xc0, 0x31, 0x36, 0xe1, 0xa0, 0x40, 0x40, 0x30, 0xfc, 0x80,
+0xd1, 0xc2, 0x40, 0xe1, 0xa0, 0x4b, 0x80, 0x31, 0x34, 0xe1, 0xa0, 0x40,
+0x00, 0x31, 0x06, 0x90, 0x90, 0x80, 0xd1, 0xc2, 0x40, 0xe1, 0xa0, 0x4b,
+0x40, 0x31, 0x32, 0xe1, 0xa0, 0x3f, 0xc0, 0x31, 0x04, 0x80, 0xd1, 0xc2,
+0x40, 0xe1, 0xa0, 0x4b, 0x00, 0x31, 0x30, 0xe1, 0xa0, 0x3f, 0x80, 0x31,
+0x02, 0x90, 0x90, 0x90, 0x48, 0x80, 0xe3, 0xa0, 0x49, 0x40, 0x31, 0x20,
+0x80, 0xe3, 0xa0, 0x49, 0x00, 0x31, 0x2a, 0x90, 0x48, 0x80, 0xe3, 0xa0,
+0x48, 0xc0, 0x31, 0x28, 0x80, 0xe3, 0xa0, 0x48, 0x80, 0x31, 0x26, 0x91,
+0x20, 0x90, 0x90, 0x90, 0x48, 0x80, 0xe3, 0xa0, 0x46, 0x40, 0x31, 0x08,
+0x80, 0xe3, 0xa0, 0x46, 0x00, 0x31, 0x1e, 0x90, 0x48, 0x80, 0xe3, 0xa0,
+0x45, 0xc0, 0x31, 0x1c, 0x80, 0xe3, 0xa0, 0x45, 0x80, 0x31, 0x1a, 0x90,
+0x90, 0x90, 0x48, 0x80, 0xe3, 0xa0, 0x43, 0xc0, 0x31, 0x0a, 0x80, 0xe3,
+0xa0, 0x43, 0x80, 0x31, 0x14, 0x90, 0x48, 0x80, 0xe3, 0xa0, 0x43, 0x40,
+0x31, 0x12, 0x80, 0xe3, 0xa0, 0x43, 0x00, 0x31, 0x10, 0x94, 0x88, 0x80,
+0x92, 0x40, 0x91, 0x20, 0x90, 0x90, 0x90, 0x48, 0x80, 0xe3, 0xa0, 0x6c,
+0x80, 0x31, 0xb9, 0x80, 0xe3, 0xa0, 0x6c, 0x40, 0x31, 0xb7, 0x90, 0x48,
+0x80, 0xe3, 0xa0, 0x6c, 0x00, 0x31, 0xb5, 0x80, 0xe3, 0xa0, 0x6b, 0xc0,
+0x31, 0xb3, 0x90, 0x90, 0x90, 0x48, 0x80, 0xe3, 0xa0, 0x6f, 0x40, 0x31,
+0xc4, 0x80, 0xe3, 0xa0, 0x6f, 0x00, 0x31, 0xc2, 0x90, 0x48, 0x80, 0xe3,
+0xa0, 0x6e, 0xc0, 0x31, 0xc0, 0x80, 0xe3, 0xa0, 0x6e, 0x80, 0x31, 0xbe,
+0x91, 0x20, 0x90, 0x90, 0x90, 0x48, 0x80, 0xe3, 0xa0, 0x74, 0xc0, 0x31,
+0xda, 0x80, 0xe3, 0xa0, 0x74, 0x80, 0x31, 0xd8, 0x90, 0x48, 0x80, 0xe3,
+0xa0, 0x74, 0x40, 0x31, 0xd6, 0x80, 0xe3, 0xa0, 0x74, 0x00, 0x31, 0xd4,
+0x90, 0x90, 0x90, 0x48, 0x80, 0xe3, 0xa0, 0x72, 0x00, 0x31, 0xcf, 0x80,
+0xe3, 0xa0, 0x71, 0xc0, 0x31, 0xcd, 0x90, 0x48, 0x80, 0xe3, 0xa0, 0x71,
+0x80, 0x31, 0xcb, 0x80, 0xe3, 0xa0, 0x71, 0x40, 0x31, 0xc9, 0x80, 0x10,
+0x10, 0x10, 0x10, 0x90, 0x90, 0x90, 0x48, 0x80, 0xe3, 0xa0, 0x6a, 0x00,
+0x31, 0xa4, 0x80, 0xe3, 0xa0, 0x69, 0xc0, 0x31, 0xad, 0x90, 0x48, 0x80,
+0xe3, 0xa0, 0x69, 0x80, 0x31, 0xab, 0x80, 0xe3, 0xa0, 0x69, 0x40, 0x31,
+0xa9, 0xa0, 0x0b, 0x90, 0xa0, 0x0a, 0xc8, 0x95, 0x60, 0x92, 0xb0, 0x91,
+0x40, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x31, 0xef, 0x80, 0x31,
+0xee, 0x10, 0x10, 0x80, 0x31, 0xed, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x0a,
+0x48, 0x32, 0x01, 0xa4, 0x0a, 0x40, 0x32, 0x00, 0x10, 0x10, 0xa4, 0x0a,
+0x38, 0x31, 0xff, 0x90, 0xb8, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x0b, 0x68,
+0x32, 0x25, 0xa4, 0x0b, 0x60, 0x32, 0x24, 0x10, 0x10, 0xa4, 0x0b, 0x58,
+0x32, 0x23, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x0a, 0xd8, 0x32, 0x13, 0xa4,
+0x0a, 0xd0, 0x32, 0x12, 0x10, 0x10, 0xa4, 0x0a, 0xc8, 0x32, 0x11, 0x91,
+0x40, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x31, 0xea, 0x80, 0x31,
+0xec, 0x10, 0x10, 0x80, 0x31, 0xeb, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x0a,
+0x20, 0x31, 0xfc, 0xa4, 0x0a, 0x30, 0x31, 0xfe, 0x10, 0x10, 0xa4, 0x0a,
+0x28, 0x31, 0xfd, 0x90, 0xb8, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x0b, 0x40,
+0x32, 0x20, 0xa4, 0x0b, 0x50, 0x32, 0x22, 0x10, 0x10, 0xa4, 0x0b, 0x48,
+0x32, 0x21, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x0a, 0xb0, 0x32, 0x0e, 0xa4,
+0x0a, 0xc0, 0x32, 0x10, 0x10, 0x10, 0xa4, 0x0a, 0xb8, 0x32, 0x0f, 0x92,
+0xb0, 0x91, 0x40, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x31, 0xe7,
+0x80, 0x31, 0xe9, 0x10, 0x10, 0x80, 0x31, 0xe8, 0x90, 0x70, 0x90, 0x38,
+0xa4, 0x0a, 0x08, 0x31, 0xf9, 0xa4, 0x0a, 0x18, 0x31, 0xfb, 0x10, 0x10,
+0xa4, 0x0a, 0x10, 0x31, 0xfa, 0x90, 0xb8, 0x90, 0x70, 0x90, 0x38, 0xa4,
+0x0b, 0x28, 0x32, 0x1d, 0xa4, 0x0b, 0x38, 0x32, 0x1f, 0x10, 0x10, 0xa4,
+0x0b, 0x30, 0x32, 0x1e, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x0a, 0x98, 0x32,
+0x0b, 0xa4, 0x0a, 0xa8, 0x32, 0x0d, 0x10, 0x10, 0xa4, 0x0a, 0xa0, 0x32,
+0x0c, 0x91, 0x40, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x31, 0xe4,
+0x80, 0x31, 0xe6, 0x10, 0x10, 0x80, 0x31, 0xe5, 0x90, 0x70, 0x90, 0x38,
+0xa4, 0x09, 0xf0, 0x31, 0xf6, 0xa4, 0x0a, 0x00, 0x31, 0xf8, 0x10, 0x10,
+0xa4, 0x09, 0xf8, 0x31, 0xf7, 0x90, 0xb8, 0x90, 0x70, 0x90, 0x38, 0xa4,
+0x0b, 0x10, 0x32, 0x1a, 0xa4, 0x0b, 0x20, 0x32, 0x1c, 0x10, 0x10, 0xa4,
+0x0b, 0x18, 0x32, 0x1b, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x0a, 0x80, 0x32,
+0x08, 0xa4, 0x0a, 0x90, 0x32, 0x0a, 0x10, 0x10, 0xa4, 0x0a, 0x88, 0x32,
+0x09, 0x10, 0x10, 0x80, 0x10, 0x10, 0x10, 0x10, 0x90, 0x50, 0x90, 0x28,
+0x80, 0x31, 0xdb, 0x80, 0x31, 0xdd, 0x10, 0x10, 0x80, 0x31, 0xdc, 0x80,
+0x95, 0x60, 0x92, 0xb0, 0x91, 0x40, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28,
+0x80, 0x31, 0xe1, 0x80, 0x31, 0xe3, 0x10, 0x10, 0x80, 0x31, 0xe2, 0x90,
+0x70, 0x90, 0x38, 0xa4, 0x09, 0xd8, 0x31, 0xf3, 0xa4, 0x09, 0xe8, 0x31,
+0xf5, 0x10, 0x10, 0xa4, 0x09, 0xe0, 0x31, 0xf4, 0x90, 0xb8, 0x90, 0x70,
+0x90, 0x38, 0xa4, 0x0a, 0xf8, 0x32, 0x17, 0xa4, 0x0b, 0x08, 0x32, 0x19,
+0x10, 0x10, 0xa4, 0x0b, 0x00, 0x32, 0x18, 0x90, 0x70, 0x90, 0x38, 0xa4,
+0x0a, 0x68, 0x32, 0x05, 0xa4, 0x0a, 0x78, 0x32, 0x07, 0x10, 0x10, 0xa4,
+0x0a, 0x70, 0x32, 0x06, 0x91, 0x40, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28,
+0x80, 0x31, 0xde, 0x80, 0x31, 0xe0, 0x10, 0x10, 0x80, 0x31, 0xdf, 0x90,
+0x70, 0x90, 0x38, 0xa4, 0x09, 0xc0, 0x31, 0xf0, 0xa4, 0x09, 0xd0, 0x31,
+0xf2, 0x10, 0x10, 0xa4, 0x09, 0xc8, 0x31, 0xf1, 0x90, 0xb8, 0x90, 0x70,
+0x90, 0x38, 0xa4, 0x0a, 0xe0, 0x32, 0x14, 0xa4, 0x0a, 0xf0, 0x32, 0x16,
+0x10, 0x10, 0xa4, 0x0a, 0xe8, 0x32, 0x15, 0x90, 0x70, 0x90, 0x38, 0xa4,
+0x0a, 0x50, 0x32, 0x02, 0xa4, 0x0a, 0x60, 0x32, 0x04, 0x10, 0x10, 0xa4,
+0x0a, 0x58, 0x32, 0x03, 0x10, 0x10, 0x92, 0x40, 0x91, 0x20, 0x90, 0x90,
+0x90, 0x48, 0x80, 0xe3, 0xa0, 0x3c, 0xc0, 0x30, 0xfa, 0x80, 0xe3, 0xa0,
+0x3c, 0x80, 0x30, 0xf8, 0x90, 0x48, 0x80, 0xe3, 0xa0, 0x3c, 0x40, 0x30,
+0xf6, 0x80, 0xe3, 0xa0, 0x3c, 0x00, 0x30, 0xf4, 0x90, 0x90, 0x90, 0x48,
+0x80, 0xe3, 0xa0, 0x3a, 0x40, 0x30, 0xe4, 0x80, 0xe3, 0xa0, 0x3a, 0x00,
+0x30, 0xee, 0x90, 0x48, 0x80, 0xe3, 0xa0, 0x39, 0xc0, 0x30, 0xec, 0x80,
+0xe3, 0xa0, 0x39, 0x80, 0x30, 0xea, 0x91, 0x20, 0x90, 0x90, 0x90, 0x48,
+0x80, 0xe3, 0xa0, 0x37, 0x40, 0x30, 0xcc, 0x80, 0xe3, 0xa0, 0x37, 0x00,
+0x30, 0xe2, 0x90, 0x48, 0x80, 0xe3, 0xa0, 0x36, 0xc0, 0x30, 0xe0, 0x80,
+0xe3, 0xa0, 0x36, 0x80, 0x30, 0xde, 0x90, 0x90, 0x90, 0x48, 0x80, 0xe3,
+0xa0, 0x34, 0xc0, 0x30, 0xce, 0x80, 0xe3, 0xa0, 0x34, 0x80, 0x30, 0xd8,
+0x90, 0x48, 0x80, 0xe3, 0xa0, 0x34, 0x40, 0x30, 0xd6, 0x80, 0xe3, 0xa0,
+0x34, 0x00, 0x30, 0xd4, 0xc3, 0xc0, 0x30, 0x42, 0x9d, 0x18, 0x07, 0xf0,
+0x91, 0xc0, 0x90, 0xf0, 0x10, 0x10, 0x80, 0x88, 0x00, 0x80, 0x90, 0x50,
+0x90, 0x28, 0x80, 0x37, 0x1c, 0x80, 0x37, 0x1d, 0x81, 0x37, 0x13, 0xd0,
+0x41, 0x80, 0x24, 0x39, 0xb0, 0x24, 0x39, 0xb8, 0x10, 0x10, 0x80, 0x90,
+0x58, 0x80, 0x90, 0x28, 0x24, 0x38, 0xb0, 0x24, 0x38, 0xb8, 0x90, 0x30,
+0x80, 0x24, 0x38, 0x60, 0x80, 0x24, 0x38, 0x58, 0x92, 0x68, 0x91, 0x00,
+0x80, 0x90, 0x90, 0x90, 0x30, 0x80, 0x24, 0x39, 0x20, 0x90, 0x38, 0xa4,
+0x39, 0x18, 0x37, 0x2a, 0x80, 0x37, 0x29, 0x80, 0x90, 0x28, 0x80, 0x37,
+0x33, 0xa4, 0x39, 0x00, 0x37, 0x32, 0x80, 0x90, 0xc0, 0x90, 0x60, 0x90,
+0x28, 0x80, 0x37, 0x2d, 0xa4, 0x39, 0x10, 0x37, 0x2c, 0x90, 0x28, 0x80,
+0x37, 0x28, 0xa4, 0x39, 0x08, 0x37, 0x27, 0x90, 0x50, 0x90, 0x28, 0x80,
+0x37, 0x31, 0x80, 0x37, 0x30, 0x90, 0x28, 0x24, 0x39, 0xa8, 0x24, 0x39,
+0xa0, 0x90, 0x58, 0x80, 0x10, 0x10, 0x80, 0x10, 0x10, 0x80, 0x37, 0x1f,
+0x80, 0x90, 0x40, 0x10, 0x10, 0x80, 0x24, 0x38, 0x70, 0x80, 0x10, 0x10,
+0x80, 0x37, 0x1e, 0x91, 0xb8, 0x91, 0x60, 0x90, 0xe0, 0x80, 0x90, 0x78,
+0x90, 0x50, 0x90, 0x28, 0x80, 0x37, 0x1a, 0x80, 0x37, 0x1b, 0x81, 0x37,
+0x12, 0x10, 0x10, 0x90, 0x28, 0x24, 0x38, 0x80, 0x24, 0x38, 0x78, 0x81,
+0x90, 0x50, 0x90, 0x28, 0x80, 0x37, 0x18, 0x80, 0x37, 0x19, 0x81, 0x37,
+0x11, 0x83, 0x90, 0x28, 0x24, 0x38, 0xa0, 0x24, 0x38, 0xa8, 0x90, 0xe8,
+0x81, 0x90, 0x88, 0x90, 0x38, 0x10, 0x10, 0x80, 0x37, 0x2b, 0x90, 0x28,
+0x80, 0x37, 0x26, 0x80, 0x37, 0x25, 0x80, 0x90, 0x28, 0x80, 0x37, 0x2f,
+0x80, 0x37, 0x2e, 0x82, 0x10, 0x10, 0x80, 0x24, 0x38, 0x68, 0x97, 0x10,
+0x9e, 0x10, 0x06, 0x98, 0x93, 0x00, 0x91, 0x80, 0x90, 0xc0, 0x90, 0x60,
+0x90, 0x38, 0xa4, 0x04, 0x80, 0x30, 0x91, 0x24, 0x04, 0x78, 0x90, 0x38,
+0xa4, 0x05, 0x10, 0x30, 0xa3, 0x24, 0x05, 0x08, 0x90, 0x60, 0x90, 0x38,
+0xa4, 0x06, 0x30, 0x30, 0xc7, 0x24, 0x06, 0x28, 0x90, 0x38, 0xa4, 0x05,
+0xa0, 0x30, 0xb5, 0x24, 0x05, 0x98, 0x90, 0xc0, 0x90, 0x60, 0x90, 0x38,
+0xa4, 0x04, 0x70, 0x30, 0x8c, 0x24, 0x04, 0x68, 0x90, 0x38, 0xa4, 0x05,
+0x00, 0x30, 0x9e, 0x24, 0x04, 0xf8, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x06,
+0x20, 0x30, 0xc2, 0x24, 0x06, 0x18, 0x90, 0x38, 0xa4, 0x05, 0x90, 0x30,
+0xb0, 0x24, 0x05, 0x88, 0x91, 0x80, 0x90, 0xc0, 0x90, 0x60, 0x90, 0x38,
+0xa4, 0x04, 0x58, 0x30, 0x89, 0x24, 0x04, 0x50, 0x90, 0x38, 0xa4, 0x04,
+0xe8, 0x30, 0x9b, 0x24, 0x04, 0xe0, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x06,
+0x08, 0x30, 0xbf, 0x24, 0x06, 0x00, 0x90, 0x38, 0xa4, 0x05, 0x78, 0x30,
+0xad, 0x24, 0x05, 0x70, 0x90, 0xc0, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x04,
+0x40, 0x30, 0x86, 0x24, 0x04, 0x38, 0x90, 0x38, 0xa4, 0x04, 0xd0, 0x30,
+0x98, 0x24, 0x04, 0xc8, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x05, 0xf0, 0x30,
+0xbc, 0x24, 0x05, 0xe8, 0x90, 0x38, 0xa4, 0x05, 0x60, 0x30, 0xaa, 0x24,
+0x05, 0x58, 0x10, 0x10, 0x80, 0x10, 0x10, 0x10, 0x10, 0x90, 0x38, 0xa4,
+0x03, 0xf8, 0x30, 0x7d, 0x24, 0x03, 0xf0, 0xd7, 0x42, 0x00, 0xa4, 0x52,
+0x70, 0x3a, 0x50, 0xa4, 0x52, 0x50, 0x3a, 0x4c, 0x9f, 0x20, 0x08, 0xd0,
+0x93, 0x00, 0x91, 0x80, 0x90, 0xc0, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x04,
+0x28, 0x30, 0x83, 0x24, 0x04, 0x20, 0x90, 0x38, 0xa4, 0x04, 0xb8, 0x30,
+0x95, 0x24, 0x04, 0xb0, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x05, 0xd8, 0x30,
+0xb9, 0x24, 0x05, 0xd0, 0x90, 0x38, 0xa4, 0x05, 0x48, 0x30, 0xa7, 0x24,
+0x05, 0x40, 0x90, 0xc0, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x04, 0x10, 0x30,
+0x80, 0x24, 0x04, 0x08, 0x90, 0x38, 0xa4, 0x04, 0xa0, 0x30, 0x92, 0x24,
+0x04, 0x98, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x05, 0xc0, 0x30, 0xb6, 0x24,
+0x05, 0xb8, 0x90, 0x38, 0xa4, 0x05, 0x30, 0x30, 0xa4, 0x24, 0x05, 0x28,
+0x10, 0x10, 0x92, 0x00, 0x91, 0x00, 0x90, 0x80, 0x90, 0x40, 0xe3, 0xe0,
+0x1a, 0x80, 0x30, 0x71, 0xe3, 0xe0, 0x1a, 0x40, 0x30, 0x6f, 0x90, 0x40,
+0xe3, 0xe0, 0x1a, 0x00, 0x30, 0x6d, 0xe3, 0xe0, 0x19, 0xc0, 0x30, 0x6b,
+0x90, 0x80, 0x90, 0x40, 0xe3, 0xe0, 0x18, 0x00, 0x30, 0x5b, 0xe3, 0xe0,
+0x17, 0xc0, 0x30, 0x65, 0x90, 0x40, 0xe3, 0xe0, 0x17, 0x80, 0x30, 0x63,
+0xe3, 0xe0, 0x17, 0x40, 0x30, 0x61, 0x91, 0x00, 0x90, 0x80, 0x90, 0x40,
+0xe3, 0xe0, 0x15, 0x00, 0x30, 0x43, 0xe3, 0xe0, 0x14, 0xc0, 0x30, 0x59,
+0x90, 0x40, 0xe3, 0xe0, 0x14, 0x80, 0x30, 0x57, 0xe3, 0xe0, 0x14, 0x40,
+0x30, 0x55, 0x90, 0x80, 0x90, 0x40, 0xe3, 0xe0, 0x12, 0x80, 0x30, 0x45,
+0xe3, 0xe0, 0x12, 0x40, 0x30, 0x4f, 0x90, 0x40, 0xe3, 0xe0, 0x12, 0x00,
+0x30, 0x4d, 0xe3, 0xe0, 0x11, 0xc0, 0x30, 0x4b, 0x91, 0x48, 0x80, 0x90,
+0xa0, 0x90, 0x50, 0x90, 0x28, 0x80, 0x30, 0x76, 0x24, 0x03, 0xa8, 0x90,
+0x28, 0x80, 0x30, 0x78, 0x24, 0x03, 0xb8, 0x90, 0x50, 0x90, 0x28, 0x80,
+0x30, 0x7c, 0x24, 0x03, 0xd8, 0x90, 0x28, 0x80, 0x30, 0x7a, 0x24, 0x03,
+0xc8, 0x80, 0x10, 0x10, 0x10, 0x10, 0x90, 0x28, 0x80, 0x30, 0x73, 0x24,
+0x03, 0xa0, 0xd7, 0x42, 0x00, 0xa4, 0x52, 0x78, 0x3a, 0x51, 0xa4, 0x52,
+0x58, 0x3a, 0x4d, 0xa0, 0x14, 0x68, 0xa0, 0x10, 0x90, 0xa0, 0x0c, 0x60,
+0x9e, 0x88, 0x09, 0xd0, 0x94, 0xf0, 0x90, 0xb0, 0x88, 0x00, 0x68, 0x84,
+0x10, 0x10, 0xc9, 0xe2, 0x15, 0x00, 0x85, 0x38, 0x70, 0xcb, 0x62, 0x0d,
+0xc0, 0x85, 0x38, 0x46, 0x9a, 0x00, 0x03, 0xf8, 0x91, 0x98, 0x80, 0x91,
+0x10, 0x90, 0xa0, 0x90, 0x68, 0x90, 0x20, 0x3d, 0x98, 0xc9, 0xe3, 0x65,
+0x80, 0x85, 0x38, 0x6e, 0xa4, 0x6c, 0xa0, 0x3d, 0x95, 0x90, 0x38, 0xa4,
+0x6c, 0x68, 0x3d, 0x8e, 0xa4, 0x6c, 0x58, 0x3d, 0x8c, 0x90, 0x48, 0x10,
+0x10, 0xa4, 0x6c, 0x20, 0x3d, 0x85, 0x10, 0x10, 0x80, 0x3d, 0x81, 0x81,
+0x10, 0x10, 0x80, 0xa4, 0x6b, 0xf0, 0x3d, 0x7f, 0x91, 0xb0, 0x91, 0x60,
+0x90, 0xe0, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x6c, 0x90, 0x3d, 0x93, 0xa4,
+0x6c, 0x80, 0x3d, 0x91, 0x90, 0x38, 0xa4, 0x6c, 0x48, 0x3d, 0x8a, 0xa4,
+0x6c, 0x38, 0x3d, 0x88, 0x90, 0x48, 0x10, 0x10, 0xa4, 0x6c, 0x10, 0x3d,
+0x83, 0x10, 0x10, 0x80, 0x3d, 0x80, 0x90, 0x28, 0x80, 0x3d, 0x79, 0x80,
+0x3d, 0x78, 0x81, 0x10, 0x10, 0x80, 0xa4, 0x6b, 0xe0, 0x3d, 0x7d, 0xcb,
+0x62, 0x0d, 0x80, 0x85, 0x38, 0x45, 0x90, 0xd8, 0x88, 0x00, 0x90, 0x84,
+0x90, 0x38, 0xc1, 0xc0, 0x85, 0x3d, 0x9b, 0xc9, 0xe2, 0x14, 0xc0, 0x85,
+0x38, 0x6c, 0xcb, 0x62, 0x0d, 0x40, 0x85, 0x38, 0x44, 0x88, 0x00, 0x68,
+0x84, 0x10, 0x10, 0xc9, 0xe2, 0x14, 0x80, 0x85, 0x38, 0x6a, 0xcb, 0x62,
+0x0d, 0x00, 0x85, 0x38, 0x43, 0x91, 0xf8, 0x90, 0xb0, 0x88, 0x00, 0x68,
+0x84, 0x10, 0x10, 0xc9, 0xe2, 0x14, 0x00, 0x85, 0x38, 0x66, 0xcb, 0x62,
+0x0c, 0x80, 0x85, 0x38, 0x41, 0x88, 0x01, 0x00, 0x90, 0xa0, 0x81, 0x90,
+0x70, 0x80, 0x90, 0x20, 0x3d, 0x8f, 0xc9, 0xe2, 0x13, 0xc0, 0x85, 0x38,
+0x64, 0x81, 0x3d, 0x86, 0x81, 0x10, 0x10, 0x80, 0xa4, 0x6b, 0xd0, 0x3d,
+0x7b, 0xcb, 0x62, 0x0c, 0x40, 0x85, 0x38, 0x40, 0x90, 0xb0, 0x88, 0x00,
+0x68, 0x84, 0x10, 0x10, 0xc9, 0xe2, 0x13, 0x80, 0x85, 0x38, 0x62, 0xcb,
+0x62, 0x0c, 0x00, 0x85, 0x38, 0x3f, 0x88, 0x00, 0x68, 0x84, 0x10, 0x10,
+0xc9, 0xe2, 0x13, 0x40, 0x85, 0x38, 0x60, 0xcb, 0x62, 0x0b, 0xc0, 0x85,
+0x38, 0x3e, 0x92, 0x38, 0x81, 0x91, 0x68, 0x91, 0x18, 0x90, 0x80, 0x90,
+0x40, 0x80, 0xa4, 0x6d, 0x50, 0x3d, 0xab, 0x80, 0xa4, 0x6d, 0x48, 0x3d,
+0xa8, 0x90, 0x28, 0x81, 0x3d, 0xa7, 0x90, 0x38, 0xa4, 0x6d, 0x28, 0x3d,
+0xa6, 0xa4, 0x6d, 0x18, 0x3d, 0xa4, 0x90, 0x28, 0x80, 0x3d, 0xa2, 0x80,
+0x3d, 0xa1, 0x80, 0x90, 0x40, 0x10, 0x10, 0x80, 0x24, 0x6d, 0x00, 0x10,
+0x10, 0x90, 0x38, 0xa4, 0x6c, 0xf0, 0x3d, 0x9f, 0xa4, 0x6c, 0xe0, 0x3d,
+0x9d, 0x90, 0x28, 0x80, 0x3d, 0x9a, 0x80, 0x3d, 0x99, 0x9a, 0xd0, 0x03,
+0xe0, 0x91, 0x60, 0x90, 0xb0, 0x88, 0x00, 0x68, 0x84, 0x10, 0x10, 0xc9,
+0xe2, 0x12, 0xc0, 0x85, 0x38, 0x5c, 0xcb, 0x62, 0x0b, 0x40, 0x85, 0x38,
+0x3c, 0x88, 0x00, 0x68, 0x84, 0x10, 0x10, 0xc9, 0xe2, 0x12, 0x80, 0x85,
+0x38, 0x5a, 0xcb, 0x62, 0x0b, 0x00, 0x85, 0x38, 0x3b, 0x90, 0xb0, 0x88,
+0x00, 0x68, 0x84, 0x10, 0x10, 0xc9, 0xe2, 0x12, 0x40, 0x85, 0x38, 0x58,
+0xcb, 0x62, 0x0a, 0xc0, 0x85, 0x38, 0x3a, 0x88, 0x00, 0x68, 0x84, 0x10,
+0x10, 0xc9, 0xe2, 0x12, 0x00, 0x85, 0x38, 0x56, 0xcb, 0x62, 0x0a, 0x80,
+0x85, 0x38, 0x39, 0x90, 0x90, 0x90, 0x48, 0xcb, 0xa2, 0x08, 0xc0, 0x85,
+0x38, 0x28, 0xcb, 0xa2, 0x08, 0x80, 0x85, 0x38, 0x27, 0x90, 0x48, 0xcb,
+0xa2, 0x08, 0x40, 0x85, 0x38, 0x26, 0xcb, 0xa2, 0x08, 0x00, 0x85, 0x38,
+0x25, 0xcb, 0xa3, 0x5d, 0x80, 0x80, 0x3d, 0x77, 0x92, 0x40, 0x91, 0x20,
+0x90, 0x90, 0x90, 0x48, 0x8c, 0x40, 0x78, 0x84, 0x24, 0x40, 0xf0, 0x8c,
+0x40, 0x70, 0x84, 0x24, 0x40, 0xe8, 0x90, 0x48, 0x8c, 0x40, 0x68, 0x84,
+0x24, 0x40, 0xe0, 0x8c, 0x40, 0x60, 0x84, 0x24, 0x40, 0xd8, 0x90, 0x90,
+0x90, 0x48, 0x8c, 0x40, 0x50, 0x84, 0x24, 0x40, 0xc8, 0x8c, 0x40, 0x48,
+0x84, 0x24, 0x40, 0xc0, 0x90, 0x48, 0x8c, 0x40, 0x40, 0x84, 0x24, 0x40,
+0xb8, 0x8c, 0x40, 0x38, 0x84, 0x24, 0x40, 0xb0, 0x91, 0x20, 0x90, 0x90,
+0x90, 0x48, 0x8c, 0x40, 0x28, 0x84, 0x24, 0x40, 0xa0, 0x8c, 0x40, 0x20,
+0x84, 0x24, 0x40, 0x98, 0x90, 0x48, 0x8c, 0x40, 0x18, 0x84, 0x24, 0x40,
+0x90, 0x8c, 0x40, 0x10, 0x84, 0x24, 0x40, 0x88, 0x90, 0x38, 0xa4, 0x3f,
+0xf8, 0x38, 0x00, 0xa4, 0x3f, 0xe8, 0x37, 0xfe, 0xa0, 0x0f, 0x50, 0xa0,
+0x09, 0x08, 0x9a, 0x30, 0x04, 0x40, 0x91, 0x90, 0x90, 0xc8, 0x98, 0x50,
+0x00, 0x80, 0xe5, 0x23, 0x5b, 0x80, 0x3d, 0x66, 0xe5, 0x23, 0x53, 0x80,
+0x3d, 0x62, 0xcb, 0x61, 0xfb, 0x00, 0x85, 0x37, 0xfb, 0x98, 0x50, 0x00,
+0x80, 0xe5, 0x23, 0x4b, 0x80, 0x3d, 0x26, 0xe5, 0x23, 0x43, 0x80, 0x3d,
+0x22, 0xcb, 0x61, 0xfa, 0xc0, 0x85, 0x37, 0xfa, 0x90, 0x48, 0xcb, 0xa1,
+0xfa, 0x80, 0x85, 0x37, 0xf9, 0xcb, 0xa1, 0xfa, 0x40, 0x85, 0x37, 0xf8,
+0x91, 0x90, 0x90, 0xc8, 0x98, 0x50, 0x00, 0x80, 0xe5, 0x23, 0x35, 0x80,
+0x3c, 0xee, 0xe5, 0x23, 0x29, 0x80, 0x3c, 0xbe, 0xcb, 0x61, 0xf9, 0xc0,
+0x85, 0x37, 0xf6, 0x98, 0x50, 0x00, 0x80, 0xe5, 0x23, 0x1d, 0x80, 0x3c,
+0x8e, 0xe5, 0x23, 0x11, 0x80, 0x3c, 0x5e, 0xcb, 0x61, 0xf9, 0x80, 0x85,
+0x37, 0xf5, 0x90, 0x48, 0xcb, 0xa1, 0xf9, 0x40, 0x85, 0x37, 0xf4, 0xcb,
+0xa1, 0xf9, 0x00, 0x85, 0x37, 0xf3, 0x92, 0x20, 0x91, 0x30, 0x90, 0xb8,
+0xd5, 0x03, 0x00, 0xc0, 0xc0, 0x81, 0x8c, 0x01, 0xa0, 0x84, 0x30, 0x3e,
+0xc0, 0xc0, 0x81, 0x8c, 0x01, 0x80, 0x84, 0x30, 0x3c, 0xd5, 0x02, 0x00,
+0xc0, 0xc0, 0x81, 0x30, 0x28, 0xc0, 0xc0, 0x81, 0x30, 0x24, 0x90, 0x78,
+0xd5, 0x02, 0x00, 0xc0, 0xc0, 0x81, 0x30, 0x1c, 0xc0, 0xc0, 0x81, 0x30,
+0x18, 0xd5, 0x02, 0x00, 0xc0, 0xc0, 0x81, 0x30, 0x10, 0xc0, 0xc0, 0x81,
+0x30, 0x0c, 0x91, 0x70, 0x90, 0xd8, 0xd5, 0x03, 0x80, 0xc8, 0xe3, 0x09,
+0x80, 0x81, 0x8c, 0x01, 0xc0, 0x84, 0x30, 0x40, 0xc8, 0xe3, 0x0b, 0x80,
+0x81, 0x8c, 0x01, 0x90, 0x84, 0x30, 0x3d, 0xd5, 0x02, 0x80, 0xc8, 0xe3,
+0x08, 0x80, 0x81, 0x30, 0x2c, 0xc8, 0xe3, 0x03, 0x00, 0x81, 0x30, 0x26,
+0x90, 0x98, 0xd5, 0x02, 0x80, 0xc8, 0xe2, 0xf8, 0x00, 0x81, 0x30, 0x20,
+0xc8, 0xe2, 0xfa, 0x00, 0x81, 0x30, 0x1a, 0xd5, 0x02, 0x80, 0xc8, 0xe2,
+0xf7, 0x00, 0x81, 0x30, 0x14, 0xc8, 0xe2, 0xf1, 0x80, 0x81, 0x30, 0x0e,
+0x9a, 0x30, 0x04, 0x40, 0x91, 0x90, 0x90, 0xc8, 0x98, 0x50, 0x00, 0x80,
+0xe5, 0x23, 0x4f, 0x80, 0x3d, 0x36, 0xe5, 0x23, 0x51, 0x80, 0x3d, 0x5a,
+0xcb, 0x61, 0xf8, 0x80, 0x85, 0x37, 0xf1, 0x98, 0x50, 0x00, 0x80, 0xe5,
+0x23, 0x3f, 0x80, 0x3c, 0xf6, 0xe5, 0x23, 0x41, 0x80, 0x3d, 0x1a, 0xcb,
+0x61, 0xf8, 0x40, 0x85, 0x37, 0xf0, 0x90, 0x48, 0xcb, 0xa1, 0xf8, 0x00,
+0x85, 0x37, 0xef, 0xcb, 0xa1, 0xf7, 0xc0, 0x85, 0x37, 0xee, 0x91, 0x90,
+0x90, 0xc8, 0x98, 0x50, 0x00, 0x80, 0xe5, 0x23, 0x31, 0x80, 0x3c, 0xde,
+0xe5, 0x23, 0x25, 0x80, 0x3c, 0xae, 0xcb, 0x61, 0xf6, 0x00, 0x85, 0x37,
+0xdd, 0x98, 0x50, 0x00, 0x80, 0xe5, 0x23, 0x19, 0x80, 0x3c, 0x7e, 0xe5,
+0x23, 0x0d, 0x80, 0x3c, 0x4e, 0xcb, 0x61, 0xf5, 0xc0, 0x85, 0x37, 0xdc,
+0x90, 0x48, 0xcb, 0xa1, 0xf5, 0x80, 0x85, 0x37, 0xdb, 0xcb, 0xa1, 0xf5,
+0x40, 0x85, 0x37, 0xda, 0x91, 0x00, 0x90, 0x80, 0x90, 0x40, 0xe5, 0x20,
+0x02, 0x40, 0x30, 0x0a, 0xe5, 0x20, 0x01, 0x80, 0x30, 0x07, 0x90, 0x40,
+0xe5, 0x20, 0x00, 0xc0, 0x30, 0x04, 0xe5, 0x20, 0x00, 0x00, 0x30, 0x01,
+0x90, 0x80, 0x90, 0x40, 0xe5, 0x22, 0xfe, 0x80, 0x3b, 0xf0, 0xe5, 0x23,
+0x00, 0xc0, 0x3c, 0x18, 0x90, 0x40, 0xe5, 0x22, 0xed, 0x00, 0x3b, 0xaa,
+0xe5, 0x22, 0xef, 0x40, 0x3b, 0xd2, 0x80, 0x99, 0x28, 0x02, 0xf0, 0x8c,
+0x3e, 0x60, 0x90, 0x80, 0x90, 0x40, 0xe5, 0x23, 0x55, 0x80, 0x3d, 0x52,
+0xe5, 0x23, 0x52, 0x80, 0x3d, 0x5e, 0x90, 0x40, 0xe5, 0x23, 0x45, 0x80,
+0x3d, 0x12, 0xe5, 0x23, 0x42, 0x80, 0x3d, 0x1e, 0x91, 0x48, 0x90, 0xc8,
+0x98, 0x50, 0x00, 0x80, 0xe5, 0x23, 0x33, 0x80, 0x3c, 0xe6, 0xe5, 0x23,
+0x27, 0x80, 0x3c, 0xb6, 0xcb, 0x61, 0xf3, 0xc0, 0x85, 0x37, 0xd3, 0x90,
+0x40, 0xe5, 0x23, 0x1b, 0x80, 0x3c, 0x86, 0xe5, 0x23, 0x0f, 0x80, 0x3c,
+0x56, 0x90, 0x48, 0xcb, 0xa1, 0xf3, 0x40, 0x85, 0x37, 0xd1, 0xcb, 0xa1,
+0xf3, 0x80, 0x85, 0x37, 0xd2, 0x10, 0x10, 0x90, 0x80, 0x90, 0x40, 0xe5,
+0x23, 0x05, 0x00, 0x3c, 0x10, 0xe5, 0x23, 0x02, 0x00, 0x3c, 0x1e, 0x90,
+0x40, 0xe5, 0x22, 0xf3, 0x80, 0x3b, 0xca, 0xe5, 0x22, 0xf0, 0x80, 0x3b,
+0xd8,
 };
 
 static const struct ia64_dis_names ia64_dis_names[] = {
--- a/opcodes/ia64-asmtab.h
+++ b/opcodes/ia64-asmtab.h
@@ -31,7 +31,7 @@ struct ia64_main_table
      opcode. */
   unsigned short name_index;
 
-  /* The type of opcode; corresponds to the TYPE field in 
+  /* The type of opcode; corresponds to the TYPE field in
      struct ia64_opcode. */
   unsigned char opcode_type;
 
@@ -64,7 +64,7 @@ struct ia64_main_table
    The completer entries modify certain bits in the instruction opcode.
    Which bits are to be modified are marked by the BITS, MASK and
    OFFSET fields.  The completer entry may also note dependencies for the
-   opcode. 
+   opcode.
 
    These completers are arranged in a DAG; the pointers are indexes
    into the completer_table array.  The completer DAG is searched by
@@ -81,7 +81,7 @@ struct ia64_main_table
    not contain an empty entry.
 
    Terminal completers (those completers that validly complete an
-   instruction) are marked by having the TERMINAL_COMPLETER flag set. 
+   instruction) are marked by having the TERMINAL_COMPLETER flag set.
 
    Only dependencies listed in the terminal completer for an opcode are
    considered to apply to that opcode instance. */
@@ -91,7 +91,7 @@ struct ia64_completer_table
   /* The bit value that this completer sets. */
   unsigned int bits;
 
-  /* And its mask. 1s are bits that are to be modified in the 
+  /* And its mask. 1s are bits that are to be modified in the
      instruction. */
   unsigned int mask;
 
@@ -118,11 +118,11 @@ struct ia64_completer_table
 
 /* This contains sufficient information for the disassembler to resolve
    the complete name of the original instruction.  */
-struct ia64_dis_names 
+struct ia64_dis_names
 {
   /* COMPLETER_INDEX represents the tree of completers that make up
      the instruction.  The LSB represents the top of the tree for the
-     specified instruction. 
+     specified instruction.
 
      A 0 bit indicates to go to the next alternate completer via the
      alternative field; a 1 bit indicates that the current completer
--- a/opcodes/ia64-dis.c
+++ b/opcodes/ia64-dis.c
@@ -303,7 +303,7 @@ print_insn_ia64 (bfd_vma memaddr, struct disassemble_info *info)
 	  need_comma = 0;
 	}
     }
-  if (slotnum + 1 == ia64_templ_desc[template_val].group_boundary 
+  if (slotnum + 1 == ia64_templ_desc[template_val].group_boundary
       || ((slotnum == 2) && s_bit))
     (*info->fprintf_func) (info->stream, ";;");
 
--- a/opcodes/ia64-gen.c
+++ b/opcodes/ia64-gen.c
@@ -22,15 +22,15 @@
 
 /* While the ia64-opc-* set of opcode tables are easy to maintain,
    they waste a tremendous amount of space.  ia64-gen rearranges the
-   instructions into a directed acyclic graph (DAG) of instruction opcodes and 
-   their possible completers, as well as compacting the set of strings used.  
+   instructions into a directed acyclic graph (DAG) of instruction opcodes and
+   their possible completers, as well as compacting the set of strings used.
 
    The disassembler table consists of a state machine that does
    branching based on the bits of the opcode being disassembled.  The
    state encodings have been chosen to minimize the amount of space
-   required.  
+   required.
 
-   The resource table is constructed based on some text dependency tables, 
+   The resource table is constructed based on some text dependency tables,
    which are also easier to maintain than the final representation.  */
 
 #include "sysdep.h"
@@ -172,7 +172,7 @@ struct bittree
    alphabetical order.  */
 
 /* One entry in the string table.  */
-struct string_entry 
+struct string_entry
 {
   /* The index in the ia64_strings[] array for this entry.  */
   int num;
@@ -188,11 +188,11 @@ int strtabtotlen = 0;
 struct rdep
 {
   char *name;                       /* Resource name.  */
-  unsigned 
+  unsigned
     mode:2,                         /* RAW, WAW, or WAR.  */
     semantics:3;                    /* Dependency semantics.  */
   char *extra;                      /* Additional semantics info.  */
-  int nchks;                   
+  int nchks;
   int total_chks;                   /* Total #of terminal insns.  */
   int *chks;                        /* Insn classes which read (RAW), write
                                        (WAW), or write (WAR) this rsrc.  */
@@ -211,12 +211,12 @@ static int rdepstotlen = 0;
 
 /* Array of all instruction classes.  */
 struct iclass
-{ 
+{
   char *name;                       /* Instruction class name.  */
   int is_class;                     /* Is a class, not a terminal.  */
-  int nsubs;                        
+  int nsubs;
   int *subs;                        /* Other classes within this class.  */
-  int nxsubs;                       
+  int nxsubs;
   int xsubs[4];                     /* Exclusions.  */
   char *comment;                    /* Optional comment.  */
   int note;                         /* Optional note.  */
@@ -301,7 +301,7 @@ static void
 fail (const char *message, ...)
 {
   va_list args;
-  
+
   va_start (args, message);
   fprintf (stderr, _("%s: Error: "), program_name);
   vfprintf (stderr, message, args);
@@ -336,7 +336,7 @@ insert_resource (const char *name, enum ia64_dependency_mode type)
   rdeps[rdepslen]->name = xstrdup (name);
   rdeps[rdepslen]->mode = type;
   rdeps[rdepslen]->waw_special = 0;
-  
+
   return rdeps[rdepslen++];
 }
 
@@ -405,7 +405,7 @@ insert_deplist (int count, unsigned short *deps)
 
 /* Add the given pair of dependency lists to the opcode dependency list.  */
 static short
-insert_dependencies (int nchks, unsigned short *chks, 
+insert_dependencies (int nchks, unsigned short *chks,
                      int nregs, unsigned short *regs)
 {
   struct opdep *pair;
@@ -419,14 +419,14 @@ insert_dependencies (int nchks, unsigned short *chks,
     chkind = insert_deplist (nchks, chks);
 
   for (i = 0; i < opdeplen; i++)
-    if (opdeps[i]->chk == chkind 
+    if (opdeps[i]->chk == chkind
 	&& opdeps[i]->reg == regind)
       return i;
 
   pair = tmalloc (struct opdep);
   pair->chk = chkind;
   pair->reg = regind;
-  
+
   if (opdeplen == opdeptotlen)
     {
       opdeptotlen += 20;
@@ -438,7 +438,7 @@ insert_dependencies (int nchks, unsigned short *chks,
   return opdeplen++;
 }
 
-static void 
+static void
 mark_used (struct iclass *ic, int clear_terminals)
 {
   int i;
@@ -521,7 +521,7 @@ fetch_insn_class (const char *full_name, int create)
     if (strcmp (name, ics[i]->name) == 0
         && ((comment == NULL && ics[i]->comment == NULL)
             || (comment != NULL && ics[i]->comment != NULL
-                && strncmp (ics[i]->comment, comment, 
+                && strncmp (ics[i]->comment, comment,
                             strlen (ics[i]->comment)) == 0))
         && note == ics[i]->note)
       return i;
@@ -623,10 +623,10 @@ load_insn_classes (void)
       int iclass;
       char *name;
       char *tmp;
-      
+
       if (fgets (buf, sizeof (buf), fp) == NULL)
         break;
-      
+
       while (ISSPACE (buf[strlen (buf) - 1]))
         buf[strlen (buf) - 1] = '\0';
 
@@ -670,9 +670,9 @@ load_insn_classes (void)
             }
           if (*tmp == ',')
             *tmp++ = '\0';
-          
+
           ics[iclass]->subs = (int *)
-            xrealloc ((void *)ics[iclass]->subs, 
+            xrealloc ((void *)ics[iclass]->subs,
 		      (ics[iclass]->nsubs + 1) * sizeof (int));
 
           sub = fetch_insn_class (subname, 1);
@@ -682,7 +682,7 @@ load_insn_classes (void)
         }
 
       /* Make sure classes come before terminals.  */
-      qsort ((void *)ics[iclass]->subs, 
+      qsort ((void *)ics[iclass]->subs,
              ics[iclass]->nsubs, sizeof(int), sub_compare);
     }
   fclose (fp);
@@ -712,7 +712,7 @@ parse_resource_users (const char *ref, int **usersp, int *nusersp,
       int iclass;
       int create = 0;
       char *name;
-      
+
       while (ISSPACE (*tmp))
         ++tmp;
       name = tmp;
@@ -720,7 +720,7 @@ parse_resource_users (const char *ref, int **usersp, int *nusersp,
         ++tmp;
       c = *tmp;
       *tmp++ = '\0';
-      
+
       xsect = strchr (name, '\\');
       if ((notestr = strstr (name, "+")) != NULL)
         {
@@ -738,7 +738,7 @@ parse_resource_users (const char *ref, int **usersp, int *nusersp,
           if (!xsect)
             *notestr = '\0';
         }
-      else 
+      else
         note = 0;
 
       /* All classes are created when the insn class table is parsed;
@@ -748,7 +748,7 @@ parse_resource_users (const char *ref, int **usersp, int *nusersp,
          table).  */
       if (! CONST_STRNEQ (name, "IC:") || xsect != NULL)
         create = 1;
-      
+
       iclass = fetch_insn_class (name, create);
       if (iclass != -1)
         {
@@ -788,7 +788,7 @@ parse_semantics (char *sem)
     return IA64_DVS_SPECIFIC;
   else if (strcmp (sem, "stop") == 0)
     return IA64_DVS_STOP;
-  else 
+  else
     return IA64_DVS_OTHER;
 }
 
@@ -835,7 +835,7 @@ load_depfile (const char *filename, enum ia64_dependency_mode mode)
       while (*tmp != ';')
         ++tmp;
       *tmp++ = '\0';
-      
+
       while (ISSPACE (*tmp))
         ++tmp;
       regp = tmp;
@@ -883,7 +883,7 @@ load_dependencies (void)
 }
 
 /* Is the given operand an indirect register file operand?  */
-static int 
+static int
 irf_operand (int op, const char *field)
 {
   if (!field)
@@ -910,7 +910,7 @@ irf_operand (int op, const char *field)
 /* Handle mov_ar, mov_br, mov_cr, move_dahr, mov_indirect, mov_ip, mov_pr,
  * mov_psr, and  mov_um insn classes.  */
 static int
-in_iclass_mov_x (struct ia64_opcode *idesc, struct iclass *ic, 
+in_iclass_mov_x (struct ia64_opcode *idesc, struct iclass *ic,
                  const char *format, const char *field)
 {
   int plain_mov = strcmp (idesc->name, "mov") == 0;
@@ -1031,7 +1031,7 @@ in_iclass_mov_x (struct ia64_opcode *idesc, struct iclass *ic,
 
 /* Is the given opcode in the given insn class?  */
 static int
-in_iclass (struct ia64_opcode *idesc, struct iclass *ic, 
+in_iclass (struct ia64_opcode *idesc, struct iclass *ic,
 	   const char *format, const char *field, int *notep)
 {
   int i;
@@ -1049,7 +1049,7 @@ in_iclass (struct ia64_opcode *idesc, struct iclass *ic,
                 {
                   warn (_("most recent format '%s'\nappears more restrictive than '%s'\n"),
 			ic->comment, format);
-                  format = ic->comment; 
+                  format = ic->comment;
                 }
             }
           else
@@ -1074,7 +1074,7 @@ in_iclass (struct ia64_opcode *idesc, struct iclass *ic,
       int len = strlen(ic->name);
 
       resolved = ((strncmp (ic->name, idesc->name, len) == 0)
-                  && (idesc->name[len] == '\0' 
+                  && (idesc->name[len] == '\0'
                       || idesc->name[len] == '.'));
 
       /* All break, nop, and hint variations must match exactly.  */
@@ -1162,7 +1162,7 @@ in_iclass (struct ia64_opcode *idesc, struct iclass *ic,
             resolved = 0;
         }
 
-      /* Misc brl variations ('.cond' is optional); 
+      /* Misc brl variations ('.cond' is optional);
          plain brl matches brl.cond.  */
       if (!resolved
           && (strcmp (idesc->name, "brl") == 0
@@ -1173,7 +1173,7 @@ in_iclass (struct ia64_opcode *idesc, struct iclass *ic,
         }
 
       /* Misc br variations ('.cond' is optional).  */
-      if (!resolved 
+      if (!resolved
           && (strcmp (idesc->name, "br") == 0
               || CONST_STRNEQ (idesc->name, "br."))
           && strcmp (ic->name, "br.cond") == 0)
@@ -1190,8 +1190,8 @@ in_iclass (struct ia64_opcode *idesc, struct iclass *ic,
       /* probe variations.  */
       if (!resolved && CONST_STRNEQ (idesc->name, "probe"))
         {
-          resolved = strcmp (ic->name, "probe") == 0 
-            && !((strstr (idesc->name, "fault") != NULL) 
+          resolved = strcmp (ic->name, "probe") == 0
+            && !((strstr (idesc->name, "fault") != NULL)
                  ^ (format && strstr (format, "M40") != NULL));
         }
 
@@ -1226,7 +1226,7 @@ in_iclass (struct ia64_opcode *idesc, struct iclass *ic,
 	    resolved = in_iclass_mov_x (idesc, ic, format, field);
         }
 
-      /* Keep track of this so we can flag any insn classes which aren't 
+      /* Keep track of this so we can flag any insn classes which aren't
          mapped onto at least one real insn.  */
       if (resolved)
 	ic->terminal_resolved = 1;
@@ -1248,7 +1248,7 @@ in_iclass (struct ia64_opcode *idesc, struct iclass *ic,
           break;
         }
     }
-  
+
   /* If it's in this IC, add the IC note (if any) to the insn.  */
   if (resolved)
     {
@@ -1483,7 +1483,7 @@ lookup_specifier (const char *name)
         return IA64_RS_PMD;
       if (strstr (name, "RR#") != NULL)
         return IA64_RS_RR;
-      
+
       warn (_("Don't know how to specify # dependency %s\n"),
 	    name);
     }
@@ -1514,7 +1514,7 @@ print_dependency_table (void)
 {
   int i, j;
 
-  if (debug) 
+  if (debug)
     {
       for (i=0;i < iclen;i++)
         {
@@ -1530,7 +1530,7 @@ print_dependency_table (void)
 			  ics[i]->name);
                 }
             }
-          else 
+          else
             {
               if (!ics[i]->terminal_resolved && !ics[i]->orphan)
                 {
@@ -1556,16 +1556,16 @@ print_dependency_table (void)
 
       if (debug > 1)
 	for (i = 0; i < rdepslen; i++)
-	  {  
+	  {
 	    static const char *mode_str[] = { "RAW", "WAW", "WAR" };
 
 	    if (rdeps[i]->total_chks == 0)
 	      {
 		if (rdeps[i]->total_regs)
-		  warn (_("Warning: rsrc %s (%s) has no chks\n"), 
+		  warn (_("Warning: rsrc %s (%s) has no chks\n"),
 			rdeps[i]->name, mode_str[rdeps[i]->mode]);
 		else
-		  warn (_("Warning: rsrc %s (%s) has no chks or regs\n"), 
+		  warn (_("Warning: rsrc %s (%s) has no chks or regs\n"),
 			rdeps[i]->name, mode_str[rdeps[i]->mode]);
 	      }
 	    else if (rdeps[i]->total_regs == 0)
@@ -1579,7 +1579,7 @@ print_dependency_table (void)
   for (i = 0; i < rdepslen; i++)
     {
       /* '%', '#', AR[], CR[], or PSR. indicates we need to specify the actual
-         resource used.  */ 
+         resource used.  */
       int specifier = lookup_specifier (rdeps[i]->name);
       int regindex = lookup_regindex (rdeps[i]->name, specifier);
 
@@ -1633,11 +1633,11 @@ print_dependency_table (void)
       printf ("  { ");
       if (opdeps[i]->chk == -1)
         printf ("0, NULL, ");
-      else 
+      else
         printf ("NELS(dep%d), dep%d, ", opdeps[i]->chk, opdeps[i]->chk);
       if (opdeps[i]->reg == -1)
         printf ("0, NULL, ");
-      else 
+      else
         printf ("NELS(dep%d), dep%d, ", opdeps[i]->reg, opdeps[i]->reg);
       printf ("},\n");
     }
@@ -1656,7 +1656,7 @@ insert_string (char *str)
     {
       strtabtotlen += 20;
       string_table = (struct string_entry **)
-	xrealloc (string_table, 
+	xrealloc (string_table,
 		  sizeof (struct string_entry **) * strtabtotlen);
     }
 
@@ -1729,7 +1729,7 @@ make_bittree_entry (void)
   res->bits_to_skip = 0;
   return res;
 }
- 
+
 
 static struct disent *
 add_dis_table_ent (struct disent *which, int insn, int order,
@@ -1794,7 +1794,7 @@ insert_bit_table_ent (struct bittree *curr_ent, int bit, ia64_insn opcode,
 
   if (bit == -1)
     {
-      struct disent *nent = add_dis_table_ent (curr_ent->disent, 
+      struct disent *nent = add_dis_table_ent (curr_ent->disent,
                                                opcodenum, order,
 					       completer_index);
       curr_ent->disent = nent;
@@ -1833,8 +1833,8 @@ add_dis_entry (struct bittree *first, ia64_insn opcode, ia64_insn mask,
 
       if (ent->is_terminal)
 	{
-	  insert_bit_table_ent (bittree, 40, newopcode, mask, 
-                                opcodenum, opcode_count - ent->order - 1, 
+	  insert_bit_table_ent (bittree, 40, newopcode, mask,
+                                opcodenum, opcode_count - ent->order - 1,
 				(completer_index << 1) | 1);
 	}
       completer_index <<= 1;
@@ -2013,7 +2013,7 @@ gen_dis_table (struct bittree *ent)
 	  else
 	    idest = ent->disent->ournum;
 
-	  /* If the destination offset for the if (bit is 1) test is less 
+	  /* If the destination offset for the if (bit is 1) test is less
 	     than 256 bytes away, we can store it as 8-bits instead of 16;
 	     the instruction has bit 5 set for the 16-bit address, and bit
 	     4 for the 8-bit address.  Since we've already allocated 16
@@ -2108,7 +2108,7 @@ gen_dis_table (struct bittree *ent)
     {
       if (ent->skip_flag)
 	printf ("%d: skipping %d\n", our_offset, ent->bits_to_skip);
-  
+
       if (ent->bits[0] != NULL)
 	printf ("%d: if (0:%d) goto %d\n", our_offset, zero_count + 1,
 		zero_dest);
@@ -2164,7 +2164,7 @@ generate_disassembler (void)
 
       if (ptr->opcode->type != IA64_TYPE_DYN)
 	add_dis_entry (bittree,
-		       ptr->opcode->opcode, ptr->opcode->mask, 
+		       ptr->opcode->opcode, ptr->opcode->mask,
 		       ptr->main_index,
 		       ptr->completers, 1);
     }
@@ -2189,7 +2189,7 @@ print_string_table (void)
   for (x = 0; x < strtablen; x++)
     {
       int len;
-      
+
       if (strlen (string_table[x]->s) > 75)
 	abort ();
 
@@ -2291,7 +2291,7 @@ insert_gclist (struct completer_entry *ent)
 		end = i - 1;
 	      else if (c == 0)
 		{
-		  while (i > 0 
+		  while (i > 0
 			 && ent->name->num == glist[i - 1]->name->num)
 		    i--;
 
@@ -2368,7 +2368,7 @@ compute_completer_bits (struct main_entry *ment, struct completer_entry *ent)
 
 	  while (p != NULL && ! p->is_terminal)
 	    p = p->parent;
-      
+
 	  if (p != NULL)
 	    p_bits = p->bits;
 	  else
@@ -2421,7 +2421,7 @@ collapse_redundant_completers (void)
 
 /* Attach two lists of dependencies to each opcode.
    1) all resources which, when already marked in use, conflict with this
-   opcode (chks) 
+   opcode (chks)
    2) all resources which must be marked in use when this opcode is used
    (regs).  */
 static int
@@ -2432,7 +2432,7 @@ insert_opcode_dependencies (struct ia64_opcode *opc,
      (79) and cmpxchng has the most regs (54) so 100 here should be enough.  */
   int i;
   int nregs = 0;
-  unsigned short regs[256];                  
+  unsigned short regs[256];
   int nchks = 0;
   unsigned short chks[256];
   /* Flag insns for which no class matched; there should be none.  */
@@ -2504,7 +2504,7 @@ insert_opcode_dependencies (struct ia64_opcode *opc,
 
   if (no_class_found)
     warn (_("opcode %s has no class (ops %d %d %d)\n"),
-	  opc->name, 
+	  opc->name,
 	  opc->operands[0], opc->operands[1], opc->operands[2]);
 
   return insert_dependencies (nchks, chks, nregs, regs);
@@ -2600,7 +2600,7 @@ print_completer_entry (struct completer_entry *ent)
       if (bits & 0xffffffff00000000LL)
 	abort ();
     }
-  
+
   printf ("  { 0x%x, 0x%x, %d, %d, %d, %d, %d, %d },\n",
 	  (int)bits,
 	  (int)mask,
@@ -2629,7 +2629,7 @@ opcodes_eq (struct ia64_opcode *opc1, struct ia64_opcode *opc2)
   int x;
   int plen1, plen2;
 
-  if ((opc1->mask != opc2->mask) || (opc1->type != opc2->type) 
+  if ((opc1->mask != opc2->mask) || (opc1->type != opc2->type)
       || (opc1->num_outputs != opc2->num_outputs)
       || (opc1->flags != opc2->flags))
     return 0;
@@ -2664,7 +2664,7 @@ add_opcode_entry (struct ia64_opcode *opc)
   name = insert_string (prefix);
 
   /* Walk the list of opcode table entries.  If it's a new
-     instruction, allocate and fill in a new entry.  Note 
+     instruction, allocate and fill in a new entry.  Note
      the main table is alphabetical by opcode name.  */
 
   while (*place != NULL)
@@ -2766,7 +2766,7 @@ shrink (struct ia64_opcode *table)
 /* Program options.  */
 #define OPTION_SRCDIR	200
 
-struct option long_options[] = 
+struct option long_options[] =
 {
   {"srcdir",  required_argument, NULL, OPTION_SRCDIR},
   {"debug",   no_argument,       NULL, 'd'},
@@ -2796,7 +2796,7 @@ main (int argc, char **argv)
   extern int chdir (char *);
   char *srcdir = NULL;
   int c;
-  
+
   program_name = *argv;
   xmalloc_set_program_name (program_name);
 
@@ -2824,7 +2824,7 @@ main (int argc, char **argv)
   if (optind != argc)
     usage (stdout, 1);
 
-  if (srcdir != NULL) 
+  if (srcdir != NULL)
     if (chdir (srcdir) != 0)
       fail (_("unable to change directory to \"%s\", errno = %s\n"),
 	    srcdir, strerror (errno));
--- a/opcodes/ia64-opc-m.c
+++ b/opcodes/ia64-opc-m.c
@@ -190,7 +190,7 @@ struct ia64_opcode ia64_opcodes_m[] =
     {"ptc.e",	M0, OpX3X6b (1, 0, 0x34), {R3}, PRIV, 0, NULL},
 
 #if 0
-// old pre-psn variant with 2-bit hints; 
+// old pre-psn variant with 2-bit hints;
 // saved for reference
     /* integer load */
     {"ld1",		M, OpMXX6aHint (4, 0, 0, 0x00, 0), {R1, MR3}, EMPTY},
@@ -893,7 +893,7 @@ struct ia64_opcode ia64_opcodes_m[] =
 #undef LDINCREG
 
 #if 0
-// old pre-psn variant with 2-bit hints; 
+// old pre-psn variant with 2-bit hints;
 // saved for reference
 
     {"st1",		M, OpMXX6aHint (4, 0, 0, 0x30, 0), {MR3, R2}, EMPTY},
@@ -1281,7 +1281,7 @@ struct ia64_opcode ia64_opcodes_m[] =
 #undef STINCIMMED
 
 #if 0
-// old pre-psn variant with 2-bit hints; 
+// old pre-psn variant with 2-bit hints;
 // saved for reference
     /* Floating-point load.  */
     {"ldfs",		M, OpMXX6aHint (6, 0, 0, 0x02, 0), {F1, MR3}, EMPTY},
@@ -1718,7 +1718,7 @@ struct ia64_opcode ia64_opcodes_m[] =
 #undef FLDINCREG
 
 #if 0
-// old pre-psn variant with 2-bit hints; 
+// old pre-psn variant with 2-bit hints;
 // saved for reference
     /* Floating-point store.  */
     {"stfs",		M, OpMXX6aHint (6, 0, 0, 0x32, 0), {MR3, F2}, EMPTY},
--- a/opcodes/ip2k-asm.c
+++ b/opcodes/ip2k-asm.c
@@ -58,7 +58,7 @@ parse_fr (CGEN_CPU_DESC cd,
 {
   const char *errmsg;
   const char *old_strp;
-  char *afteroffset; 
+  char *afteroffset;
   enum cgen_parse_operand_result result_type;
   bfd_vma value;
   extern CGEN_KEYWORD ip2k_cgen_opval_register_names;
@@ -107,7 +107,7 @@ parse_fr (CGEN_CPU_DESC cd,
 	}
       else
 	{
-	  *strp += 4; 
+	  *strp += 4;
 	  *valuep = 0;
 	  errmsg = NULL;
 	  return errmsg;
@@ -241,7 +241,7 @@ parse_addr16 (CGEN_CPU_DESC cd,
       errmsg = _("parse_addr16: invalid opindex.");
       return errmsg;
     }
-  
+
   errmsg = cgen_parse_address (cd, strp, opindex, code,
 			       & result_type, & value);
   if (errmsg == NULL)
@@ -255,7 +255,7 @@ parse_addr16 (CGEN_CPU_DESC cd,
 	  else
 	    /* code = BFD_RELOC_IP2K_LOW8DATA.  */
 	    value &= 0x00FF;
-	}   
+	}
       *valuep = value;
     }
 
@@ -272,7 +272,7 @@ parse_addr16_cjp (CGEN_CPU_DESC cd,
   enum cgen_parse_operand_result result_type;
   bfd_reloc_code_real_type code = BFD_RELOC_NONE;
   bfd_vma value;
- 
+
   if (opindex == (CGEN_OPERAND_TYPE) IP2K_OPERAND_ADDR16CJP)
     code = BFD_RELOC_IP2K_ADDR16CJP;
   else if (opindex == (CGEN_OPERAND_TYPE) IP2K_OPERAND_ADDR16P)
@@ -300,10 +300,10 @@ parse_addr16_cjp (CGEN_CPU_DESC cd,
 	     are labels.  */
 	  *valuep = value;
 	}
-      else 
+      else
         errmsg = _("cgen_parse_address returned a symbol. Literal required.");
     }
-  return errmsg; 
+  return errmsg;
 }
 
 static const char *
@@ -352,7 +352,7 @@ parse_lit8 (CGEN_CPU_DESC cd,
   /* Parse %op operand.  */
   if (code != BFD_RELOC_NONE)
     {
-      errmsg = cgen_parse_address (cd, strp, opindex, code, 
+      errmsg = cgen_parse_address (cd, strp, opindex, code,
 				   & result_type, & value);
       if ((errmsg == NULL) &&
 	  (result_type != CGEN_PARSE_OPERAND_RESULT_QUEUED))
@@ -412,7 +412,7 @@ parse_bit3 (CGEN_CPU_DESC cd,
 	  errmsg = _("Attempt to find bit index of 0");
 	  return errmsg;
 	}
-    
+
       if (mode == 1)
 	{
 	  count = 31;
@@ -431,7 +431,7 @@ parse_bit3 (CGEN_CPU_DESC cd,
 	      value >>= 1;
 	    }
 	}
-    
+
       *valuep = count;
     }
 
@@ -514,7 +514,7 @@ ip2k_cgen_parse_operand (CGEN_CPU_DESC cd,
   return errmsg;
 }
 
-cgen_parse_fn * const ip2k_cgen_parse_handlers[] = 
+cgen_parse_fn * const ip2k_cgen_parse_handlers[] =
 {
   parse_insn_normal,
 };
@@ -544,9 +544,9 @@ CGEN_ASM_INIT_HOOK
 
    Returns NULL for success, an error message for failure.  */
 
-char * 
+char *
 ip2k_cgen_build_insn_regex (CGEN_INSN *insn)
-{  
+{
   CGEN_OPCODE *opc = (CGEN_OPCODE *) CGEN_INSN_OPCODE (insn);
   const char *mnem = CGEN_INSN_MNEMONIC (insn);
   char rxbuf[CGEN_MAX_RX_ELEMENTS];
@@ -585,18 +585,18 @@ ip2k_cgen_build_insn_regex (CGEN_INSN *insn)
   /* Copy any remaining literals from the syntax string into the rx.  */
   for(; * syn != 0 && rx <= rxbuf + (CGEN_MAX_RX_ELEMENTS - 7 - 4); ++syn)
     {
-      if (CGEN_SYNTAX_CHAR_P (* syn)) 
+      if (CGEN_SYNTAX_CHAR_P (* syn))
 	{
 	  char c = CGEN_SYNTAX_CHAR (* syn);
 
-	  switch (c) 
+	  switch (c)
 	    {
 	      /* Escape any regex metacharacters in the syntax.  */
-	    case '.': case '[': case '\\': 
-	    case '*': case '^': case '$': 
+	    case '.': case '[': case '\\':
+	    case '*': case '^': case '$':
 
 #ifdef CGEN_ESCAPE_EXTENDED_REGEX
-	    case '?': case '{': case '}': 
+	    case '?': case '{': case '}':
 	    case '(': case ')': case '*':
 	    case '|': case '+': case ']':
 #endif
@@ -626,20 +626,20 @@ ip2k_cgen_build_insn_regex (CGEN_INSN *insn)
     }
 
   /* Trailing whitespace ok.  */
-  * rx++ = '['; 
-  * rx++ = ' '; 
-  * rx++ = '\t'; 
-  * rx++ = ']'; 
-  * rx++ = '*'; 
+  * rx++ = '[';
+  * rx++ = ' ';
+  * rx++ = '\t';
+  * rx++ = ']';
+  * rx++ = '*';
 
   /* But anchor it after that.  */
-  * rx++ = '$'; 
+  * rx++ = '$';
   * rx = '\0';
 
   CGEN_INSN_RX (insn) = xmalloc (sizeof (regex_t));
   reg_err = regcomp ((regex_t *) CGEN_INSN_RX (insn), rxbuf, REG_NOSUB);
 
-  if (reg_err == 0) 
+  if (reg_err == 0)
     return NULL;
   else
     {
@@ -838,7 +838,7 @@ ip2k_cgen_assemble_insn (CGEN_CPU_DESC cd,
       const CGEN_INSN *insn = ilist->insn;
       recognized_mnemonic = 1;
 
-#ifdef CGEN_VALIDATE_INSN_SUPPORTED 
+#ifdef CGEN_VALIDATE_INSN_SUPPORTED
       /* Not usually needed as unsupported opcodes
 	 shouldn't be in the hash lists.  */
       /* Is this insn supported by the selected cpu?  */
@@ -898,7 +898,7 @@ ip2k_cgen_assemble_insn (CGEN_CPU_DESC cd,
 	if (strlen (start) > 50)
 	  /* xgettext:c-format */
 	  sprintf (errbuf, "%s `%.50s...'", tmp_errmsg, start);
-	else 
+	else
 	  /* xgettext:c-format */
 	  sprintf (errbuf, "%s `%.50s'", tmp_errmsg, start);
       }
@@ -907,11 +907,11 @@ ip2k_cgen_assemble_insn (CGEN_CPU_DESC cd,
 	if (strlen (start) > 50)
 	  /* xgettext:c-format */
 	  sprintf (errbuf, _("bad instruction `%.50s...'"), start);
-	else 
+	else
 	  /* xgettext:c-format */
 	  sprintf (errbuf, _("bad instruction `%.50s'"), start);
       }
-      
+
     *errmsg = errbuf;
     return NULL;
   }
--- a/opcodes/ip2k-desc.c
+++ b/opcodes/ip2k-desc.c
@@ -332,55 +332,55 @@ const CGEN_OPERAND ip2k_cgen_operand_table[] =
 {
 /* pc: program counter */
   { "pc", IP2K_OPERAND_PC, HW_H_PC, 0, 0,
-    { 0, { (const PTR) &ip2k_cgen_ifld_table[IP2K_F_NIL] } }, 
+    { 0, { (const PTR) &ip2k_cgen_ifld_table[IP2K_F_NIL] } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* addr16cjp: 13-bit address */
   { "addr16cjp", IP2K_OPERAND_ADDR16CJP, HW_H_UINT, 12, 13,
-    { 0, { (const PTR) &ip2k_cgen_ifld_table[IP2K_F_ADDR16CJP] } }, 
+    { 0, { (const PTR) &ip2k_cgen_ifld_table[IP2K_F_ADDR16CJP] } },
     { 0|A(ABS_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
 /* fr: register */
   { "fr", IP2K_OPERAND_FR, HW_H_REGISTERS, 8, 9,
-    { 0, { (const PTR) &ip2k_cgen_ifld_table[IP2K_F_REG] } }, 
+    { 0, { (const PTR) &ip2k_cgen_ifld_table[IP2K_F_REG] } },
     { 0|A(ABS_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
 /* lit8: 8-bit signed literal */
   { "lit8", IP2K_OPERAND_LIT8, HW_H_SINT, 7, 8,
-    { 0, { (const PTR) &ip2k_cgen_ifld_table[IP2K_F_IMM8] } }, 
+    { 0, { (const PTR) &ip2k_cgen_ifld_table[IP2K_F_IMM8] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* bitno: bit number */
   { "bitno", IP2K_OPERAND_BITNO, HW_H_UINT, 11, 3,
-    { 0, { (const PTR) &ip2k_cgen_ifld_table[IP2K_F_BITNO] } }, 
+    { 0, { (const PTR) &ip2k_cgen_ifld_table[IP2K_F_BITNO] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* addr16p: page number */
   { "addr16p", IP2K_OPERAND_ADDR16P, HW_H_UINT, 2, 3,
-    { 0, { (const PTR) &ip2k_cgen_ifld_table[IP2K_F_PAGE3] } }, 
+    { 0, { (const PTR) &ip2k_cgen_ifld_table[IP2K_F_PAGE3] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* addr16h: high 8 bits of address */
   { "addr16h", IP2K_OPERAND_ADDR16H, HW_H_UINT, 7, 8,
-    { 0, { (const PTR) &ip2k_cgen_ifld_table[IP2K_F_IMM8] } }, 
+    { 0, { (const PTR) &ip2k_cgen_ifld_table[IP2K_F_IMM8] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* addr16l: low 8 bits of address */
   { "addr16l", IP2K_OPERAND_ADDR16L, HW_H_UINT, 7, 8,
-    { 0, { (const PTR) &ip2k_cgen_ifld_table[IP2K_F_IMM8] } }, 
+    { 0, { (const PTR) &ip2k_cgen_ifld_table[IP2K_F_IMM8] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* reti3: reti flags */
   { "reti3", IP2K_OPERAND_RETI3, HW_H_UINT, 2, 3,
-    { 0, { (const PTR) &ip2k_cgen_ifld_table[IP2K_F_RETI3] } }, 
+    { 0, { (const PTR) &ip2k_cgen_ifld_table[IP2K_F_RETI3] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* pabits: page bits */
   { "pabits", IP2K_OPERAND_PABITS, HW_H_PABITS, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* zbit: zero bit */
   { "zbit", IP2K_OPERAND_ZBIT, HW_H_ZBIT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* cbit: carry bit */
   { "cbit", IP2K_OPERAND_CBIT, HW_H_CBIT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* dcbit: digit carry bit */
   { "dcbit", IP2K_OPERAND_DCBIT, HW_H_DCBIT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* sentinel */
   { 0, 0, 0, 0, 0,
@@ -1118,7 +1118,7 @@ ip2k_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)
 
   /* Default to not allowing signed overflow.  */
   cd->signed_overflow_ok_p = 0;
-  
+
   return (CGEN_CPU_DESC) cd;
 }
 
@@ -1158,7 +1158,7 @@ ip2k_cgen_cpu_close (CGEN_CPU_DESC cd)
       for (i = 0; i < cd->insn_table.num_init_entries; ++i, ++insns)
 	if (CGEN_INSN_RX (insns))
 	  regfree (CGEN_INSN_RX (insns));
-    }  
+    }
 
   if (cd->macro_insn_table.init_entries)
     free ((CGEN_INSN *) cd->macro_insn_table.init_entries);
--- a/opcodes/ip2k-dis.c
+++ b/opcodes/ip2k-dis.c
@@ -290,7 +290,7 @@ ip2k_cgen_print_operand (CGEN_CPU_DESC cd,
   }
 }
 
-cgen_print_fn * const ip2k_cgen_print_handlers[] = 
+cgen_print_fn * const ip2k_cgen_print_handlers[] =
 {
   print_insn_normal,
 };
@@ -480,7 +480,7 @@ print_insn (CGEN_CPU_DESC cd,
       int length;
       unsigned long insn_value_cropped;
 
-#ifdef CGEN_VALIDATE_INSN_SUPPORTED 
+#ifdef CGEN_VALIDATE_INSN_SUPPORTED
       /* Not needed as insn shouldn't be in hash lists if not supported.  */
       /* Supported by this cpu?  */
       if (! ip2k_cgen_insn_supported (cd, insn))
@@ -498,7 +498,7 @@ print_insn (CGEN_CPU_DESC cd,
          relevant part from the buffer. */
       if ((unsigned) (CGEN_INSN_BITSIZE (insn) / 8) < buflen &&
 	  (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
-	insn_value_cropped = bfd_get_bits (buf, CGEN_INSN_BITSIZE (insn), 
+	insn_value_cropped = bfd_get_bits (buf, CGEN_INSN_BITSIZE (insn),
 					   info->endian == BFD_ENDIAN_BIG);
       else
 	insn_value_cropped = insn_value;
@@ -617,7 +617,7 @@ print_insn_ip2k (bfd_vma pc, disassemble_info *info)
   arch = info->arch;
   if (arch == bfd_arch_unknown)
     arch = CGEN_BFD_ARCH;
-   
+
   /* There's no standard way to compute the machine or isa number
      so we leave it to the target.  */
 #ifdef CGEN_COMPUTE_MACH
@@ -658,7 +658,7 @@ print_insn_ip2k (bfd_vma pc, disassemble_info *info)
 	      break;
 	    }
 	}
-    } 
+    }
 
   /* If we haven't initialized yet, initialize the opcode table.  */
   if (! cd)
--- a/opcodes/ip2k-ibld.c
+++ b/opcodes/ip2k-ibld.c
@@ -154,7 +154,7 @@ insert_normal (CGEN_CPU_DESC cd,
     {
       long minval = - (1L << (length - 1));
       unsigned long maxval = mask;
-      
+
       if ((value > 0 && (unsigned long) value > maxval)
 	  || value < minval)
 	{
@@ -192,7 +192,7 @@ insert_normal (CGEN_CPU_DESC cd,
 	{
 	  long minval = - (1L << (length - 1));
 	  long maxval =   (1L << (length - 1)) - 1;
-	  
+
 	  if (value < minval || value > maxval)
 	    {
 	      sprintf
@@ -683,12 +683,12 @@ ip2k_cgen_extract_operand (CGEN_CPU_DESC cd,
   return length;
 }
 
-cgen_insert_fn * const ip2k_cgen_insert_handlers[] = 
+cgen_insert_fn * const ip2k_cgen_insert_handlers[] =
 {
   insert_insn_normal,
 };
 
-cgen_extract_fn * const ip2k_cgen_extract_handlers[] = 
+cgen_extract_fn * const ip2k_cgen_extract_handlers[] =
 {
   extract_insn_normal,
 };
--- a/opcodes/ip2k-opc.c
+++ b/opcodes/ip2k-opc.c
@@ -60,7 +60,7 @@ ip2k_cgen_insn_supported (CGEN_CPU_DESC cd, const CGEN_INSN *insn)
   /* No mach attribute?  Assume it's supported for all machs.  */
   if (machs == 0)
     return 1;
-  
+
   return (machs & cd->machs) != 0;
 }
 
--- a/opcodes/iq2000-asm.c
+++ b/opcodes/iq2000-asm.c
@@ -70,16 +70,16 @@ iq2000_cgen_isa_register (const char **strp)
   int len;
   int ch1, ch2;
 
-  if (**strp == 'r' || **strp == 'R') 
+  if (**strp == 'r' || **strp == 'R')
     {
       len = strlen (*strp);
-      if (len == 2) 
+      if (len == 2)
         {
           ch1 = (*strp)[1];
           if ('0' <= ch1 && ch1 <= '9')
             return 1;
-        } 
-      else if (len == 3) 
+        }
+      else if (len == 3)
         {
 	  ch1 = (*strp)[1];
           ch2 = (*strp)[2];
@@ -112,7 +112,7 @@ parse_mimm (CGEN_CPU_DESC cd,
   else
     {
       long value;
-      
+
       errmsg = cgen_parse_signed_integer (cd, strp, opindex, & value);
       if (errmsg == NULL)
 	{
@@ -462,7 +462,7 @@ iq2000_cgen_parse_operand (CGEN_CPU_DESC cd,
   return errmsg;
 }
 
-cgen_parse_fn * const iq2000_cgen_parse_handlers[] = 
+cgen_parse_fn * const iq2000_cgen_parse_handlers[] =
 {
   parse_insn_normal,
 };
@@ -492,9 +492,9 @@ CGEN_ASM_INIT_HOOK
 
    Returns NULL for success, an error message for failure.  */
 
-char * 
+char *
 iq2000_cgen_build_insn_regex (CGEN_INSN *insn)
-{  
+{
   CGEN_OPCODE *opc = (CGEN_OPCODE *) CGEN_INSN_OPCODE (insn);
   const char *mnem = CGEN_INSN_MNEMONIC (insn);
   char rxbuf[CGEN_MAX_RX_ELEMENTS];
@@ -533,18 +533,18 @@ iq2000_cgen_build_insn_regex (CGEN_INSN *insn)
   /* Copy any remaining literals from the syntax string into the rx.  */
   for(; * syn != 0 && rx <= rxbuf + (CGEN_MAX_RX_ELEMENTS - 7 - 4); ++syn)
     {
-      if (CGEN_SYNTAX_CHAR_P (* syn)) 
+      if (CGEN_SYNTAX_CHAR_P (* syn))
 	{
 	  char c = CGEN_SYNTAX_CHAR (* syn);
 
-	  switch (c) 
+	  switch (c)
 	    {
 	      /* Escape any regex metacharacters in the syntax.  */
-	    case '.': case '[': case '\\': 
-	    case '*': case '^': case '$': 
+	    case '.': case '[': case '\\':
+	    case '*': case '^': case '$':
 
 #ifdef CGEN_ESCAPE_EXTENDED_REGEX
-	    case '?': case '{': case '}': 
+	    case '?': case '{': case '}':
 	    case '(': case ')': case '*':
 	    case '|': case '+': case ']':
 #endif
@@ -574,20 +574,20 @@ iq2000_cgen_build_insn_regex (CGEN_INSN *insn)
     }
 
   /* Trailing whitespace ok.  */
-  * rx++ = '['; 
-  * rx++ = ' '; 
-  * rx++ = '\t'; 
-  * rx++ = ']'; 
-  * rx++ = '*'; 
+  * rx++ = '[';
+  * rx++ = ' ';
+  * rx++ = '\t';
+  * rx++ = ']';
+  * rx++ = '*';
 
   /* But anchor it after that.  */
-  * rx++ = '$'; 
+  * rx++ = '$';
   * rx = '\0';
 
   CGEN_INSN_RX (insn) = xmalloc (sizeof (regex_t));
   reg_err = regcomp ((regex_t *) CGEN_INSN_RX (insn), rxbuf, REG_NOSUB);
 
-  if (reg_err == 0) 
+  if (reg_err == 0)
     return NULL;
   else
     {
@@ -786,7 +786,7 @@ iq2000_cgen_assemble_insn (CGEN_CPU_DESC cd,
       const CGEN_INSN *insn = ilist->insn;
       recognized_mnemonic = 1;
 
-#ifdef CGEN_VALIDATE_INSN_SUPPORTED 
+#ifdef CGEN_VALIDATE_INSN_SUPPORTED
       /* Not usually needed as unsupported opcodes
 	 shouldn't be in the hash lists.  */
       /* Is this insn supported by the selected cpu?  */
@@ -846,7 +846,7 @@ iq2000_cgen_assemble_insn (CGEN_CPU_DESC cd,
 	if (strlen (start) > 50)
 	  /* xgettext:c-format */
 	  sprintf (errbuf, "%s `%.50s...'", tmp_errmsg, start);
-	else 
+	else
 	  /* xgettext:c-format */
 	  sprintf (errbuf, "%s `%.50s'", tmp_errmsg, start);
       }
@@ -855,11 +855,11 @@ iq2000_cgen_assemble_insn (CGEN_CPU_DESC cd,
 	if (strlen (start) > 50)
 	  /* xgettext:c-format */
 	  sprintf (errbuf, _("bad instruction `%.50s...'"), start);
-	else 
+	else
 	  /* xgettext:c-format */
 	  sprintf (errbuf, _("bad instruction `%.50s'"), start);
       }
-      
+
     *errmsg = errbuf;
     return NULL;
   }
--- a/opcodes/iq2000-desc.c
+++ b/opcodes/iq2000-desc.c
@@ -316,131 +316,131 @@ const CGEN_OPERAND iq2000_cgen_operand_table[] =
 {
 /* pc: program counter */
   { "pc", IQ2000_OPERAND_PC, HW_H_PC, 0, 0,
-    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_NIL] } }, 
+    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_NIL] } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* rs: register Rs */
   { "rs", IQ2000_OPERAND_RS, HW_H_GR, 25, 5,
-    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_RS] } }, 
+    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_RS] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* rt: register Rt */
   { "rt", IQ2000_OPERAND_RT, HW_H_GR, 20, 5,
-    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_RT] } }, 
+    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_RT] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* rd: register Rd */
   { "rd", IQ2000_OPERAND_RD, HW_H_GR, 15, 5,
-    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_RD] } }, 
+    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_RD] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* rd-rs: register Rd from Rs */
   { "rd-rs", IQ2000_OPERAND_RD_RS, HW_H_GR, 15, 10,
-    { 2, { (const PTR) &IQ2000_F_RD_RS_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &IQ2000_F_RD_RS_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } }  },
 /* rd-rt: register Rd from Rt */
   { "rd-rt", IQ2000_OPERAND_RD_RT, HW_H_GR, 15, 10,
-    { 2, { (const PTR) &IQ2000_F_RD_RT_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &IQ2000_F_RD_RT_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } }  },
 /* rt-rs: register Rt from Rs */
   { "rt-rs", IQ2000_OPERAND_RT_RS, HW_H_GR, 20, 10,
-    { 2, { (const PTR) &IQ2000_F_RT_RS_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &IQ2000_F_RT_RS_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } }  },
 /* shamt: shift amount */
   { "shamt", IQ2000_OPERAND_SHAMT, HW_H_UINT, 10, 5,
-    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_SHAMT] } }, 
+    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_SHAMT] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* imm: immediate */
   { "imm", IQ2000_OPERAND_IMM, HW_H_UINT, 15, 16,
-    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_IMM] } }, 
+    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_IMM] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* offset: pc-relative offset */
   { "offset", IQ2000_OPERAND_OFFSET, HW_H_IADDR, 15, 16,
-    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_OFFSET] } }, 
+    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_OFFSET] } },
     { 0|A(PCREL_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
 /* baseoff: base register offset */
   { "baseoff", IQ2000_OPERAND_BASEOFF, HW_H_IADDR, 15, 16,
-    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_IMM] } }, 
+    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_IMM] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* jmptarg: jump target */
   { "jmptarg", IQ2000_OPERAND_JMPTARG, HW_H_IADDR, 15, 16,
-    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_JTARG] } }, 
+    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_JTARG] } },
     { 0|A(ABS_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
 /* mask: mask */
   { "mask", IQ2000_OPERAND_MASK, HW_H_UINT, 9, 4,
-    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_MASK] } }, 
+    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_MASK] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* maskq10: iq10 mask */
   { "maskq10", IQ2000_OPERAND_MASKQ10, HW_H_UINT, 10, 5,
-    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_MASKQ10] } }, 
+    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_MASKQ10] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* maskl: mask left */
   { "maskl", IQ2000_OPERAND_MASKL, HW_H_UINT, 4, 5,
-    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_MASKL] } }, 
+    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_MASKL] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* count: count */
   { "count", IQ2000_OPERAND_COUNT, HW_H_UINT, 15, 7,
-    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_COUNT] } }, 
+    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_COUNT] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* _index: index */
   { "_index", IQ2000_OPERAND__INDEX, HW_H_UINT, 8, 9,
-    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_INDEX] } }, 
+    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_INDEX] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* execode: execcode */
   { "execode", IQ2000_OPERAND_EXECODE, HW_H_UINT, 25, 20,
-    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_EXCODE] } }, 
+    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_EXCODE] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* bytecount: byte count */
   { "bytecount", IQ2000_OPERAND_BYTECOUNT, HW_H_UINT, 7, 8,
-    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_BYTECOUNT] } }, 
+    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_BYTECOUNT] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* cam-y: cam global opn y */
   { "cam-y", IQ2000_OPERAND_CAM_Y, HW_H_UINT, 2, 3,
-    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_CAM_Y] } }, 
+    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_CAM_Y] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* cam-z: cam global mask z */
   { "cam-z", IQ2000_OPERAND_CAM_Z, HW_H_UINT, 5, 3,
-    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_CAM_Z] } }, 
+    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_CAM_Z] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* cm-3func: CM 3 bit fn field */
   { "cm-3func", IQ2000_OPERAND_CM_3FUNC, HW_H_UINT, 5, 3,
-    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_CM_3FUNC] } }, 
+    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_CM_3FUNC] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* cm-4func: CM 4 bit fn field */
   { "cm-4func", IQ2000_OPERAND_CM_4FUNC, HW_H_UINT, 5, 4,
-    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_CM_4FUNC] } }, 
+    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_CM_4FUNC] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* cm-3z: CM 3 bit Z field */
   { "cm-3z", IQ2000_OPERAND_CM_3Z, HW_H_UINT, 1, 2,
-    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_CM_3Z] } }, 
+    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_CM_3Z] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* cm-4z: CM 4 bit Z field */
   { "cm-4z", IQ2000_OPERAND_CM_4Z, HW_H_UINT, 2, 3,
-    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_CM_4Z] } }, 
+    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_CM_4Z] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* base: base register */
   { "base", IQ2000_OPERAND_BASE, HW_H_GR, 25, 5,
-    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_RS] } }, 
+    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_RS] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* maskr: mask right */
   { "maskr", IQ2000_OPERAND_MASKR, HW_H_UINT, 25, 5,
-    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_RS] } }, 
+    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_RS] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* bitnum: bit number */
   { "bitnum", IQ2000_OPERAND_BITNUM, HW_H_UINT, 20, 5,
-    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_RT] } }, 
+    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_RT] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* hi16: high 16 bit immediate */
   { "hi16", IQ2000_OPERAND_HI16, HW_H_UINT, 15, 16,
-    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_IMM] } }, 
+    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_IMM] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* lo16: 16 bit signed immediate, for low */
   { "lo16", IQ2000_OPERAND_LO16, HW_H_UINT, 15, 16,
-    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_IMM] } }, 
+    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_IMM] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* mlo16: negated 16 bit signed immediate */
   { "mlo16", IQ2000_OPERAND_MLO16, HW_H_UINT, 15, 16,
-    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_IMM] } }, 
+    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_IMM] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* jmptargq10: iq10 21-bit jump offset */
   { "jmptargq10", IQ2000_OPERAND_JMPTARGQ10, HW_H_IADDR, 20, 21,
-    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_JTARGQ10] } }, 
+    { 0, { (const PTR) &iq2000_cgen_ifld_table[IQ2000_F_JTARGQ10] } },
     { 0|A(ABS_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
 /* sentinel */
   { 0, 0, 0, 0, 0,
@@ -2123,7 +2123,7 @@ iq2000_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)
 
   /* Default to not allowing signed overflow.  */
   cd->signed_overflow_ok_p = 0;
-  
+
   return (CGEN_CPU_DESC) cd;
 }
 
@@ -2163,7 +2163,7 @@ iq2000_cgen_cpu_close (CGEN_CPU_DESC cd)
       for (i = 0; i < cd->insn_table.num_init_entries; ++i, ++insns)
 	if (CGEN_INSN_RX (insns))
 	  regfree (CGEN_INSN_RX (insns));
-    }  
+    }
 
   if (cd->macro_insn_table.init_entries)
     free ((CGEN_INSN *) cd->macro_insn_table.init_entries);
--- a/opcodes/iq2000-dis.c
+++ b/opcodes/iq2000-dis.c
@@ -191,7 +191,7 @@ iq2000_cgen_print_operand (CGEN_CPU_DESC cd,
   }
 }
 
-cgen_print_fn * const iq2000_cgen_print_handlers[] = 
+cgen_print_fn * const iq2000_cgen_print_handlers[] =
 {
   print_insn_normal,
 };
@@ -381,7 +381,7 @@ print_insn (CGEN_CPU_DESC cd,
       int length;
       unsigned long insn_value_cropped;
 
-#ifdef CGEN_VALIDATE_INSN_SUPPORTED 
+#ifdef CGEN_VALIDATE_INSN_SUPPORTED
       /* Not needed as insn shouldn't be in hash lists if not supported.  */
       /* Supported by this cpu?  */
       if (! iq2000_cgen_insn_supported (cd, insn))
@@ -399,7 +399,7 @@ print_insn (CGEN_CPU_DESC cd,
          relevant part from the buffer. */
       if ((unsigned) (CGEN_INSN_BITSIZE (insn) / 8) < buflen &&
 	  (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
-	insn_value_cropped = bfd_get_bits (buf, CGEN_INSN_BITSIZE (insn), 
+	insn_value_cropped = bfd_get_bits (buf, CGEN_INSN_BITSIZE (insn),
 					   info->endian == BFD_ENDIAN_BIG);
       else
 	insn_value_cropped = insn_value;
@@ -518,7 +518,7 @@ print_insn_iq2000 (bfd_vma pc, disassemble_info *info)
   arch = info->arch;
   if (arch == bfd_arch_unknown)
     arch = CGEN_BFD_ARCH;
-   
+
   /* There's no standard way to compute the machine or isa number
      so we leave it to the target.  */
 #ifdef CGEN_COMPUTE_MACH
@@ -559,7 +559,7 @@ print_insn_iq2000 (bfd_vma pc, disassemble_info *info)
 	      break;
 	    }
 	}
-    } 
+    }
 
   /* If we haven't initialized yet, initialize the opcode table.  */
   if (! cd)
--- a/opcodes/iq2000-ibld.c
+++ b/opcodes/iq2000-ibld.c
@@ -154,7 +154,7 @@ insert_normal (CGEN_CPU_DESC cd,
     {
       long minval = - (1L << (length - 1));
       unsigned long maxval = mask;
-      
+
       if ((value > 0 && (unsigned long) value > maxval)
 	  || value < minval)
 	{
@@ -192,7 +192,7 @@ insert_normal (CGEN_CPU_DESC cd,
 	{
 	  long minval = - (1L << (length - 1));
 	  long maxval =   (1L << (length - 1)) - 1;
-	  
+
 	  if (value < minval || value > maxval)
 	    {
 	      sprintf
@@ -889,12 +889,12 @@ iq2000_cgen_extract_operand (CGEN_CPU_DESC cd,
   return length;
 }
 
-cgen_insert_fn * const iq2000_cgen_insert_handlers[] = 
+cgen_insert_fn * const iq2000_cgen_insert_handlers[] =
 {
   insert_insn_normal,
 };
 
-cgen_extract_fn * const iq2000_cgen_extract_handlers[] = 
+cgen_extract_fn * const iq2000_cgen_extract_handlers[] =
 {
   extract_insn_normal,
 };
--- a/opcodes/lm32-asm.c
+++ b/opcodes/lm32-asm.c
@@ -352,7 +352,7 @@ lm32_cgen_parse_operand (CGEN_CPU_DESC cd,
   return errmsg;
 }
 
-cgen_parse_fn * const lm32_cgen_parse_handlers[] = 
+cgen_parse_fn * const lm32_cgen_parse_handlers[] =
 {
   parse_insn_normal,
 };
@@ -382,9 +382,9 @@ CGEN_ASM_INIT_HOOK
 
    Returns NULL for success, an error message for failure.  */
 
-char * 
+char *
 lm32_cgen_build_insn_regex (CGEN_INSN *insn)
-{  
+{
   CGEN_OPCODE *opc = (CGEN_OPCODE *) CGEN_INSN_OPCODE (insn);
   const char *mnem = CGEN_INSN_MNEMONIC (insn);
   char rxbuf[CGEN_MAX_RX_ELEMENTS];
@@ -423,18 +423,18 @@ lm32_cgen_build_insn_regex (CGEN_INSN *insn)
   /* Copy any remaining literals from the syntax string into the rx.  */
   for(; * syn != 0 && rx <= rxbuf + (CGEN_MAX_RX_ELEMENTS - 7 - 4); ++syn)
     {
-      if (CGEN_SYNTAX_CHAR_P (* syn)) 
+      if (CGEN_SYNTAX_CHAR_P (* syn))
 	{
 	  char c = CGEN_SYNTAX_CHAR (* syn);
 
-	  switch (c) 
+	  switch (c)
 	    {
 	      /* Escape any regex metacharacters in the syntax.  */
-	    case '.': case '[': case '\\': 
-	    case '*': case '^': case '$': 
+	    case '.': case '[': case '\\':
+	    case '*': case '^': case '$':
 
 #ifdef CGEN_ESCAPE_EXTENDED_REGEX
-	    case '?': case '{': case '}': 
+	    case '?': case '{': case '}':
 	    case '(': case ')': case '*':
 	    case '|': case '+': case ']':
 #endif
@@ -464,20 +464,20 @@ lm32_cgen_build_insn_regex (CGEN_INSN *insn)
     }
 
   /* Trailing whitespace ok.  */
-  * rx++ = '['; 
-  * rx++ = ' '; 
-  * rx++ = '\t'; 
-  * rx++ = ']'; 
-  * rx++ = '*'; 
+  * rx++ = '[';
+  * rx++ = ' ';
+  * rx++ = '\t';
+  * rx++ = ']';
+  * rx++ = '*';
 
   /* But anchor it after that.  */
-  * rx++ = '$'; 
+  * rx++ = '$';
   * rx = '\0';
 
   CGEN_INSN_RX (insn) = xmalloc (sizeof (regex_t));
   reg_err = regcomp ((regex_t *) CGEN_INSN_RX (insn), rxbuf, REG_NOSUB);
 
-  if (reg_err == 0) 
+  if (reg_err == 0)
     return NULL;
   else
     {
@@ -676,7 +676,7 @@ lm32_cgen_assemble_insn (CGEN_CPU_DESC cd,
       const CGEN_INSN *insn = ilist->insn;
       recognized_mnemonic = 1;
 
-#ifdef CGEN_VALIDATE_INSN_SUPPORTED 
+#ifdef CGEN_VALIDATE_INSN_SUPPORTED
       /* Not usually needed as unsupported opcodes
 	 shouldn't be in the hash lists.  */
       /* Is this insn supported by the selected cpu?  */
@@ -736,7 +736,7 @@ lm32_cgen_assemble_insn (CGEN_CPU_DESC cd,
 	if (strlen (start) > 50)
 	  /* xgettext:c-format */
 	  sprintf (errbuf, "%s `%.50s...'", tmp_errmsg, start);
-	else 
+	else
 	  /* xgettext:c-format */
 	  sprintf (errbuf, "%s `%.50s'", tmp_errmsg, start);
       }
@@ -745,11 +745,11 @@ lm32_cgen_assemble_insn (CGEN_CPU_DESC cd,
 	if (strlen (start) > 50)
 	  /* xgettext:c-format */
 	  sprintf (errbuf, _("bad instruction `%.50s...'"), start);
-	else 
+	else
 	  /* xgettext:c-format */
 	  sprintf (errbuf, _("bad instruction `%.50s'"), start);
       }
-      
+
     *errmsg = errbuf;
     return NULL;
   }
--- a/opcodes/lm32-desc.c
+++ b/opcodes/lm32-desc.c
@@ -274,75 +274,75 @@ const CGEN_OPERAND lm32_cgen_operand_table[] =
 {
 /* pc: program counter */
   { "pc", LM32_OPERAND_PC, HW_H_PC, 0, 0,
-    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_NIL] } }, 
+    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_NIL] } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* r0: register 0 */
   { "r0", LM32_OPERAND_R0, HW_H_GR, 25, 5,
-    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_R0] } }, 
+    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_R0] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* r1: register 1 */
   { "r1", LM32_OPERAND_R1, HW_H_GR, 20, 5,
-    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_R1] } }, 
+    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_R1] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* r2: register 2 */
   { "r2", LM32_OPERAND_R2, HW_H_GR, 15, 5,
-    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_R2] } }, 
+    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_R2] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* shift: shift amout */
   { "shift", LM32_OPERAND_SHIFT, HW_H_UINT, 4, 5,
-    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_SHIFT] } }, 
+    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_SHIFT] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* imm: signed immediate */
   { "imm", LM32_OPERAND_IMM, HW_H_SINT, 15, 16,
-    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_IMM] } }, 
+    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_IMM] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* uimm: unsigned immediate */
   { "uimm", LM32_OPERAND_UIMM, HW_H_UINT, 15, 16,
-    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_UIMM] } }, 
+    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_UIMM] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* branch: branch offset */
   { "branch", LM32_OPERAND_BRANCH, HW_H_IADDR, 15, 16,
-    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_BRANCH] } }, 
+    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_BRANCH] } },
     { 0|A(PCREL_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
 /* call: call offset */
   { "call", LM32_OPERAND_CALL, HW_H_IADDR, 25, 26,
-    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_CALL] } }, 
+    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_CALL] } },
     { 0|A(PCREL_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
 /* csr: csr */
   { "csr", LM32_OPERAND_CSR, HW_H_CSR, 25, 5,
-    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_CSR] } }, 
+    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_CSR] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* user: user */
   { "user", LM32_OPERAND_USER, HW_H_UINT, 10, 11,
-    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_USER] } }, 
+    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_USER] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* exception: exception */
   { "exception", LM32_OPERAND_EXCEPTION, HW_H_UINT, 25, 26,
-    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_EXCEPTION] } }, 
+    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_EXCEPTION] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* hi16: high 16-bit immediate */
   { "hi16", LM32_OPERAND_HI16, HW_H_UINT, 15, 16,
-    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_UIMM] } }, 
+    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_UIMM] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* lo16: low 16-bit immediate */
   { "lo16", LM32_OPERAND_LO16, HW_H_UINT, 15, 16,
-    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_UIMM] } }, 
+    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_UIMM] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* gp16: gp relative 16-bit immediate */
   { "gp16", LM32_OPERAND_GP16, HW_H_SINT, 15, 16,
-    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_IMM] } }, 
+    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_IMM] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* got16: got 16-bit immediate */
   { "got16", LM32_OPERAND_GOT16, HW_H_SINT, 15, 16,
-    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_IMM] } }, 
+    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_IMM] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* gotoffhi16: got offset high 16-bit immediate */
   { "gotoffhi16", LM32_OPERAND_GOTOFFHI16, HW_H_SINT, 15, 16,
-    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_IMM] } }, 
+    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_IMM] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* gotofflo16: got offset low 16-bit immediate */
   { "gotofflo16", LM32_OPERAND_GOTOFFLO16, HW_H_SINT, 15, 16,
-    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_IMM] } }, 
+    { 0, { (const PTR) &lm32_cgen_ifld_table[LM32_F_IMM] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* sentinel */
   { 0, 0, 0, 0, 0,
@@ -1105,7 +1105,7 @@ lm32_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)
 
   /* Default to not allowing signed overflow.  */
   cd->signed_overflow_ok_p = 0;
-  
+
   return (CGEN_CPU_DESC) cd;
 }
 
@@ -1145,7 +1145,7 @@ lm32_cgen_cpu_close (CGEN_CPU_DESC cd)
       for (i = 0; i < cd->insn_table.num_init_entries; ++i, ++insns)
 	if (CGEN_INSN_RX (insns))
 	  regfree (CGEN_INSN_RX (insns));
-    }  
+    }
 
   if (cd->macro_insn_table.init_entries)
     free ((CGEN_INSN *) cd->macro_insn_table.init_entries);
--- a/opcodes/lm32-dis.c
+++ b/opcodes/lm32-dis.c
@@ -149,7 +149,7 @@ lm32_cgen_print_operand (CGEN_CPU_DESC cd,
   }
 }
 
-cgen_print_fn * const lm32_cgen_print_handlers[] = 
+cgen_print_fn * const lm32_cgen_print_handlers[] =
 {
   print_insn_normal,
 };
@@ -339,7 +339,7 @@ print_insn (CGEN_CPU_DESC cd,
       int length;
       unsigned long insn_value_cropped;
 
-#ifdef CGEN_VALIDATE_INSN_SUPPORTED 
+#ifdef CGEN_VALIDATE_INSN_SUPPORTED
       /* Not needed as insn shouldn't be in hash lists if not supported.  */
       /* Supported by this cpu?  */
       if (! lm32_cgen_insn_supported (cd, insn))
@@ -357,7 +357,7 @@ print_insn (CGEN_CPU_DESC cd,
          relevant part from the buffer. */
       if ((unsigned) (CGEN_INSN_BITSIZE (insn) / 8) < buflen &&
 	  (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
-	insn_value_cropped = bfd_get_bits (buf, CGEN_INSN_BITSIZE (insn), 
+	insn_value_cropped = bfd_get_bits (buf, CGEN_INSN_BITSIZE (insn),
 					   info->endian == BFD_ENDIAN_BIG);
       else
 	insn_value_cropped = insn_value;
@@ -476,7 +476,7 @@ print_insn_lm32 (bfd_vma pc, disassemble_info *info)
   arch = info->arch;
   if (arch == bfd_arch_unknown)
     arch = CGEN_BFD_ARCH;
-   
+
   /* There's no standard way to compute the machine or isa number
      so we leave it to the target.  */
 #ifdef CGEN_COMPUTE_MACH
@@ -517,7 +517,7 @@ print_insn_lm32 (bfd_vma pc, disassemble_info *info)
 	      break;
 	    }
 	}
-    } 
+    }
 
   /* If we haven't initialized yet, initialize the opcode table.  */
   if (! cd)
--- a/opcodes/lm32-ibld.c
+++ b/opcodes/lm32-ibld.c
@@ -154,7 +154,7 @@ insert_normal (CGEN_CPU_DESC cd,
     {
       long minval = - (1L << (length - 1));
       unsigned long maxval = mask;
-      
+
       if ((value > 0 && (unsigned long) value > maxval)
 	  || value < minval)
 	{
@@ -192,7 +192,7 @@ insert_normal (CGEN_CPU_DESC cd,
 	{
 	  long minval = - (1L << (length - 1));
 	  long maxval =   (1L << (length - 1)) - 1;
-	  
+
 	  if (value < minval || value > maxval)
 	    {
 	      sprintf
@@ -739,12 +739,12 @@ lm32_cgen_extract_operand (CGEN_CPU_DESC cd,
   return length;
 }
 
-cgen_insert_fn * const lm32_cgen_insert_handlers[] = 
+cgen_insert_fn * const lm32_cgen_insert_handlers[] =
 {
   insert_insn_normal,
 };
 
-cgen_extract_fn * const lm32_cgen_extract_handlers[] = 
+cgen_extract_fn * const lm32_cgen_extract_handlers[] =
 {
   extract_insn_normal,
 };
--- a/opcodes/lm32-opc.h
+++ b/opcodes/lm32-opc.h
@@ -31,7 +31,7 @@ This file is part of the GNU Binutils and/or GDB, the GNU debugger.
 #define CGEN_VERBOSE_ASSEMBLER_ERRORS
 
 #define CGEN_DIS_HASH_SIZE 64
-#define CGEN_DIS_HASH(buf,value) ((value >> 26) & 0x3f) 
+#define CGEN_DIS_HASH(buf,value) ((value >> 26) & 0x3f)
 
 /* -- asm.c */
 /* Enum declaration for lm32 instruction types.  */
--- a/opcodes/m10200-dis.c
+++ b/opcodes/m10200-dis.c
@@ -20,7 +20,7 @@
 
 #include "sysdep.h"
 #include <stdio.h>
-#include "opcode/mn10200.h" 
+#include "opcode/mn10200.h"
 #include "dis-asm.h"
 #include "opintl.h"
 
@@ -54,7 +54,7 @@ disassemble (bfd_vma memaddr,
 	mysize = 5;
       else
 	abort ();
-	
+
       if (op->format == FMT_2 || op->format == FMT_5)
 	extra_shift = 8;
       else if (op->format == FMT_3
@@ -70,7 +70,7 @@ disassemble (bfd_vma memaddr,
 	  const unsigned char *opindex_ptr;
 	  unsigned int nocomma;
 	  int paren = 0;
-	  
+
 	  match = 1;
 	  (*info->fprintf_func) (info->stream, "%s\t", op->name);
 
@@ -104,7 +104,7 @@ disassemble (bfd_vma memaddr,
 		(*info->fprintf_func) (info->stream, ",");
 
 	      nocomma = 0;
-		
+
 	      if ((operand->flags & MN10200_OPERAND_DREG) != 0)
 		{
 		  value = ((insn >> (operand->shift + extra_shift))
@@ -144,7 +144,7 @@ disassemble (bfd_vma memaddr,
 	      else if ((operand->flags & MN10200_OPERAND_MEMADDR) != 0)
 		(*info->print_address_func) (value, info);
 
-	      else 
+	      else
 		(*info->fprintf_func) (info->stream, "%ld", value);
 	    }
 	  /* All done. */
@@ -157,7 +157,7 @@ disassemble (bfd_vma memaddr,
     (*info->fprintf_func) (info->stream, _("unknown\t0x%04lx"), insn);
 }
 
-int 
+int
 print_insn_mn10200 (bfd_vma memaddr, struct disassemble_info *info)
 {
   int status;
--- a/opcodes/m10200-opc.c
+++ b/opcodes/m10200-opc.c
@@ -24,7 +24,7 @@
 
 const struct mn10200_operand mn10200_operands[] = {
 #define UNUSED	0
-  {0, 0, 0}, 
+  {0, 0, 0},
 
 /* dn register in the first register operand position.  */
 #define DN0      (UNUSED+1)
@@ -130,7 +130,7 @@ const struct mn10200_operand mn10200_operands[] = {
 
 /* Either an open paren or close paren.  */
 #define PAREN	(SIMM16N+1)
-  {0, 0, MN10200_OPERAND_PAREN}, 
+  {0, 0, MN10200_OPERAND_PAREN},
 
 /* dn register that appears in the first and second register positions.  */
 #define DN01     (PAREN+1)
@@ -139,10 +139,10 @@ const struct mn10200_operand mn10200_operands[] = {
 /* an register that appears in the first and second register positions.  */
 #define AN01     (DN01+1)
   {2, 0, MN10200_OPERAND_AREG | MN10200_OPERAND_REPEATED},
-} ; 
+} ;
 
-#define MEM(ADDR) PAREN, ADDR, PAREN 
-#define MEM2(ADDR1,ADDR2) PAREN, ADDR1, ADDR2, PAREN 
+#define MEM(ADDR) PAREN, ADDR, PAREN
+#define MEM2(ADDR1,ADDR2) PAREN, ADDR1, ADDR2, PAREN
 
 /* The opcode table.
 
--- a/opcodes/m10300-opc.c
+++ b/opcodes/m10300-opc.c
@@ -26,7 +26,7 @@
 
 const struct mn10300_operand mn10300_operands[] = {
 #define UNUSED	0
-  {0, 0, 0}, 
+  {0, 0, 0},
 
 /* dn register in the first register operand position.  */
 #define DN0      (UNUSED+1)
@@ -97,7 +97,7 @@ const struct mn10300_operand mn10300_operands[] = {
   {16, 0, MN10300_OPERAND_PROMOTE | MN10300_OPERAND_MEMADDR},
 
 /* 32bit immediate, high 16 bits in the main instruction
-   word, 16bits in the extension word. 
+   word, 16bits in the extension word.
 
    The "bits" field indicates how many bits are in the
    main instruction word for MN10300_OPERAND_SPLIT!  */
@@ -114,7 +114,7 @@ const struct mn10300_operand mn10300_operands[] = {
 
 /* 32bit immediate, high 16 bits in the main instruction
    word, 16bits in the extension word, low 16bits are left
-   shifted 8 places. 
+   shifted 8 places.
 
    The "bits" field indicates how many bits are in the
    main instruction word for MN10300_OPERAND_SPLIT!  */
@@ -131,7 +131,7 @@ const struct mn10300_operand mn10300_operands[] = {
 
 /* 32bit immediate, high 24 bits in the main instruction
    word, 8 in the extension word, low 8 bits are left
-   shifted 16 places. 
+   shifted 16 places.
 
    The "bits" field indicates how many bits are in the
    main instruction word for MN10300_OPERAND_SPLIT!  */
@@ -184,7 +184,7 @@ const struct mn10300_operand mn10300_operands[] = {
 
 /* Either an open paren or close paren.  */
 #define PAREN	(SIMM16+1)
-  {0, 0, MN10300_OPERAND_PAREN}, 
+  {0, 0, MN10300_OPERAND_PAREN},
 
 /* dn register that appears in the first and second register positions.  */
 #define DN01     (PAREN+1)
@@ -270,7 +270,7 @@ const struct mn10300_operand mn10300_operands[] = {
 
 /* + for autoincrement */
 #define PLUS	(XRM2+1)
-  {0, 0, MN10300_OPERAND_PLUS}, 
+  {0, 0, MN10300_OPERAND_PLUS},
 
 #define XRN02      (PLUS+1)
   {4, 0, MN10300_OPERAND_XRREG | MN10300_OPERAND_REPEATED},
@@ -420,12 +420,12 @@ const struct mn10300_operand mn10300_operands[] = {
 #define FDN3      (FDN2+1)
   {5, -12, MN10300_OPERAND_FDREG },
 
-} ; 
+} ;
 
-#define MEM(ADDR) PAREN, ADDR, PAREN 
-#define MEMINC(ADDR) PAREN, ADDR, PLUS, PAREN 
-#define MEMINC2(ADDR,INC) PAREN, ADDR, PLUS, INC, PAREN 
-#define MEM2(ADDR1,ADDR2) PAREN, ADDR1, ADDR2, PAREN 
+#define MEM(ADDR) PAREN, ADDR, PAREN
+#define MEMINC(ADDR) PAREN, ADDR, PLUS, PAREN
+#define MEMINC2(ADDR,INC) PAREN, ADDR, PLUS, INC, PAREN
+#define MEM2(ADDR1,ADDR2) PAREN, ADDR1, ADDR2, PAREN
 
 /* The opcode table.
 
@@ -1666,7 +1666,7 @@ const struct mn10300_opcode mn10300_opcodes[] = {
 { "leq_mov",	0xf7e00008,  0xffff000f,  0x22, FMT_D10, AM33,	 {MEMINC2 (RN4,SIMM4_2), RM6}},
 { "lne_mov",	0xf7e00009,  0xffff000f,  0x22, FMT_D10, AM33,	 {MEMINC2 (RN4,SIMM4_2), RM6}},
 { "lra_mov",	0xf7e0000a,  0xffff000f,  0x22, FMT_D10, AM33,	 {MEMINC2 (RN4,SIMM4_2), RM6}},
- 
+
 { 0, 0, 0, 0, 0, 0, {0}},
 
 } ;
--- a/opcodes/m32c-asm.c
+++ b/opcodes/m32c-asm.c
@@ -58,14 +58,14 @@ m32c_cgen_isa_register (const char **strp)
  {
    int u;
    const char *s = *strp;
-   static char * m32c_register_names [] = 
+   static char * m32c_register_names [] =
      {
        "r0", "r1", "r2", "r3", "r0l", "r0h", "r1l", "r1h",
        "a0", "a1", "r2r0", "r3r1", "sp", "fb", "dct0", "dct1", "flg", "svf",
        "drc0", "drc1", "dmd0", "dmd1", "intb", "svp", "vct", "isp", "dma0",
        "dma1", "dra0", "dra1", "dsa0", "dsa1", 0
      };
- 
+
    for (u = 0; m32c_register_names[u]; u++)
      {
        int len = strlen (m32c_register_names[u]);
@@ -148,7 +148,7 @@ parse_unsigned8 (CGEN_CPU_DESC cd, const char **strp,
       return errmsg;
     }
 
-  if (strncmp (*strp, "0x0", 3) == 0 
+  if (strncmp (*strp, "0x0", 3) == 0
       || (**strp == '0' && *(*strp + 1) != 'x'))
     have_zero = 1;
 
@@ -173,7 +173,7 @@ parse_signed4 (CGEN_CPU_DESC cd, const char **strp,
   signed long value;
   long have_zero = 0;
 
-  if (strncmp (*strp, "0x0", 3) == 0 
+  if (strncmp (*strp, "0x0", 3) == 0
       || (**strp == '0' && *(*strp + 1) != 'x'))
     have_zero = 1;
 
@@ -198,7 +198,7 @@ parse_signed4n (CGEN_CPU_DESC cd, const char **strp,
   signed long value;
   long have_zero = 0;
 
-  if (strncmp (*strp, "0x0", 3) == 0 
+  if (strncmp (*strp, "0x0", 3) == 0
       || (**strp == '0' && *(*strp + 1) != 'x'))
     have_zero = 1;
 
@@ -292,10 +292,10 @@ parse_unsigned16 (CGEN_CPU_DESC cd, const char **strp,
   if (m32c_cgen_isa_register (strp))
     return "Invalid literal"; /* Anything -- will not be seen.  */
 
-  if (strncmp (*strp, "0x0", 3) == 0 
+  if (strncmp (*strp, "0x0", 3) == 0
       || (**strp == '0' && *(*strp + 1) != 'x'))
     have_zero = 1;
-  
+
   errmsg = cgen_parse_unsigned_integer (cd, strp, opindex, & value);
   if (errmsg)
     return errmsg;
@@ -381,7 +381,7 @@ parse_unsigned20 (CGEN_CPU_DESC cd, const char **strp,
 {
   const char *errmsg = 0;
   unsigned long value;
-  
+
   /* Don't successfully parse literals beginning with '['.  */
   if (**strp == '[')
     return "Invalid literal"; /* Anything -- will not be seen.  */
@@ -407,7 +407,7 @@ parse_unsigned24 (CGEN_CPU_DESC cd, const char **strp,
 {
   const char *errmsg = 0;
   unsigned long value;
-  
+
   /* Don't successfully parse literals beginning with '['.  */
   if (**strp == '[')
     return "Invalid literal"; /* Anything -- will not be seen.  */
@@ -453,7 +453,7 @@ parse_signed32 (CGEN_CPU_DESC cd, const char **strp,
 {
   const char *errmsg = 0;
   signed long value;
-  
+
   errmsg = cgen_parse_signed_integer (cd, strp, opindex, & value);
   if (errmsg)
     return errmsg;
@@ -486,7 +486,7 @@ parse_imm3_S (CGEN_CPU_DESC cd, const char **strp,
 {
   const char *errmsg = 0;
   signed long value;
-  
+
   errmsg = cgen_parse_signed_integer (cd, strp, opindex, & value);
   if (errmsg)
     return errmsg;
@@ -504,7 +504,7 @@ parse_bit3_S (CGEN_CPU_DESC cd, const char **strp,
 {
   const char *errmsg = 0;
   signed long value;
-  
+
   errmsg = cgen_parse_signed_integer (cd, strp, opindex, & value);
   if (errmsg)
     return errmsg;
@@ -591,7 +591,7 @@ parse_unsigned_bitbase (CGEN_CPU_DESC cd, const char **strp,
 
   ++newp;
 
-  if (strncmp (newp, "0x0", 3) == 0 
+  if (strncmp (newp, "0x0", 3) == 0
       || (newp[0] == '0' && newp[1] != 'x'))
     have_zero = 1;
 
@@ -646,7 +646,7 @@ parse_signed_bitbase (CGEN_CPU_DESC cd, const char **strp,
 
   ++newp;
 
-  if (strncmp (newp, "0x0", 3) == 0 
+  if (strncmp (newp, "0x0", 3) == 0
       || (newp[0] == '0' && newp[1] != 'x'))
     have_zero = 1;
 
@@ -731,7 +731,7 @@ static const char *
 parse_suffix (const char **strp, char suffix)
 {
   const char *newp = *strp;
-  
+
   if (**strp == ':' && TOLOWER (*(*strp + 1)) == suffix)
     newp = *strp + 2;
 
@@ -740,7 +740,7 @@ parse_suffix (const char **strp, char suffix)
       *strp = newp;
       return 0;
     }
-	
+
   return "Invalid suffix"; /* Anything -- will not be seen.  */
 }
 
@@ -859,7 +859,7 @@ parse_regset (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 {
   const char *errmsg = 0;
   int regno = 0;
- 
+
   *valuep = 0;
   while (**strp && **strp != ')')
     {
@@ -878,19 +878,19 @@ parse_regset (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	    errmsg = _("Register number is not valid");
 	  regno = **strp - '0' + 4;
 	}
-      
+
       else if (strncasecmp (*strp, "sb", 2) == 0 || strncasecmp (*strp, "SB", 2) == 0)
 	{
 	  regno = 6;
 	  ++*strp;
 	}
-      
+
       else if (strncasecmp (*strp, "fb", 2) == 0 || strncasecmp (*strp, "FB", 2) == 0)
 	{
 	  regno = 7;
 	  ++*strp;
 	}
-      
+
       if (push) /* Mask is reversed for push.  */
 	*valuep |= 0x80 >> regno;
       else
@@ -1587,7 +1587,7 @@ m32c_cgen_parse_operand (CGEN_CPU_DESC cd,
   return errmsg;
 }
 
-cgen_parse_fn * const m32c_cgen_parse_handlers[] = 
+cgen_parse_fn * const m32c_cgen_parse_handlers[] =
 {
   parse_insn_normal,
 };
@@ -1617,9 +1617,9 @@ CGEN_ASM_INIT_HOOK
 
    Returns NULL for success, an error message for failure.  */
 
-char * 
+char *
 m32c_cgen_build_insn_regex (CGEN_INSN *insn)
-{  
+{
   CGEN_OPCODE *opc = (CGEN_OPCODE *) CGEN_INSN_OPCODE (insn);
   const char *mnem = CGEN_INSN_MNEMONIC (insn);
   char rxbuf[CGEN_MAX_RX_ELEMENTS];
@@ -1658,18 +1658,18 @@ m32c_cgen_build_insn_regex (CGEN_INSN *insn)
   /* Copy any remaining literals from the syntax string into the rx.  */
   for(; * syn != 0 && rx <= rxbuf + (CGEN_MAX_RX_ELEMENTS - 7 - 4); ++syn)
     {
-      if (CGEN_SYNTAX_CHAR_P (* syn)) 
+      if (CGEN_SYNTAX_CHAR_P (* syn))
 	{
 	  char c = CGEN_SYNTAX_CHAR (* syn);
 
-	  switch (c) 
+	  switch (c)
 	    {
 	      /* Escape any regex metacharacters in the syntax.  */
-	    case '.': case '[': case '\\': 
-	    case '*': case '^': case '$': 
+	    case '.': case '[': case '\\':
+	    case '*': case '^': case '$':
 
 #ifdef CGEN_ESCAPE_EXTENDED_REGEX
-	    case '?': case '{': case '}': 
+	    case '?': case '{': case '}':
 	    case '(': case ')': case '*':
 	    case '|': case '+': case ']':
 #endif
@@ -1699,20 +1699,20 @@ m32c_cgen_build_insn_regex (CGEN_INSN *insn)
     }
 
   /* Trailing whitespace ok.  */
-  * rx++ = '['; 
-  * rx++ = ' '; 
-  * rx++ = '\t'; 
-  * rx++ = ']'; 
-  * rx++ = '*'; 
+  * rx++ = '[';
+  * rx++ = ' ';
+  * rx++ = '\t';
+  * rx++ = ']';
+  * rx++ = '*';
 
   /* But anchor it after that.  */
-  * rx++ = '$'; 
+  * rx++ = '$';
   * rx = '\0';
 
   CGEN_INSN_RX (insn) = xmalloc (sizeof (regex_t));
   reg_err = regcomp ((regex_t *) CGEN_INSN_RX (insn), rxbuf, REG_NOSUB);
 
-  if (reg_err == 0) 
+  if (reg_err == 0)
     return NULL;
   else
     {
@@ -1911,7 +1911,7 @@ m32c_cgen_assemble_insn (CGEN_CPU_DESC cd,
       const CGEN_INSN *insn = ilist->insn;
       recognized_mnemonic = 1;
 
-#ifdef CGEN_VALIDATE_INSN_SUPPORTED 
+#ifdef CGEN_VALIDATE_INSN_SUPPORTED
       /* Not usually needed as unsupported opcodes
 	 shouldn't be in the hash lists.  */
       /* Is this insn supported by the selected cpu?  */
@@ -1971,7 +1971,7 @@ m32c_cgen_assemble_insn (CGEN_CPU_DESC cd,
 	if (strlen (start) > 50)
 	  /* xgettext:c-format */
 	  sprintf (errbuf, "%s `%.50s...'", tmp_errmsg, start);
-	else 
+	else
 	  /* xgettext:c-format */
 	  sprintf (errbuf, "%s `%.50s'", tmp_errmsg, start);
       }
@@ -1980,11 +1980,11 @@ m32c_cgen_assemble_insn (CGEN_CPU_DESC cd,
 	if (strlen (start) > 50)
 	  /* xgettext:c-format */
 	  sprintf (errbuf, _("bad instruction `%.50s...'"), start);
-	else 
+	else
 	  /* xgettext:c-format */
 	  sprintf (errbuf, _("bad instruction `%.50s'"), start);
       }
-      
+
     *errmsg = errbuf;
     return NULL;
   }
--- a/opcodes/m32c-desc.c
+++ b/opcodes/m32c-desc.c
@@ -1163,839 +1163,839 @@ const CGEN_OPERAND m32c_cgen_operand_table[] =
 {
 /* pc: program counter */
   { "pc", M32C_OPERAND_PC, HW_H_PC, 0, 0,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_NIL] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_NIL] } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Src16RnQI: general register QI view */
   { "Src16RnQI", M32C_OPERAND_SRC16RNQI, HW_H_GR_QI, 10, 2,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_SRC16_RN] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_SRC16_RN] } },
     { 0, { { { (1<<MACH_M16C), 0 } }, { { 1, "\x80" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Src16RnHI: general register QH view */
   { "Src16RnHI", M32C_OPERAND_SRC16RNHI, HW_H_GR_HI, 10, 2,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_SRC16_RN] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_SRC16_RN] } },
     { 0, { { { (1<<MACH_M16C), 0 } }, { { 1, "\x80" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Src32RnUnprefixedQI: general register QI view */
   { "Src32RnUnprefixedQI", M32C_OPERAND_SRC32RNUNPREFIXEDQI, HW_H_GR_QI, 10, 2,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_SRC32_RN_UNPREFIXED_QI] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_SRC32_RN_UNPREFIXED_QI] } },
     { 0, { { { (1<<MACH_M32C), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Src32RnUnprefixedHI: general register HI view */
   { "Src32RnUnprefixedHI", M32C_OPERAND_SRC32RNUNPREFIXEDHI, HW_H_GR_HI, 10, 2,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_SRC32_RN_UNPREFIXED_HI] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_SRC32_RN_UNPREFIXED_HI] } },
     { 0, { { { (1<<MACH_M32C), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Src32RnUnprefixedSI: general register SI view */
   { "Src32RnUnprefixedSI", M32C_OPERAND_SRC32RNUNPREFIXEDSI, HW_H_GR_SI, 10, 2,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_SRC32_RN_UNPREFIXED_SI] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_SRC32_RN_UNPREFIXED_SI] } },
     { 0, { { { (1<<MACH_M32C), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Src32RnPrefixedQI: general register QI view */
   { "Src32RnPrefixedQI", M32C_OPERAND_SRC32RNPREFIXEDQI, HW_H_GR_QI, 18, 2,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_SRC32_RN_PREFIXED_QI] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_SRC32_RN_PREFIXED_QI] } },
     { 0, { { { (1<<MACH_M32C), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Src32RnPrefixedHI: general register HI view */
   { "Src32RnPrefixedHI", M32C_OPERAND_SRC32RNPREFIXEDHI, HW_H_GR_HI, 18, 2,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_SRC32_RN_PREFIXED_HI] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_SRC32_RN_PREFIXED_HI] } },
     { 0, { { { (1<<MACH_M32C), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Src32RnPrefixedSI: general register SI view */
   { "Src32RnPrefixedSI", M32C_OPERAND_SRC32RNPREFIXEDSI, HW_H_GR_SI, 18, 2,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_SRC32_RN_PREFIXED_SI] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_SRC32_RN_PREFIXED_SI] } },
     { 0, { { { (1<<MACH_M32C), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Src16An: address register */
   { "Src16An", M32C_OPERAND_SRC16AN, HW_H_AR, 11, 1,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_SRC16_AN] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_SRC16_AN] } },
     { 0, { { { (1<<MACH_M16C), 0 } }, { { 1, "\x80" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Src16AnQI: address register QI view */
   { "Src16AnQI", M32C_OPERAND_SRC16ANQI, HW_H_AR_QI, 11, 1,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_SRC16_AN] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_SRC16_AN] } },
     { 0, { { { (1<<MACH_M16C), 0 } }, { { 1, "\x80" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Src16AnHI: address register HI view */
   { "Src16AnHI", M32C_OPERAND_SRC16ANHI, HW_H_AR_HI, 11, 1,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_SRC16_AN] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_SRC16_AN] } },
     { 0, { { { (1<<MACH_M16C), 0 } }, { { 1, "\x80" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Src32AnUnprefixed: address register */
   { "Src32AnUnprefixed", M32C_OPERAND_SRC32ANUNPREFIXED, HW_H_AR, 11, 1,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_SRC32_AN_UNPREFIXED] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_SRC32_AN_UNPREFIXED] } },
     { 0, { { { (1<<MACH_M32C), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Src32AnUnprefixedQI: address register QI view */
   { "Src32AnUnprefixedQI", M32C_OPERAND_SRC32ANUNPREFIXEDQI, HW_H_AR_QI, 11, 1,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_SRC32_AN_UNPREFIXED] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_SRC32_AN_UNPREFIXED] } },
     { 0, { { { (1<<MACH_M32C), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Src32AnUnprefixedHI: address register HI view */
   { "Src32AnUnprefixedHI", M32C_OPERAND_SRC32ANUNPREFIXEDHI, HW_H_AR_HI, 11, 1,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_SRC32_AN_UNPREFIXED] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_SRC32_AN_UNPREFIXED] } },
     { 0, { { { (1<<MACH_M32C), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Src32AnUnprefixedSI: address register SI view */
   { "Src32AnUnprefixedSI", M32C_OPERAND_SRC32ANUNPREFIXEDSI, HW_H_AR, 11, 1,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_SRC32_AN_UNPREFIXED] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_SRC32_AN_UNPREFIXED] } },
     { 0, { { { (1<<MACH_M32C), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Src32AnPrefixed: address register */
   { "Src32AnPrefixed", M32C_OPERAND_SRC32ANPREFIXED, HW_H_AR, 19, 1,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_SRC32_AN_PREFIXED] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_SRC32_AN_PREFIXED] } },
     { 0, { { { (1<<MACH_M32C), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Src32AnPrefixedQI: address register QI view */
   { "Src32AnPrefixedQI", M32C_OPERAND_SRC32ANPREFIXEDQI, HW_H_AR_QI, 19, 1,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_SRC32_AN_PREFIXED] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_SRC32_AN_PREFIXED] } },
     { 0, { { { (1<<MACH_M32C), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Src32AnPrefixedHI: address register HI view */
   { "Src32AnPrefixedHI", M32C_OPERAND_SRC32ANPREFIXEDHI, HW_H_AR_HI, 19, 1,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_SRC32_AN_PREFIXED] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_SRC32_AN_PREFIXED] } },
     { 0, { { { (1<<MACH_M32C), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Src32AnPrefixedSI: address register SI view */
   { "Src32AnPrefixedSI", M32C_OPERAND_SRC32ANPREFIXEDSI, HW_H_AR, 19, 1,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_SRC32_AN_PREFIXED] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_SRC32_AN_PREFIXED] } },
     { 0, { { { (1<<MACH_M32C), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dst16RnQI: general register QI view */
   { "Dst16RnQI", M32C_OPERAND_DST16RNQI, HW_H_GR_QI, 14, 2,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST16_RN] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST16_RN] } },
     { 0, { { { (1<<MACH_M16C), 0 } }, { { 1, "\x80" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dst16RnHI: general register HI view */
   { "Dst16RnHI", M32C_OPERAND_DST16RNHI, HW_H_GR_HI, 14, 2,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST16_RN] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST16_RN] } },
     { 0, { { { (1<<MACH_M16C), 0 } }, { { 1, "\x80" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dst16RnSI: general register SI view */
   { "Dst16RnSI", M32C_OPERAND_DST16RNSI, HW_H_GR_SI, 14, 2,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST16_RN] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST16_RN] } },
     { 0, { { { (1<<MACH_M16C), 0 } }, { { 1, "\x80" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dst16RnExtQI: general register QI/HI view for 'ext' insns */
   { "Dst16RnExtQI", M32C_OPERAND_DST16RNEXTQI, HW_H_GR_EXT_QI, 14, 1,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST16_RN_EXT] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST16_RN_EXT] } },
     { 0, { { { (1<<MACH_M16C), 0 } }, { { 1, "\x80" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dst32R0QI-S: general register QI view */
   { "Dst32R0QI-S", M32C_OPERAND_DST32R0QI_S, HW_H_R0L, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_M32C), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dst32R0HI-S: general register HI view */
   { "Dst32R0HI-S", M32C_OPERAND_DST32R0HI_S, HW_H_R0, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_M32C), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dst32RnUnprefixedQI: general register QI view */
   { "Dst32RnUnprefixedQI", M32C_OPERAND_DST32RNUNPREFIXEDQI, HW_H_GR_QI, 8, 2,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST32_RN_UNPREFIXED_QI] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST32_RN_UNPREFIXED_QI] } },
     { 0, { { { (1<<MACH_M32C), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dst32RnUnprefixedHI: general register HI view */
   { "Dst32RnUnprefixedHI", M32C_OPERAND_DST32RNUNPREFIXEDHI, HW_H_GR_HI, 8, 2,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST32_RN_UNPREFIXED_HI] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST32_RN_UNPREFIXED_HI] } },
     { 0, { { { (1<<MACH_M32C), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dst32RnUnprefixedSI: general register SI view */
   { "Dst32RnUnprefixedSI", M32C_OPERAND_DST32RNUNPREFIXEDSI, HW_H_GR_SI, 8, 2,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST32_RN_UNPREFIXED_SI] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST32_RN_UNPREFIXED_SI] } },
     { 0, { { { (1<<MACH_M32C), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dst32RnExtUnprefixedQI: general register QI view */
   { "Dst32RnExtUnprefixedQI", M32C_OPERAND_DST32RNEXTUNPREFIXEDQI, HW_H_GR_EXT_QI, 9, 1,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST32_RN_EXT_UNPREFIXED] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST32_RN_EXT_UNPREFIXED] } },
     { 0, { { { (1<<MACH_M32C), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dst32RnExtUnprefixedHI: general register HI view */
   { "Dst32RnExtUnprefixedHI", M32C_OPERAND_DST32RNEXTUNPREFIXEDHI, HW_H_GR_EXT_HI, 9, 1,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST32_RN_EXT_UNPREFIXED] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST32_RN_EXT_UNPREFIXED] } },
     { 0, { { { (1<<MACH_M32C), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dst32RnPrefixedQI: general register QI view */
   { "Dst32RnPrefixedQI", M32C_OPERAND_DST32RNPREFIXEDQI, HW_H_GR_QI, 16, 2,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST32_RN_PREFIXED_QI] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST32_RN_PREFIXED_QI] } },
     { 0, { { { (1<<MACH_M32C), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dst32RnPrefixedHI: general register HI view */
   { "Dst32RnPrefixedHI", M32C_OPERAND_DST32RNPREFIXEDHI, HW_H_GR_HI, 16, 2,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST32_RN_PREFIXED_HI] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST32_RN_PREFIXED_HI] } },
     { 0, { { { (1<<MACH_M32C), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dst32RnPrefixedSI: general register SI view */
   { "Dst32RnPrefixedSI", M32C_OPERAND_DST32RNPREFIXEDSI, HW_H_GR_SI, 16, 2,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST32_RN_PREFIXED_SI] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST32_RN_PREFIXED_SI] } },
     { 0, { { { (1<<MACH_M32C), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dst16RnQI-S: general register QI view */
   { "Dst16RnQI-S", M32C_OPERAND_DST16RNQI_S, HW_H_R0L_R0H, 5, 1,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST16_RN_QI_S] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST16_RN_QI_S] } },
     { 0, { { { (1<<MACH_M16C), 0 } }, { { 1, "\x80" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dst16AnQI-S: address register QI view */
   { "Dst16AnQI-S", M32C_OPERAND_DST16ANQI_S, HW_H_AR_QI, 5, 1,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST16_RN_QI_S] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST16_RN_QI_S] } },
     { 0, { { { (1<<MACH_M16C), 0 } }, { { 1, "\x80" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Bit16Rn: general register bit view */
   { "Bit16Rn", M32C_OPERAND_BIT16RN, HW_H_GR_HI, 14, 2,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST16_RN] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST16_RN] } },
     { 0, { { { (1<<MACH_M16C), 0 } }, { { 1, "\x80" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Bit32RnPrefixed: general register bit view */
   { "Bit32RnPrefixed", M32C_OPERAND_BIT32RNPREFIXED, HW_H_GR_QI, 16, 2,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST32_RN_PREFIXED_QI] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST32_RN_PREFIXED_QI] } },
     { 0, { { { (1<<MACH_M32C), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Bit32RnUnprefixed: general register bit view */
   { "Bit32RnUnprefixed", M32C_OPERAND_BIT32RNUNPREFIXED, HW_H_GR_QI, 8, 2,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST32_RN_UNPREFIXED_QI] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST32_RN_UNPREFIXED_QI] } },
     { 0, { { { (1<<MACH_M32C), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* R0: r0 */
   { "R0", M32C_OPERAND_R0, HW_H_R0, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* R1: r1 */
   { "R1", M32C_OPERAND_R1, HW_H_R1, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* R2: r2 */
   { "R2", M32C_OPERAND_R2, HW_H_R2, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* R3: r3 */
   { "R3", M32C_OPERAND_R3, HW_H_R3, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* R0l: r0l */
   { "R0l", M32C_OPERAND_R0L, HW_H_R0L, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* R0h: r0h */
   { "R0h", M32C_OPERAND_R0H, HW_H_R0H, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* R2R0: r2r0 */
   { "R2R0", M32C_OPERAND_R2R0, HW_H_R2R0, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* R3R1: r3r1 */
   { "R3R1", M32C_OPERAND_R3R1, HW_H_R3R1, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* R1R2R0: r1r2r0 */
   { "R1R2R0", M32C_OPERAND_R1R2R0, HW_H_R1R2R0, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dst16An: address register */
   { "Dst16An", M32C_OPERAND_DST16AN, HW_H_AR, 15, 1,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST16_AN] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST16_AN] } },
     { 0, { { { (1<<MACH_M16C), 0 } }, { { 1, "\x80" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dst16AnQI: address register QI view */
   { "Dst16AnQI", M32C_OPERAND_DST16ANQI, HW_H_AR_QI, 15, 1,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST16_AN] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST16_AN] } },
     { 0, { { { (1<<MACH_M16C), 0 } }, { { 1, "\x80" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dst16AnHI: address register HI view */
   { "Dst16AnHI", M32C_OPERAND_DST16ANHI, HW_H_AR_HI, 15, 1,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST16_AN] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST16_AN] } },
     { 0, { { { (1<<MACH_M16C), 0 } }, { { 1, "\x80" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dst16AnSI: address register SI view */
   { "Dst16AnSI", M32C_OPERAND_DST16ANSI, HW_H_AR_SI, 15, 1,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST16_AN] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST16_AN] } },
     { 0, { { { (1<<MACH_M16C), 0 } }, { { 1, "\x80" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dst16An-S: address register HI view */
   { "Dst16An-S", M32C_OPERAND_DST16AN_S, HW_H_AR_HI, 4, 1,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST16_AN_S] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST16_AN_S] } },
     { 0, { { { (1<<MACH_M16C), 0 } }, { { 1, "\x80" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dst32AnUnprefixed: address register */
   { "Dst32AnUnprefixed", M32C_OPERAND_DST32ANUNPREFIXED, HW_H_AR, 9, 1,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST32_AN_UNPREFIXED] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST32_AN_UNPREFIXED] } },
     { 0, { { { (1<<MACH_M32C), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dst32AnUnprefixedQI: address register QI view */
   { "Dst32AnUnprefixedQI", M32C_OPERAND_DST32ANUNPREFIXEDQI, HW_H_AR_QI, 9, 1,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST32_AN_UNPREFIXED] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST32_AN_UNPREFIXED] } },
     { 0, { { { (1<<MACH_M32C), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dst32AnUnprefixedHI: address register HI view */
   { "Dst32AnUnprefixedHI", M32C_OPERAND_DST32ANUNPREFIXEDHI, HW_H_AR_HI, 9, 1,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST32_AN_UNPREFIXED] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST32_AN_UNPREFIXED] } },
     { 0, { { { (1<<MACH_M32C), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dst32AnUnprefixedSI: address register SI view */
   { "Dst32AnUnprefixedSI", M32C_OPERAND_DST32ANUNPREFIXEDSI, HW_H_AR, 9, 1,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST32_AN_UNPREFIXED] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST32_AN_UNPREFIXED] } },
     { 0, { { { (1<<MACH_M32C), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dst32AnExtUnprefixed: address register */
   { "Dst32AnExtUnprefixed", M32C_OPERAND_DST32ANEXTUNPREFIXED, HW_H_AR, 9, 1,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST32_AN_UNPREFIXED] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST32_AN_UNPREFIXED] } },
     { 0, { { { (1<<MACH_M32C), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dst32AnPrefixed: address register */
   { "Dst32AnPrefixed", M32C_OPERAND_DST32ANPREFIXED, HW_H_AR, 17, 1,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST32_AN_PREFIXED] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST32_AN_PREFIXED] } },
     { 0, { { { (1<<MACH_M32C), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dst32AnPrefixedQI: address register QI view */
   { "Dst32AnPrefixedQI", M32C_OPERAND_DST32ANPREFIXEDQI, HW_H_AR_QI, 17, 1,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST32_AN_PREFIXED] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST32_AN_PREFIXED] } },
     { 0, { { { (1<<MACH_M32C), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dst32AnPrefixedHI: address register HI view */
   { "Dst32AnPrefixedHI", M32C_OPERAND_DST32ANPREFIXEDHI, HW_H_AR_HI, 17, 1,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST32_AN_PREFIXED] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST32_AN_PREFIXED] } },
     { 0, { { { (1<<MACH_M32C), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dst32AnPrefixedSI: address register SI view */
   { "Dst32AnPrefixedSI", M32C_OPERAND_DST32ANPREFIXEDSI, HW_H_AR, 17, 1,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST32_AN_PREFIXED] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST32_AN_PREFIXED] } },
     { 0, { { { (1<<MACH_M32C), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Bit16An: address register bit view */
   { "Bit16An", M32C_OPERAND_BIT16AN, HW_H_AR, 15, 1,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST16_AN] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST16_AN] } },
     { 0, { { { (1<<MACH_M16C), 0 } }, { { 1, "\x80" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Bit32AnPrefixed: address register bit */
   { "Bit32AnPrefixed", M32C_OPERAND_BIT32ANPREFIXED, HW_H_AR, 17, 1,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST32_AN_PREFIXED] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST32_AN_PREFIXED] } },
     { 0, { { { (1<<MACH_M32C), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Bit32AnUnprefixed: address register bit */
   { "Bit32AnUnprefixed", M32C_OPERAND_BIT32ANUNPREFIXED, HW_H_AR, 9, 1,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST32_AN_UNPREFIXED] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DST32_AN_UNPREFIXED] } },
     { 0, { { { (1<<MACH_M32C), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* A0: a0 */
   { "A0", M32C_OPERAND_A0, HW_H_A0, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* A1: a1 */
   { "A1", M32C_OPERAND_A1, HW_H_A1, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* sb: SB register */
   { "sb", M32C_OPERAND_SB, HW_H_SB, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* fb: FB register */
   { "fb", M32C_OPERAND_FB, HW_H_FB, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* sp: SP register */
   { "sp", M32C_OPERAND_SP, HW_H_SP, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* SrcDst16-r0l-r0h-S-normal: r0l/r0h pair */
   { "SrcDst16-r0l-r0h-S-normal", M32C_OPERAND_SRCDST16_R0L_R0H_S_NORMAL, HW_H_SINT, 5, 1,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_5_1] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_5_1] } },
     { 0, { { { (1<<MACH_M16C), 0 } }, { { 1, "\x80" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Regsetpop: popm regset */
   { "Regsetpop", M32C_OPERAND_REGSETPOP, HW_H_UINT, 8, 8,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_8_8] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_8_8] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Regsetpush: pushm regset */
   { "Regsetpush", M32C_OPERAND_REGSETPUSH, HW_H_UINT, 8, 8,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_8_8] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_8_8] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Rn16-push-S: r0[lh] */
   { "Rn16-push-S", M32C_OPERAND_RN16_PUSH_S, HW_H_GR_QI, 4, 1,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_4_1] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_4_1] } },
     { 0, { { { (1<<MACH_M16C), 0 } }, { { 1, "\x80" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* An16-push-S: a[01] */
   { "An16-push-S", M32C_OPERAND_AN16_PUSH_S, HW_H_AR_HI, 4, 1,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_4_1] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_4_1] } },
     { 0, { { { (1<<MACH_M16C), 0 } }, { { 1, "\x80" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dsp-8-u6: unsigned 6 bit displacement at offset 8 bits */
   { "Dsp-8-u6", M32C_OPERAND_DSP_8_U6, HW_H_UINT, 8, 6,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_8_U6] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_8_U6] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dsp-8-u8: unsigned 8 bit displacement at offset 8 bits */
   { "Dsp-8-u8", M32C_OPERAND_DSP_8_U8, HW_H_UINT, 8, 8,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_8_U8] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_8_U8] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dsp-8-u16: unsigned 16 bit displacement at offset 8 bits */
   { "Dsp-8-u16", M32C_OPERAND_DSP_8_U16, HW_H_UINT, 8, 16,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_8_U16] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_8_U16] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dsp-8-s8: signed 8 bit displacement at offset 8 bits */
   { "Dsp-8-s8", M32C_OPERAND_DSP_8_S8, HW_H_SINT, 8, 8,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_8_S8] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_8_S8] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dsp-8-s24: signed 24 bit displacement at offset 8 bits */
   { "Dsp-8-s24", M32C_OPERAND_DSP_8_S24, HW_H_SINT, 8, 24,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_8_S24] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_8_S24] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dsp-8-u24: unsigned 24 bit displacement at offset 8 bits */
   { "Dsp-8-u24", M32C_OPERAND_DSP_8_U24, HW_H_UINT, 8, 24,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_8_U24] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_8_U24] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dsp-10-u6: unsigned 6 bit displacement at offset 10 bits */
   { "Dsp-10-u6", M32C_OPERAND_DSP_10_U6, HW_H_UINT, 10, 6,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_10_U6] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_10_U6] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dsp-16-u8: unsigned 8 bit displacement at offset 16 bits */
   { "Dsp-16-u8", M32C_OPERAND_DSP_16_U8, HW_H_UINT, 16, 8,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_16_U8] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_16_U8] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dsp-16-u16: unsigned 16 bit displacement at offset 16 bits */
   { "Dsp-16-u16", M32C_OPERAND_DSP_16_U16, HW_H_UINT, 16, 16,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_16_U16] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_16_U16] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dsp-16-u20: unsigned 20 bit displacement at offset 16 bits */
   { "Dsp-16-u20", M32C_OPERAND_DSP_16_U20, HW_H_UINT, 0, 24,
-    { 2, { (const PTR) &M32C_F_DSP_16_U24_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &M32C_F_DSP_16_U24_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dsp-16-u24: unsigned 24 bit displacement at offset 16 bits */
   { "Dsp-16-u24", M32C_OPERAND_DSP_16_U24, HW_H_UINT, 0, 24,
-    { 2, { (const PTR) &M32C_F_DSP_16_U24_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &M32C_F_DSP_16_U24_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dsp-16-s8: signed 8 bit displacement at offset 16 bits */
   { "Dsp-16-s8", M32C_OPERAND_DSP_16_S8, HW_H_SINT, 16, 8,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_16_S8] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_16_S8] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dsp-16-s16: signed 16 bit displacement at offset 16 bits */
   { "Dsp-16-s16", M32C_OPERAND_DSP_16_S16, HW_H_SINT, 16, 16,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_16_S16] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_16_S16] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dsp-24-u8: unsigned 8 bit displacement at offset 24 bits */
   { "Dsp-24-u8", M32C_OPERAND_DSP_24_U8, HW_H_UINT, 24, 8,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_24_U8] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_24_U8] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dsp-24-u16: unsigned 16 bit displacement at offset 24 bits */
   { "Dsp-24-u16", M32C_OPERAND_DSP_24_U16, HW_H_UINT, 0, 16,
-    { 2, { (const PTR) &M32C_F_DSP_24_U16_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &M32C_F_DSP_24_U16_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dsp-24-u20: unsigned 20 bit displacement at offset 24 bits */
   { "Dsp-24-u20", M32C_OPERAND_DSP_24_U20, HW_H_UINT, 0, 24,
-    { 2, { (const PTR) &M32C_F_DSP_24_U24_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &M32C_F_DSP_24_U24_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dsp-24-u24: unsigned 24 bit displacement at offset 24 bits */
   { "Dsp-24-u24", M32C_OPERAND_DSP_24_U24, HW_H_UINT, 0, 24,
-    { 2, { (const PTR) &M32C_F_DSP_24_U24_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &M32C_F_DSP_24_U24_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dsp-24-s8: signed 8 bit displacement at offset 24 bits */
   { "Dsp-24-s8", M32C_OPERAND_DSP_24_S8, HW_H_SINT, 24, 8,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_24_S8] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_24_S8] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dsp-24-s16: signed 16 bit displacement at offset 24 bits */
   { "Dsp-24-s16", M32C_OPERAND_DSP_24_S16, HW_H_SINT, 0, 16,
-    { 2, { (const PTR) &M32C_F_DSP_24_S16_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &M32C_F_DSP_24_S16_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dsp-32-u8: unsigned 8 bit displacement at offset 32 bits */
   { "Dsp-32-u8", M32C_OPERAND_DSP_32_U8, HW_H_UINT, 0, 8,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_32_U8] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_32_U8] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dsp-32-u16: unsigned 16 bit displacement at offset 32 bits */
   { "Dsp-32-u16", M32C_OPERAND_DSP_32_U16, HW_H_UINT, 0, 16,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_32_U16] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_32_U16] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dsp-32-u24: unsigned 24 bit displacement at offset 32 bits */
   { "Dsp-32-u24", M32C_OPERAND_DSP_32_U24, HW_H_UINT, 0, 24,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_32_U24] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_32_U24] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dsp-32-u20: unsigned 20 bit displacement at offset 32 bits */
   { "Dsp-32-u20", M32C_OPERAND_DSP_32_U20, HW_H_UINT, 0, 24,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_32_U24] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_32_U24] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dsp-32-s8: signed 8 bit displacement at offset 32 bits */
   { "Dsp-32-s8", M32C_OPERAND_DSP_32_S8, HW_H_SINT, 0, 8,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_32_S8] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_32_S8] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dsp-32-s16: signed 16 bit displacement at offset 32 bits */
   { "Dsp-32-s16", M32C_OPERAND_DSP_32_S16, HW_H_SINT, 0, 16,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_32_S16] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_32_S16] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dsp-40-u8: unsigned 8 bit displacement at offset 40 bits */
   { "Dsp-40-u8", M32C_OPERAND_DSP_40_U8, HW_H_UINT, 8, 8,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_40_U8] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_40_U8] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dsp-40-s8: signed 8 bit displacement at offset 40 bits */
   { "Dsp-40-s8", M32C_OPERAND_DSP_40_S8, HW_H_SINT, 8, 8,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_40_S8] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_40_S8] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dsp-40-u16: unsigned 16 bit displacement at offset 40 bits */
   { "Dsp-40-u16", M32C_OPERAND_DSP_40_U16, HW_H_UINT, 8, 16,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_40_U16] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_40_U16] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dsp-40-s16: signed 16 bit displacement at offset 40 bits */
   { "Dsp-40-s16", M32C_OPERAND_DSP_40_S16, HW_H_SINT, 8, 16,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_40_S16] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_40_S16] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dsp-40-u20: unsigned 20 bit displacement at offset 40 bits */
   { "Dsp-40-u20", M32C_OPERAND_DSP_40_U20, HW_H_UINT, 8, 20,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_40_U20] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_40_U20] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dsp-40-u24: unsigned 24 bit displacement at offset 40 bits */
   { "Dsp-40-u24", M32C_OPERAND_DSP_40_U24, HW_H_UINT, 8, 24,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_40_U24] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_40_U24] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dsp-48-u8: unsigned 8 bit displacement at offset 48 bits */
   { "Dsp-48-u8", M32C_OPERAND_DSP_48_U8, HW_H_UINT, 16, 8,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_48_U8] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_48_U8] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dsp-48-s8: signed 8 bit displacement at offset 48 bits */
   { "Dsp-48-s8", M32C_OPERAND_DSP_48_S8, HW_H_SINT, 16, 8,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_48_S8] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_48_S8] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dsp-48-u16: unsigned 16 bit displacement at offset 48 bits */
   { "Dsp-48-u16", M32C_OPERAND_DSP_48_U16, HW_H_UINT, 16, 16,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_48_U16] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_48_U16] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dsp-48-s16: signed 16 bit displacement at offset 48 bits */
   { "Dsp-48-s16", M32C_OPERAND_DSP_48_S16, HW_H_SINT, 16, 16,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_48_S16] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_48_S16] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dsp-48-u20: unsigned 24 bit displacement at offset 40 bits */
   { "Dsp-48-u20", M32C_OPERAND_DSP_48_U20, HW_H_UINT, 0, 24,
-    { 2, { (const PTR) &M32C_F_DSP_48_U20_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &M32C_F_DSP_48_U20_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Dsp-48-u24: unsigned 24 bit displacement at offset 48 bits */
   { "Dsp-48-u24", M32C_OPERAND_DSP_48_U24, HW_H_UINT, 0, 24,
-    { 2, { (const PTR) &M32C_F_DSP_48_U24_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &M32C_F_DSP_48_U24_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Imm-8-s4: signed 4 bit immediate at offset 8 bits */
   { "Imm-8-s4", M32C_OPERAND_IMM_8_S4, HW_H_SINT, 8, 4,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_IMM_8_S4] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_IMM_8_S4] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Imm-8-s4n: negated 4 bit immediate at offset 8 bits */
   { "Imm-8-s4n", M32C_OPERAND_IMM_8_S4N, HW_H_SINT, 8, 4,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_IMM_8_S4] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_IMM_8_S4] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Imm-sh-8-s4: signed 4 bit shift immediate at offset 8 bits */
   { "Imm-sh-8-s4", M32C_OPERAND_IMM_SH_8_S4, HW_H_SHIMM, 8, 4,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_IMM_8_S4] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_IMM_8_S4] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Imm-8-QI: signed 8 bit immediate at offset 8 bits */
   { "Imm-8-QI", M32C_OPERAND_IMM_8_QI, HW_H_SINT, 8, 8,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_8_S8] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_8_S8] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Imm-8-HI: signed 16 bit immediate at offset 8 bits */
   { "Imm-8-HI", M32C_OPERAND_IMM_8_HI, HW_H_SINT, 8, 16,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_8_S16] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_8_S16] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Imm-12-s4: signed 4 bit immediate at offset 12 bits */
   { "Imm-12-s4", M32C_OPERAND_IMM_12_S4, HW_H_SINT, 12, 4,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_IMM_12_S4] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_IMM_12_S4] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Imm-12-s4n: negated 4 bit immediate at offset 12 bits */
   { "Imm-12-s4n", M32C_OPERAND_IMM_12_S4N, HW_H_SINT, 12, 4,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_IMM_12_S4] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_IMM_12_S4] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Imm-sh-12-s4: signed 4 bit shift immediate at offset 12 bits */
   { "Imm-sh-12-s4", M32C_OPERAND_IMM_SH_12_S4, HW_H_SHIMM, 12, 4,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_IMM_12_S4] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_IMM_12_S4] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Imm-13-u3: signed 3 bit immediate at offset 13 bits */
   { "Imm-13-u3", M32C_OPERAND_IMM_13_U3, HW_H_SINT, 13, 3,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_IMM_13_U3] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_IMM_13_U3] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Imm-20-s4: signed 4 bit immediate at offset 20 bits */
   { "Imm-20-s4", M32C_OPERAND_IMM_20_S4, HW_H_SINT, 20, 4,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_IMM_20_S4] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_IMM_20_S4] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Imm-sh-20-s4: signed 4 bit shift immediate at offset 12 bits */
   { "Imm-sh-20-s4", M32C_OPERAND_IMM_SH_20_S4, HW_H_SHIMM, 20, 4,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_IMM_20_S4] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_IMM_20_S4] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Imm-16-QI: signed 8 bit immediate at offset 16 bits */
   { "Imm-16-QI", M32C_OPERAND_IMM_16_QI, HW_H_SINT, 16, 8,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_16_S8] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_16_S8] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Imm-16-HI: signed 16 bit immediate at offset 16 bits */
   { "Imm-16-HI", M32C_OPERAND_IMM_16_HI, HW_H_SINT, 16, 16,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_16_S16] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_16_S16] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Imm-16-SI: signed 32 bit immediate at offset 16 bits */
   { "Imm-16-SI", M32C_OPERAND_IMM_16_SI, HW_H_SINT, 0, 32,
-    { 2, { (const PTR) &M32C_F_DSP_16_S32_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &M32C_F_DSP_16_S32_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Imm-24-QI: signed 8 bit immediate at offset 24 bits */
   { "Imm-24-QI", M32C_OPERAND_IMM_24_QI, HW_H_SINT, 24, 8,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_24_S8] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_24_S8] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Imm-24-HI: signed 16 bit immediate at offset 24 bits */
   { "Imm-24-HI", M32C_OPERAND_IMM_24_HI, HW_H_SINT, 0, 16,
-    { 2, { (const PTR) &M32C_F_DSP_24_S16_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &M32C_F_DSP_24_S16_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Imm-24-SI: signed 32 bit immediate at offset 24 bits */
   { "Imm-24-SI", M32C_OPERAND_IMM_24_SI, HW_H_SINT, 0, 32,
-    { 2, { (const PTR) &M32C_F_DSP_24_S32_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &M32C_F_DSP_24_S32_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Imm-32-QI: signed 8 bit immediate at offset 32 bits */
   { "Imm-32-QI", M32C_OPERAND_IMM_32_QI, HW_H_SINT, 0, 8,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_32_S8] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_32_S8] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Imm-32-SI: signed 32 bit immediate at offset 32 bits */
   { "Imm-32-SI", M32C_OPERAND_IMM_32_SI, HW_H_SINT, 0, 32,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_32_S32] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_32_S32] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Imm-32-HI: signed 16 bit immediate at offset 32 bits */
   { "Imm-32-HI", M32C_OPERAND_IMM_32_HI, HW_H_SINT, 0, 16,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_32_S16] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_32_S16] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Imm-40-QI: signed 8 bit immediate at offset 40 bits */
   { "Imm-40-QI", M32C_OPERAND_IMM_40_QI, HW_H_SINT, 8, 8,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_40_S8] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_40_S8] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Imm-40-HI: signed 16 bit immediate at offset 40 bits */
   { "Imm-40-HI", M32C_OPERAND_IMM_40_HI, HW_H_SINT, 8, 16,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_40_S16] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_40_S16] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Imm-40-SI: signed 32 bit immediate at offset 40 bits */
   { "Imm-40-SI", M32C_OPERAND_IMM_40_SI, HW_H_SINT, 0, 32,
-    { 2, { (const PTR) &M32C_F_DSP_40_S32_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &M32C_F_DSP_40_S32_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Imm-48-QI: signed 8 bit immediate at offset 48 bits */
   { "Imm-48-QI", M32C_OPERAND_IMM_48_QI, HW_H_SINT, 16, 8,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_48_S8] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_48_S8] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Imm-48-HI: signed 16 bit immediate at offset 48 bits */
   { "Imm-48-HI", M32C_OPERAND_IMM_48_HI, HW_H_SINT, 16, 16,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_48_S16] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_48_S16] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Imm-48-SI: signed 32 bit immediate at offset 48 bits */
   { "Imm-48-SI", M32C_OPERAND_IMM_48_SI, HW_H_SINT, 0, 32,
-    { 2, { (const PTR) &M32C_F_DSP_48_S32_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &M32C_F_DSP_48_S32_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Imm-56-QI: signed 8 bit immediate at offset 56 bits */
   { "Imm-56-QI", M32C_OPERAND_IMM_56_QI, HW_H_SINT, 24, 8,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_56_S8] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_56_S8] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Imm-56-HI: signed 16 bit immediate at offset 56 bits */
   { "Imm-56-HI", M32C_OPERAND_IMM_56_HI, HW_H_SINT, 0, 16,
-    { 2, { (const PTR) &M32C_F_DSP_56_S16_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &M32C_F_DSP_56_S16_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Imm-64-HI: signed 16 bit immediate at offset 64 bits */
   { "Imm-64-HI", M32C_OPERAND_IMM_64_HI, HW_H_SINT, 0, 16,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_64_S16] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_64_S16] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Imm1-S: signed 1 bit immediate for short format binary insns */
   { "Imm1-S", M32C_OPERAND_IMM1_S, HW_H_SINT, 2, 1,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_IMM1_S] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_IMM1_S] } },
     { 0, { { { (1<<MACH_M32C), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Imm3-S: signed 3 bit immediate for short format binary insns */
   { "Imm3-S", M32C_OPERAND_IMM3_S, HW_H_SINT, 2, 3,
-    { 2, { (const PTR) &M32C_F_IMM3_S_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &M32C_F_IMM3_S_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Bit3-S: 3 bit bit number */
   { "Bit3-S", M32C_OPERAND_BIT3_S, HW_H_SINT, 2, 3,
-    { 2, { (const PTR) &M32C_F_IMM3_S_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &M32C_F_IMM3_S_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Bitno16R: bit number for indexing registers */
   { "Bitno16R", M32C_OPERAND_BITNO16R, HW_H_UINT, 16, 8,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_16_U8] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_16_U8] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\x80" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Bitno32Prefixed: bit number for indexing objects */
   { "Bitno32Prefixed", M32C_OPERAND_BITNO32PREFIXED, HW_H_UINT, 21, 3,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_BITNO32_PREFIXED] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_BITNO32_PREFIXED] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Bitno32Unprefixed: bit number for indexing objects */
   { "Bitno32Unprefixed", M32C_OPERAND_BITNO32UNPREFIXED, HW_H_UINT, 13, 3,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_BITNO32_UNPREFIXED] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_BITNO32_UNPREFIXED] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* BitBase16-16-u8: unsigned bit,base:8 at offset 16for m16c */
   { "BitBase16-16-u8", M32C_OPERAND_BITBASE16_16_U8, HW_H_UINT, 16, 8,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_16_U8] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_16_U8] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\x80" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* BitBase16-16-s8: signed bit,base:8 at offset 16for m16c */
   { "BitBase16-16-s8", M32C_OPERAND_BITBASE16_16_S8, HW_H_SINT, 16, 8,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_16_S8] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_16_S8] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\x80" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* BitBase16-16-u16: unsigned bit,base:16 at offset 16 for m16c */
   { "BitBase16-16-u16", M32C_OPERAND_BITBASE16_16_U16, HW_H_UINT, 16, 16,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_16_U16] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_16_U16] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\x80" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* BitBase16-8-u11-S: signed bit,base:11 at offset 16 for m16c */
   { "BitBase16-8-u11-S", M32C_OPERAND_BITBASE16_8_U11_S, HW_H_UINT, 5, 11,
-    { 2, { (const PTR) &M32C_F_BITBASE16_U11_S_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &M32C_F_BITBASE16_U11_S_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, "\x80" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* BitBase32-16-u11-Unprefixed: unsigned bit,base:11 at offset 16 for m32c */
   { "BitBase32-16-u11-Unprefixed", M32C_OPERAND_BITBASE32_16_U11_UNPREFIXED, HW_H_UINT, 13, 11,
-    { 2, { (const PTR) &M32C_F_BITBASE32_16_U11_UNPREFIXED_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &M32C_F_BITBASE32_16_U11_UNPREFIXED_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* BitBase32-16-s11-Unprefixed: signed bit,base:11 at offset 16 for m32c */
   { "BitBase32-16-s11-Unprefixed", M32C_OPERAND_BITBASE32_16_S11_UNPREFIXED, HW_H_SINT, 13, 11,
-    { 2, { (const PTR) &M32C_F_BITBASE32_16_S11_UNPREFIXED_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &M32C_F_BITBASE32_16_S11_UNPREFIXED_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* BitBase32-16-u19-Unprefixed: unsigned bit,base:19 at offset 16 for m32c */
   { "BitBase32-16-u19-Unprefixed", M32C_OPERAND_BITBASE32_16_U19_UNPREFIXED, HW_H_UINT, 13, 19,
-    { 2, { (const PTR) &M32C_F_BITBASE32_16_U19_UNPREFIXED_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &M32C_F_BITBASE32_16_U19_UNPREFIXED_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* BitBase32-16-s19-Unprefixed: signed bit,base:19 at offset 16 for m32c */
   { "BitBase32-16-s19-Unprefixed", M32C_OPERAND_BITBASE32_16_S19_UNPREFIXED, HW_H_SINT, 13, 19,
-    { 2, { (const PTR) &M32C_F_BITBASE32_16_S19_UNPREFIXED_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &M32C_F_BITBASE32_16_S19_UNPREFIXED_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* BitBase32-16-u27-Unprefixed: unsigned bit,base:27 at offset 16 for m32c */
   { "BitBase32-16-u27-Unprefixed", M32C_OPERAND_BITBASE32_16_U27_UNPREFIXED, HW_H_UINT, 0, 27,
-    { 3, { (const PTR) &M32C_F_BITBASE32_16_U27_UNPREFIXED_MULTI_IFIELD[0] } }, 
+    { 3, { (const PTR) &M32C_F_BITBASE32_16_U27_UNPREFIXED_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* BitBase32-24-u11-Prefixed: unsigned bit,base:11 at offset 24 for m32c */
   { "BitBase32-24-u11-Prefixed", M32C_OPERAND_BITBASE32_24_U11_PREFIXED, HW_H_UINT, 21, 11,
-    { 2, { (const PTR) &M32C_F_BITBASE32_24_U11_PREFIXED_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &M32C_F_BITBASE32_24_U11_PREFIXED_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* BitBase32-24-s11-Prefixed: signed bit,base:11 at offset 24 for m32c */
   { "BitBase32-24-s11-Prefixed", M32C_OPERAND_BITBASE32_24_S11_PREFIXED, HW_H_SINT, 21, 11,
-    { 2, { (const PTR) &M32C_F_BITBASE32_24_S11_PREFIXED_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &M32C_F_BITBASE32_24_S11_PREFIXED_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* BitBase32-24-u19-Prefixed: unsigned bit,base:19 at offset 24 for m32c */
   { "BitBase32-24-u19-Prefixed", M32C_OPERAND_BITBASE32_24_U19_PREFIXED, HW_H_UINT, 0, 19,
-    { 3, { (const PTR) &M32C_F_BITBASE32_24_U19_PREFIXED_MULTI_IFIELD[0] } }, 
+    { 3, { (const PTR) &M32C_F_BITBASE32_24_U19_PREFIXED_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* BitBase32-24-s19-Prefixed: signed bit,base:19 at offset 24 for m32c */
   { "BitBase32-24-s19-Prefixed", M32C_OPERAND_BITBASE32_24_S19_PREFIXED, HW_H_SINT, 0, 19,
-    { 3, { (const PTR) &M32C_F_BITBASE32_24_S19_PREFIXED_MULTI_IFIELD[0] } }, 
+    { 3, { (const PTR) &M32C_F_BITBASE32_24_S19_PREFIXED_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* BitBase32-24-u27-Prefixed: unsigned bit,base:27 at offset 24 for m32c */
   { "BitBase32-24-u27-Prefixed", M32C_OPERAND_BITBASE32_24_U27_PREFIXED, HW_H_UINT, 0, 27,
-    { 3, { (const PTR) &M32C_F_BITBASE32_24_U27_PREFIXED_MULTI_IFIELD[0] } }, 
+    { 3, { (const PTR) &M32C_F_BITBASE32_24_U27_PREFIXED_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Lab-5-3: 3 bit label */
   { "Lab-5-3", M32C_OPERAND_LAB_5_3, HW_H_IADDR, 5, 3,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_LAB_5_3] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_LAB_5_3] } },
     { 0|A(RELAX)|A(PCREL_ADDR), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Lab32-jmp-s: 3 bit label */
   { "Lab32-jmp-s", M32C_OPERAND_LAB32_JMP_S, HW_H_IADDR, 2, 3,
-    { 2, { (const PTR) &M32C_F_LAB32_JMP_S_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &M32C_F_LAB32_JMP_S_MULTI_IFIELD[0] } },
     { 0|A(RELAX)|A(PCREL_ADDR)|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Lab-8-8: 8 bit label */
   { "Lab-8-8", M32C_OPERAND_LAB_8_8, HW_H_IADDR, 8, 8,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_LAB_8_8] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_LAB_8_8] } },
     { 0|A(RELAX)|A(PCREL_ADDR), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Lab-8-16: 16 bit label */
   { "Lab-8-16", M32C_OPERAND_LAB_8_16, HW_H_IADDR, 8, 16,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_LAB_8_16] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_LAB_8_16] } },
     { 0|A(RELAX)|A(SIGN_OPT)|A(PCREL_ADDR), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Lab-8-24: 24 bit label */
   { "Lab-8-24", M32C_OPERAND_LAB_8_24, HW_H_IADDR, 8, 24,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_LAB_8_24] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_LAB_8_24] } },
     { 0|A(RELAX)|A(ABS_ADDR), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Lab-16-8: 8 bit label */
   { "Lab-16-8", M32C_OPERAND_LAB_16_8, HW_H_IADDR, 16, 8,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_LAB_16_8] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_LAB_16_8] } },
     { 0|A(RELAX)|A(PCREL_ADDR), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Lab-24-8: 8 bit label */
   { "Lab-24-8", M32C_OPERAND_LAB_24_8, HW_H_IADDR, 24, 8,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_LAB_24_8] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_LAB_24_8] } },
     { 0|A(RELAX)|A(PCREL_ADDR), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Lab-32-8: 8 bit label */
   { "Lab-32-8", M32C_OPERAND_LAB_32_8, HW_H_IADDR, 0, 8,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_LAB_32_8] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_LAB_32_8] } },
     { 0|A(RELAX)|A(PCREL_ADDR), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Lab-40-8: 8 bit label */
   { "Lab-40-8", M32C_OPERAND_LAB_40_8, HW_H_IADDR, 8, 8,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_LAB_40_8] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_LAB_40_8] } },
     { 0|A(RELAX)|A(PCREL_ADDR), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* sbit: negative    bit */
   { "sbit", M32C_OPERAND_SBIT, HW_H_SBIT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* obit: overflow    bit */
   { "obit", M32C_OPERAND_OBIT, HW_H_OBIT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* zbit: zero        bit */
   { "zbit", M32C_OPERAND_ZBIT, HW_H_ZBIT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* cbit: carry       bit */
   { "cbit", M32C_OPERAND_CBIT, HW_H_CBIT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* ubit: stack ptr select bit */
   { "ubit", M32C_OPERAND_UBIT, HW_H_UBIT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* ibit: interrupt enable bit */
   { "ibit", M32C_OPERAND_IBIT, HW_H_IBIT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* bbit: reg bank select bit */
   { "bbit", M32C_OPERAND_BBIT, HW_H_BBIT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* dbit: debug       bit */
   { "dbit", M32C_OPERAND_DBIT, HW_H_DBIT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* cond16-16: condition */
   { "cond16-16", M32C_OPERAND_COND16_16, HW_H_COND16, 16, 8,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_16_U8] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_16_U8] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\x80" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* cond16-24: condition */
   { "cond16-24", M32C_OPERAND_COND16_24, HW_H_COND16, 24, 8,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_24_U8] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_24_U8] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\x80" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* cond16-32: condition */
   { "cond16-32", M32C_OPERAND_COND16_32, HW_H_COND16, 0, 8,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_32_U8] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_32_U8] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\x80" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* cond32-16: condition */
   { "cond32-16", M32C_OPERAND_COND32_16, HW_H_COND32, 16, 8,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_16_U8] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_16_U8] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* cond32-24: condition */
   { "cond32-24", M32C_OPERAND_COND32_24, HW_H_COND32, 24, 8,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_24_U8] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_24_U8] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* cond32-32: condition */
   { "cond32-32", M32C_OPERAND_COND32_32, HW_H_COND32, 0, 8,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_32_U8] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_32_U8] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* cond32-40: condition */
   { "cond32-40", M32C_OPERAND_COND32_40, HW_H_COND32, 8, 8,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_40_U8] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_DSP_40_U8] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* cond16c: condition */
   { "cond16c", M32C_OPERAND_COND16C, HW_H_COND16C, 12, 4,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_COND16] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_COND16] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\x80" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* cond16j: condition */
   { "cond16j", M32C_OPERAND_COND16J, HW_H_COND16J, 12, 4,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_COND16] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_COND16] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\x80" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* cond16j5: condition */
   { "cond16j5", M32C_OPERAND_COND16J5, HW_H_COND16J_5, 5, 3,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_COND16J_5] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_COND16J_5] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\x80" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* cond32: condition */
   { "cond32", M32C_OPERAND_COND32, HW_H_COND32, 9, 4,
-    { 2, { (const PTR) &M32C_F_COND32_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &M32C_F_COND32_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* cond32j: condition */
   { "cond32j", M32C_OPERAND_COND32J, HW_H_COND32, 1, 4,
-    { 2, { (const PTR) &M32C_F_COND32J_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &M32C_F_COND32J_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* sccond32: scCND condition */
   { "sccond32", M32C_OPERAND_SCCOND32, HW_H_COND32, 12, 4,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_COND16] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_COND16] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* flags16: flags */
   { "flags16", M32C_OPERAND_FLAGS16, HW_H_FLAGS, 9, 3,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_9_3] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_9_3] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\x80" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* flags32: flags */
   { "flags32", M32C_OPERAND_FLAGS32, HW_H_FLAGS, 13, 3,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_13_3] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_13_3] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* cr16: control */
   { "cr16", M32C_OPERAND_CR16, HW_H_CR_16, 9, 3,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_9_3] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_9_3] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\x80" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* cr1-Unprefixed-32: control */
   { "cr1-Unprefixed-32", M32C_OPERAND_CR1_UNPREFIXED_32, HW_H_CR1_32, 13, 3,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_13_3] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_13_3] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* cr1-Prefixed-32: control */
   { "cr1-Prefixed-32", M32C_OPERAND_CR1_PREFIXED_32, HW_H_CR1_32, 21, 3,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_21_3] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_21_3] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* cr2-32: control */
   { "cr2-32", M32C_OPERAND_CR2_32, HW_H_CR2_32, 13, 3,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_13_3] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_13_3] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* cr3-Unprefixed-32: control */
   { "cr3-Unprefixed-32", M32C_OPERAND_CR3_UNPREFIXED_32, HW_H_CR3_32, 13, 3,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_13_3] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_13_3] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* cr3-Prefixed-32: control */
   { "cr3-Prefixed-32", M32C_OPERAND_CR3_PREFIXED_32, HW_H_CR3_32, 21, 3,
-    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_21_3] } }, 
+    { 0, { (const PTR) &m32c_cgen_ifld_table[M32C_F_21_3] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Z: Suffix for zero format insns */
   { "Z", M32C_OPERAND_Z, HW_H_SINT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* S: Suffix for short format insns */
   { "S", M32C_OPERAND_S, HW_H_SINT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* Q: Suffix for quick format insns */
   { "Q", M32C_OPERAND_Q, HW_H_SINT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* G: Suffix for general format insns */
   { "G", M32C_OPERAND_G, HW_H_SINT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* X: Empty suffix */
   { "X", M32C_OPERAND_X, HW_H_SINT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* size: any size specifier */
   { "size", M32C_OPERAND_SIZE, HW_H_SINT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xc0" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* BitIndex: Bit Index for the next insn */
   { "BitIndex", M32C_OPERAND_BITINDEX, HW_H_BIT_INDEX, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_M32C), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* SrcIndex: Source Index for the next insn */
   { "SrcIndex", M32C_OPERAND_SRCINDEX, HW_H_SRC_INDEX, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_M32C), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* DstIndex: Destination Index for the next insn */
   { "DstIndex", M32C_OPERAND_DSTINDEX, HW_H_DST_INDEX, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_M32C), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* NoRemainder: Place holder for when the remainder is not kept */
   { "NoRemainder", M32C_OPERAND_NOREMAINDER, HW_H_NONE, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_M32C), 0 } }, { { 1, "\x40" } }, { { RL_TYPE_NONE, 0 } } } }  },
 /* src16-Rn-direct-QI: m16c Rn direct source QI */
 /* src16-Rn-direct-HI: m16c Rn direct source HI */
@@ -63136,7 +63136,7 @@ m32c_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)
 
   /* Default to not allowing signed overflow.  */
   cd->signed_overflow_ok_p = 0;
-  
+
   return (CGEN_CPU_DESC) cd;
 }
 
@@ -63176,7 +63176,7 @@ m32c_cgen_cpu_close (CGEN_CPU_DESC cd)
       for (i = 0; i < cd->insn_table.num_init_entries; ++i, ++insns)
 	if (CGEN_INSN_RX (insns))
 	  regfree (CGEN_INSN_RX (insns));
-    }  
+    }
 
   if (cd->macro_insn_table.init_entries)
     free ((CGEN_INSN *) cd->macro_insn_table.init_entries);
--- a/opcodes/m32c-dis.c
+++ b/opcodes/m32c-dis.c
@@ -203,7 +203,7 @@ print_regset (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
 	      int length ATTRIBUTE_UNUSED,
 	      int push)
 {
-  static char * m16c_register_names [] = 
+  static char * m16c_register_names [] =
   {
     "r0", "r1", "r2", "r3", "a0", "a1", "sb", "fb"
   };
@@ -216,7 +216,7 @@ print_regset (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
     mask = 0x80;
   else
     mask = 1;
- 
+
   if (value & mask)
     {
       (*info->fprintf_func) (info->stream, "%s", m16c_register_names [0]);
@@ -893,7 +893,7 @@ m32c_cgen_print_operand (CGEN_CPU_DESC cd,
   }
 }
 
-cgen_print_fn * const m32c_cgen_print_handlers[] = 
+cgen_print_fn * const m32c_cgen_print_handlers[] =
 {
   print_insn_normal,
 };
@@ -1083,7 +1083,7 @@ print_insn (CGEN_CPU_DESC cd,
       int length;
       unsigned long insn_value_cropped;
 
-#ifdef CGEN_VALIDATE_INSN_SUPPORTED 
+#ifdef CGEN_VALIDATE_INSN_SUPPORTED
       /* Not needed as insn shouldn't be in hash lists if not supported.  */
       /* Supported by this cpu?  */
       if (! m32c_cgen_insn_supported (cd, insn))
@@ -1101,7 +1101,7 @@ print_insn (CGEN_CPU_DESC cd,
          relevant part from the buffer. */
       if ((unsigned) (CGEN_INSN_BITSIZE (insn) / 8) < buflen &&
 	  (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
-	insn_value_cropped = bfd_get_bits (buf, CGEN_INSN_BITSIZE (insn), 
+	insn_value_cropped = bfd_get_bits (buf, CGEN_INSN_BITSIZE (insn),
 					   info->endian == BFD_ENDIAN_BIG);
       else
 	insn_value_cropped = insn_value;
@@ -1220,7 +1220,7 @@ print_insn_m32c (bfd_vma pc, disassemble_info *info)
   arch = info->arch;
   if (arch == bfd_arch_unknown)
     arch = CGEN_BFD_ARCH;
-   
+
   /* There's no standard way to compute the machine or isa number
      so we leave it to the target.  */
 #ifdef CGEN_COMPUTE_MACH
@@ -1261,7 +1261,7 @@ print_insn_m32c (bfd_vma pc, disassemble_info *info)
 	      break;
 	    }
 	}
-    } 
+    }
 
   /* If we haven't initialized yet, initialize the opcode table.  */
   if (! cd)
--- a/opcodes/m32c-ibld.c
+++ b/opcodes/m32c-ibld.c
@@ -154,7 +154,7 @@ insert_normal (CGEN_CPU_DESC cd,
     {
       long minval = - (1L << (length - 1));
       unsigned long maxval = mask;
-      
+
       if ((value > 0 && (unsigned long) value > maxval)
 	  || value < minval)
 	{
@@ -192,7 +192,7 @@ insert_normal (CGEN_CPU_DESC cd,
 	{
 	  long minval = - (1L << (length - 1));
 	  long maxval =   (1L << (length - 1)) - 1;
-	  
+
 	  if (value < minval || value > maxval)
 	    {
 	      sprintf
@@ -2893,12 +2893,12 @@ m32c_cgen_extract_operand (CGEN_CPU_DESC cd,
   return length;
 }
 
-cgen_insert_fn * const m32c_cgen_insert_handlers[] = 
+cgen_insert_fn * const m32c_cgen_insert_handlers[] =
 {
   insert_insn_normal,
 };
 
-cgen_extract_fn * const m32c_cgen_extract_handlers[] = 
+cgen_extract_fn * const m32c_cgen_extract_handlers[] =
 {
   extract_insn_normal,
 };
--- a/opcodes/m32c-opc.c
+++ b/opcodes/m32c-opc.c
@@ -35,19 +35,19 @@ static unsigned int
 m32c_asm_hash (const char *mnem)
 {
   unsigned int h;
-  
+
   /* The length of the mnemonic for the Jcnd insns is 1.  Hash jsri.  */
   if (mnem[0] == 'j' && mnem[1] != 's')
     return 'j';
-  
+
   /* Don't hash scCND  */
   if (mnem[0] == 's' && mnem[1] == 'c')
     return 's';
-  
+
   /* Don't hash bmCND  */
   if (mnem[0] == 'b' && mnem[1] == 'm')
     return 'b';
-  
+
   for (h = 0; *mnem && *mnem != ' ' && *mnem != ':'; ++mnem)
     h += *mnem;
   return h % CGEN_ASM_HASH_SIZE;
--- a/opcodes/m32r-asm.c
+++ b/opcodes/m32r-asm.c
@@ -331,7 +331,7 @@ m32r_cgen_parse_operand (CGEN_CPU_DESC cd,
   return errmsg;
 }
 
-cgen_parse_fn * const m32r_cgen_parse_handlers[] = 
+cgen_parse_fn * const m32r_cgen_parse_handlers[] =
 {
   parse_insn_normal,
 };
@@ -361,9 +361,9 @@ CGEN_ASM_INIT_HOOK
 
    Returns NULL for success, an error message for failure.  */
 
-char * 
+char *
 m32r_cgen_build_insn_regex (CGEN_INSN *insn)
-{  
+{
   CGEN_OPCODE *opc = (CGEN_OPCODE *) CGEN_INSN_OPCODE (insn);
   const char *mnem = CGEN_INSN_MNEMONIC (insn);
   char rxbuf[CGEN_MAX_RX_ELEMENTS];
@@ -402,18 +402,18 @@ m32r_cgen_build_insn_regex (CGEN_INSN *insn)
   /* Copy any remaining literals from the syntax string into the rx.  */
   for(; * syn != 0 && rx <= rxbuf + (CGEN_MAX_RX_ELEMENTS - 7 - 4); ++syn)
     {
-      if (CGEN_SYNTAX_CHAR_P (* syn)) 
+      if (CGEN_SYNTAX_CHAR_P (* syn))
 	{
 	  char c = CGEN_SYNTAX_CHAR (* syn);
 
-	  switch (c) 
+	  switch (c)
 	    {
 	      /* Escape any regex metacharacters in the syntax.  */
-	    case '.': case '[': case '\\': 
-	    case '*': case '^': case '$': 
+	    case '.': case '[': case '\\':
+	    case '*': case '^': case '$':
 
 #ifdef CGEN_ESCAPE_EXTENDED_REGEX
-	    case '?': case '{': case '}': 
+	    case '?': case '{': case '}':
 	    case '(': case ')': case '*':
 	    case '|': case '+': case ']':
 #endif
@@ -443,20 +443,20 @@ m32r_cgen_build_insn_regex (CGEN_INSN *insn)
     }
 
   /* Trailing whitespace ok.  */
-  * rx++ = '['; 
-  * rx++ = ' '; 
-  * rx++ = '\t'; 
-  * rx++ = ']'; 
-  * rx++ = '*'; 
+  * rx++ = '[';
+  * rx++ = ' ';
+  * rx++ = '\t';
+  * rx++ = ']';
+  * rx++ = '*';
 
   /* But anchor it after that.  */
-  * rx++ = '$'; 
+  * rx++ = '$';
   * rx = '\0';
 
   CGEN_INSN_RX (insn) = xmalloc (sizeof (regex_t));
   reg_err = regcomp ((regex_t *) CGEN_INSN_RX (insn), rxbuf, REG_NOSUB);
 
-  if (reg_err == 0) 
+  if (reg_err == 0)
     return NULL;
   else
     {
@@ -655,7 +655,7 @@ m32r_cgen_assemble_insn (CGEN_CPU_DESC cd,
       const CGEN_INSN *insn = ilist->insn;
       recognized_mnemonic = 1;
 
-#ifdef CGEN_VALIDATE_INSN_SUPPORTED 
+#ifdef CGEN_VALIDATE_INSN_SUPPORTED
       /* Not usually needed as unsupported opcodes
 	 shouldn't be in the hash lists.  */
       /* Is this insn supported by the selected cpu?  */
@@ -715,7 +715,7 @@ m32r_cgen_assemble_insn (CGEN_CPU_DESC cd,
 	if (strlen (start) > 50)
 	  /* xgettext:c-format */
 	  sprintf (errbuf, "%s `%.50s...'", tmp_errmsg, start);
-	else 
+	else
 	  /* xgettext:c-format */
 	  sprintf (errbuf, "%s `%.50s'", tmp_errmsg, start);
       }
@@ -724,11 +724,11 @@ m32r_cgen_assemble_insn (CGEN_CPU_DESC cd,
 	if (strlen (start) > 50)
 	  /* xgettext:c-format */
 	  sprintf (errbuf, _("bad instruction `%.50s...'"), start);
-	else 
+	else
 	  /* xgettext:c-format */
 	  sprintf (errbuf, _("bad instruction `%.50s'"), start);
       }
-      
+
     *errmsg = errbuf;
     return NULL;
   }
--- a/opcodes/m32r-desc.c
+++ b/opcodes/m32r-desc.c
@@ -312,115 +312,115 @@ const CGEN_OPERAND m32r_cgen_operand_table[] =
 {
 /* pc: program counter */
   { "pc", M32R_OPERAND_PC, HW_H_PC, 0, 0,
-    { 0, { (const PTR) &m32r_cgen_ifld_table[M32R_F_NIL] } }, 
+    { 0, { (const PTR) &m32r_cgen_ifld_table[M32R_F_NIL] } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* sr: source register */
   { "sr", M32R_OPERAND_SR, HW_H_GR, 12, 4,
-    { 0, { (const PTR) &m32r_cgen_ifld_table[M32R_F_R2] } }, 
+    { 0, { (const PTR) &m32r_cgen_ifld_table[M32R_F_R2] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* dr: destination register */
   { "dr", M32R_OPERAND_DR, HW_H_GR, 4, 4,
-    { 0, { (const PTR) &m32r_cgen_ifld_table[M32R_F_R1] } }, 
+    { 0, { (const PTR) &m32r_cgen_ifld_table[M32R_F_R1] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* src1: source register 1 */
   { "src1", M32R_OPERAND_SRC1, HW_H_GR, 4, 4,
-    { 0, { (const PTR) &m32r_cgen_ifld_table[M32R_F_R1] } }, 
+    { 0, { (const PTR) &m32r_cgen_ifld_table[M32R_F_R1] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* src2: source register 2 */
   { "src2", M32R_OPERAND_SRC2, HW_H_GR, 12, 4,
-    { 0, { (const PTR) &m32r_cgen_ifld_table[M32R_F_R2] } }, 
+    { 0, { (const PTR) &m32r_cgen_ifld_table[M32R_F_R2] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* scr: source control register */
   { "scr", M32R_OPERAND_SCR, HW_H_CR, 12, 4,
-    { 0, { (const PTR) &m32r_cgen_ifld_table[M32R_F_R2] } }, 
+    { 0, { (const PTR) &m32r_cgen_ifld_table[M32R_F_R2] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* dcr: destination control register */
   { "dcr", M32R_OPERAND_DCR, HW_H_CR, 4, 4,
-    { 0, { (const PTR) &m32r_cgen_ifld_table[M32R_F_R1] } }, 
+    { 0, { (const PTR) &m32r_cgen_ifld_table[M32R_F_R1] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* simm8: 8 bit signed immediate */
   { "simm8", M32R_OPERAND_SIMM8, HW_H_SINT, 8, 8,
-    { 0, { (const PTR) &m32r_cgen_ifld_table[M32R_F_SIMM8] } }, 
+    { 0, { (const PTR) &m32r_cgen_ifld_table[M32R_F_SIMM8] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* simm16: 16 bit signed immediate */
   { "simm16", M32R_OPERAND_SIMM16, HW_H_SINT, 16, 16,
-    { 0, { (const PTR) &m32r_cgen_ifld_table[M32R_F_SIMM16] } }, 
+    { 0, { (const PTR) &m32r_cgen_ifld_table[M32R_F_SIMM16] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* uimm3: 3 bit unsigned number */
   { "uimm3", M32R_OPERAND_UIMM3, HW_H_UINT, 5, 3,
-    { 0, { (const PTR) &m32r_cgen_ifld_table[M32R_F_UIMM3] } }, 
+    { 0, { (const PTR) &m32r_cgen_ifld_table[M32R_F_UIMM3] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* uimm4: 4 bit trap number */
   { "uimm4", M32R_OPERAND_UIMM4, HW_H_UINT, 12, 4,
-    { 0, { (const PTR) &m32r_cgen_ifld_table[M32R_F_UIMM4] } }, 
+    { 0, { (const PTR) &m32r_cgen_ifld_table[M32R_F_UIMM4] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* uimm5: 5 bit shift count */
   { "uimm5", M32R_OPERAND_UIMM5, HW_H_UINT, 11, 5,
-    { 0, { (const PTR) &m32r_cgen_ifld_table[M32R_F_UIMM5] } }, 
+    { 0, { (const PTR) &m32r_cgen_ifld_table[M32R_F_UIMM5] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* uimm8: 8 bit unsigned immediate */
   { "uimm8", M32R_OPERAND_UIMM8, HW_H_UINT, 8, 8,
-    { 0, { (const PTR) &m32r_cgen_ifld_table[M32R_F_UIMM8] } }, 
+    { 0, { (const PTR) &m32r_cgen_ifld_table[M32R_F_UIMM8] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* uimm16: 16 bit unsigned immediate */
   { "uimm16", M32R_OPERAND_UIMM16, HW_H_UINT, 16, 16,
-    { 0, { (const PTR) &m32r_cgen_ifld_table[M32R_F_UIMM16] } }, 
+    { 0, { (const PTR) &m32r_cgen_ifld_table[M32R_F_UIMM16] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* imm1: 1 bit immediate */
   { "imm1", M32R_OPERAND_IMM1, HW_H_UINT, 15, 1,
-    { 0, { (const PTR) &m32r_cgen_ifld_table[M32R_F_IMM1] } }, 
+    { 0, { (const PTR) &m32r_cgen_ifld_table[M32R_F_IMM1] } },
     { 0, { { { (1<<MACH_M32RX)|(1<<MACH_M32R2), 0 } } } }  },
 /* accd: accumulator destination register */
   { "accd", M32R_OPERAND_ACCD, HW_H_ACCUMS, 4, 2,
-    { 0, { (const PTR) &m32r_cgen_ifld_table[M32R_F_ACCD] } }, 
+    { 0, { (const PTR) &m32r_cgen_ifld_table[M32R_F_ACCD] } },
     { 0, { { { (1<<MACH_M32RX)|(1<<MACH_M32R2), 0 } } } }  },
 /* accs: accumulator source register */
   { "accs", M32R_OPERAND_ACCS, HW_H_ACCUMS, 12, 2,
-    { 0, { (const PTR) &m32r_cgen_ifld_table[M32R_F_ACCS] } }, 
+    { 0, { (const PTR) &m32r_cgen_ifld_table[M32R_F_ACCS] } },
     { 0, { { { (1<<MACH_M32RX)|(1<<MACH_M32R2), 0 } } } }  },
 /* acc: accumulator reg (d) */
   { "acc", M32R_OPERAND_ACC, HW_H_ACCUMS, 8, 1,
-    { 0, { (const PTR) &m32r_cgen_ifld_table[M32R_F_ACC] } }, 
+    { 0, { (const PTR) &m32r_cgen_ifld_table[M32R_F_ACC] } },
     { 0, { { { (1<<MACH_M32RX)|(1<<MACH_M32R2), 0 } } } }  },
 /* hash: # prefix */
   { "hash", M32R_OPERAND_HASH, HW_H_SINT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* hi16: high 16 bit immediate, sign optional */
   { "hi16", M32R_OPERAND_HI16, HW_H_HI16, 16, 16,
-    { 0, { (const PTR) &m32r_cgen_ifld_table[M32R_F_HI16] } }, 
+    { 0, { (const PTR) &m32r_cgen_ifld_table[M32R_F_HI16] } },
     { 0|A(SIGN_OPT), { { { (1<<MACH_BASE), 0 } } } }  },
 /* slo16: 16 bit signed immediate, for low() */
   { "slo16", M32R_OPERAND_SLO16, HW_H_SLO16, 16, 16,
-    { 0, { (const PTR) &m32r_cgen_ifld_table[M32R_F_SIMM16] } }, 
+    { 0, { (const PTR) &m32r_cgen_ifld_table[M32R_F_SIMM16] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* ulo16: 16 bit unsigned immediate, for low() */
   { "ulo16", M32R_OPERAND_ULO16, HW_H_ULO16, 16, 16,
-    { 0, { (const PTR) &m32r_cgen_ifld_table[M32R_F_UIMM16] } }, 
+    { 0, { (const PTR) &m32r_cgen_ifld_table[M32R_F_UIMM16] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* uimm24: 24 bit address */
   { "uimm24", M32R_OPERAND_UIMM24, HW_H_ADDR, 8, 24,
-    { 0, { (const PTR) &m32r_cgen_ifld_table[M32R_F_UIMM24] } }, 
+    { 0, { (const PTR) &m32r_cgen_ifld_table[M32R_F_UIMM24] } },
     { 0|A(RELOC)|A(ABS_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
 /* disp8: 8 bit displacement */
   { "disp8", M32R_OPERAND_DISP8, HW_H_IADDR, 8, 8,
-    { 0, { (const PTR) &m32r_cgen_ifld_table[M32R_F_DISP8] } }, 
+    { 0, { (const PTR) &m32r_cgen_ifld_table[M32R_F_DISP8] } },
     { 0|A(RELAX)|A(RELOC)|A(PCREL_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
 /* disp16: 16 bit displacement */
   { "disp16", M32R_OPERAND_DISP16, HW_H_IADDR, 16, 16,
-    { 0, { (const PTR) &m32r_cgen_ifld_table[M32R_F_DISP16] } }, 
+    { 0, { (const PTR) &m32r_cgen_ifld_table[M32R_F_DISP16] } },
     { 0|A(RELOC)|A(PCREL_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
 /* disp24: 24 bit displacement */
   { "disp24", M32R_OPERAND_DISP24, HW_H_IADDR, 8, 24,
-    { 0, { (const PTR) &m32r_cgen_ifld_table[M32R_F_DISP24] } }, 
+    { 0, { (const PTR) &m32r_cgen_ifld_table[M32R_F_DISP24] } },
     { 0|A(RELAX)|A(RELOC)|A(PCREL_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
 /* condbit: condition bit */
   { "condbit", M32R_OPERAND_CONDBIT, HW_H_COND, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* accum: accumulator */
   { "accum", M32R_OPERAND_ACCUM, HW_H_ACCUM, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* sentinel */
   { 0, 0, 0, 0, 0,
@@ -1468,7 +1468,7 @@ m32r_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)
 
   /* Default to not allowing signed overflow.  */
   cd->signed_overflow_ok_p = 0;
-  
+
   return (CGEN_CPU_DESC) cd;
 }
 
@@ -1508,7 +1508,7 @@ m32r_cgen_cpu_close (CGEN_CPU_DESC cd)
       for (i = 0; i < cd->insn_table.num_init_entries; ++i, ++insns)
 	if (CGEN_INSN_RX (insns))
 	  regfree (CGEN_INSN_RX (insns));
-    }  
+    }
 
   if (cd->macro_insn_table.init_entries)
     free ((CGEN_INSN *) cd->macro_insn_table.init_entries);
--- a/opcodes/m32r-dis.c
+++ b/opcodes/m32r-dis.c
@@ -281,7 +281,7 @@ m32r_cgen_print_operand (CGEN_CPU_DESC cd,
   }
 }
 
-cgen_print_fn * const m32r_cgen_print_handlers[] = 
+cgen_print_fn * const m32r_cgen_print_handlers[] =
 {
   print_insn_normal,
 };
@@ -471,7 +471,7 @@ print_insn (CGEN_CPU_DESC cd,
       int length;
       unsigned long insn_value_cropped;
 
-#ifdef CGEN_VALIDATE_INSN_SUPPORTED 
+#ifdef CGEN_VALIDATE_INSN_SUPPORTED
       /* Not needed as insn shouldn't be in hash lists if not supported.  */
       /* Supported by this cpu?  */
       if (! m32r_cgen_insn_supported (cd, insn))
@@ -489,7 +489,7 @@ print_insn (CGEN_CPU_DESC cd,
          relevant part from the buffer. */
       if ((unsigned) (CGEN_INSN_BITSIZE (insn) / 8) < buflen &&
 	  (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
-	insn_value_cropped = bfd_get_bits (buf, CGEN_INSN_BITSIZE (insn), 
+	insn_value_cropped = bfd_get_bits (buf, CGEN_INSN_BITSIZE (insn),
 					   info->endian == BFD_ENDIAN_BIG);
       else
 	insn_value_cropped = insn_value;
@@ -608,7 +608,7 @@ print_insn_m32r (bfd_vma pc, disassemble_info *info)
   arch = info->arch;
   if (arch == bfd_arch_unknown)
     arch = CGEN_BFD_ARCH;
-   
+
   /* There's no standard way to compute the machine or isa number
      so we leave it to the target.  */
 #ifdef CGEN_COMPUTE_MACH
@@ -649,7 +649,7 @@ print_insn_m32r (bfd_vma pc, disassemble_info *info)
 	      break;
 	    }
 	}
-    } 
+    }
 
   /* If we haven't initialized yet, initialize the opcode table.  */
   if (! cd)
--- a/opcodes/m32r-ibld.c
+++ b/opcodes/m32r-ibld.c
@@ -154,7 +154,7 @@ insert_normal (CGEN_CPU_DESC cd,
     {
       long minval = - (1L << (length - 1));
       unsigned long maxval = mask;
-      
+
       if ((value > 0 && (unsigned long) value > maxval)
 	  || value < minval)
 	{
@@ -192,7 +192,7 @@ insert_normal (CGEN_CPU_DESC cd,
 	{
 	  long minval = - (1L << (length - 1));
 	  long maxval =   (1L << (length - 1)) - 1;
-	  
+
 	  if (value < minval || value > maxval)
 	    {
 	      sprintf
@@ -803,12 +803,12 @@ m32r_cgen_extract_operand (CGEN_CPU_DESC cd,
   return length;
 }
 
-cgen_insert_fn * const m32r_cgen_insert_handlers[] = 
+cgen_insert_fn * const m32r_cgen_insert_handlers[] =
 {
   insert_insn_normal,
 };
 
-cgen_extract_fn * const m32r_cgen_extract_handlers[] = 
+cgen_extract_fn * const m32r_cgen_extract_handlers[] =
 {
   extract_insn_normal,
 };
--- a/opcodes/m68hc11-dis.c
+++ b/opcodes/m68hc11-dis.c
@@ -697,7 +697,7 @@ print_insn (bfd_vma memaddr, struct disassemble_info* info, int arch)
 	    {
 	      int cur_page;
 	      bfd_vma vaddr;
-                
+
 	      if (memaddr >= M68HC12_BANK_VIRT)
 		cur_page = ((memaddr - M68HC12_BANK_VIRT)
 			    >> M68HC12_BANK_SHIFT);
@@ -827,7 +827,7 @@ print_insn (bfd_vma memaddr, struct disassemble_info* info, int arch)
 	  val = buffer[0] & 0x0ff;
 	  (*info->fprintf_func) (info->stream, ", 0x%x", val);
 	}
-      
+
 #ifdef DEBUG
       /* Consistency check.  'format' must be 0, so that we have handled
 	 all formats; and the computed size of the insn must match the
--- a/opcodes/m68hc11-opc.c
+++ b/opcodes/m68hc11-opc.c
@@ -328,7 +328,7 @@ const struct m68hc11_opcode m68hc11_opcodes[] = {
   { "bgt", OP_JUMP_REL,        2, 0x2e,  1,  3, CHG_NONE, cpu6811 | cpu6812|cpu9s12x, 0 },
   { "bhi", OP_JUMP_REL,        2, 0x22,  1,  3, CHG_NONE, cpu6811 | cpu6812|cpu9s12x, 0 },
   { "bhs", OP_JUMP_REL,        2, 0x24,  1,  3, CHG_NONE, cpu6811 | cpu6812|cpu9s12x, 0 },
-  
+
   { "bita", OP_IMM8,          2, 0x85,  1,  1, CLR_V_CHG_NZ, cpu6811|cpu6812|cpu9s12x, 0 },
   { "bita", OP_DIRECT,        2, 0x95,  3,  3, CLR_V_CHG_NZ, cpu6811|cpu6812|cpu9s12x, 0 },
   { "bita", OP_IND16,         3, 0xb5,  3,  3, CLR_V_CHG_NZ, cpu6811|cpu6812|cpu9s12x, 0 },
--- a/opcodes/m68k-dis.c
+++ b/opcodes/m68k-dis.c
@@ -79,7 +79,7 @@ static char *const reg_half_names[] =
 	return ret_val;				\
       val = COERCE16 ((p[-2] << 8) + p[-1]);	\
     }						\
-  while (0)						
+  while (0)
 
 /* Get a 4 byte signed integer.  */
 #define COERCE32(x) ((bfd_signed_vma) ((x) ^ 0x80000000) - 0x80000000)
@@ -1336,7 +1336,7 @@ match_insn_m68k (bfd_vma memaddr,
 
   if (*args == '.')
     args++;
-  
+
   /* Point at first word of argument data,
      and at descriptor for first argument.  */
   p = buffer + 2;
@@ -1583,7 +1583,7 @@ m68k_scan_mask (bfd_vma memaddr, disassemble_info *info,
 	}
     }
   return 0;
-}		
+}
 
 /* Print the m68k instruction at address MEMADDR in debugged memory,
    on INFO->STREAM.  Returns length of the instruction, in bytes.  */
--- a/opcodes/m68k-opc.c
+++ b/opcodes/m68k-opc.c
@@ -292,7 +292,7 @@ const struct m68k_opcode m68k_opcodes[] =
 {"cmpl", 6,	one(0006200),	one(0177700), "#lDs", mcfisa_a },
 {"cmpl", 2,	one(0130610),	one(0170770), "+s+d", m68000up },
 {"cmpl", 2,	one(0130200),	one(0170700), "*lDd", m68000up | mcfisa_a },
-  
+
 {"cp0bcbusy",2, one (0176300), one (01777770), "BW", mcfisa_a},
 {"cp1bcbusy",2, one (0177300), one (01777770), "BW", mcfisa_a},
 {"cp0nop",   4, two (0176000,0), two (01777477,0170777), "jE", mcfisa_a},
@@ -316,7 +316,7 @@ const struct m68k_opcode m68k_opcodes[] =
 {"cp1stl",   6, one (0177600), one (01777700), ".R1pwjEK3", mcfisa_a},
 {"cp0st",    6, one (0176600), one (01777700), ".R1pwjEK3", mcfisa_a},
 {"cp1st",    6, one (0177600), one (01777700), ".R1pwjEK3", mcfisa_a},
-  
+
 {"dbcc", 2,	one(0052310),	one(0177770), "DsBw", m68000up },
 {"dbcs", 2,	one(0052710),	one(0177770), "DsBw", m68000up },
 {"dbeq", 2,	one(0053710),	one(0177770), "DsBw", m68000up },
@@ -376,7 +376,7 @@ const struct m68k_opcode m68k_opcodes[] =
 {"eor", 4,	one(0005174),	one(0177777), "#wSs", m68000up },
 {"eor", 4,	one(0005100),	one(0177700), "#w$s", m68000up },
 {"eor", 2,	one(0130500),	one(0170700), "Dd$s", m68000up },
-		
+
 {"exg", 2,	one(0140500),	one(0170770), "DdDs", m68000up },
 {"exg", 2,	one(0140510),	one(0170770), "AdAs", m68000up },
 {"exg", 2,	one(0140610),	one(0170770), "DdAs", m68000up },
@@ -2005,22 +2005,22 @@ const struct m68k_opcode m68k_opcodes[] =
 {"roxrl", 2,	one(0160260),		one(0170770), "DdDs", m68000up },
 
 {"rtd", 4,	one(0047164),		one(0177777), "#w", m68010up },
-		
+
 {"rte", 2,	one(0047163),		one(0177777), "",   m68000up | mcfisa_a },
-		
+
 {"rtm", 2,	one(0003300),		one(0177760), "Rs", m68020 },
-		
+
 {"rtr", 2,	one(0047167),		one(0177777), "",   m68000up },
-		
+
 {"rts", 2,	one(0047165),		one(0177777), "",   m68000up | mcfisa_a },
 
 {"satsl", 2,	one(0046200),		one(0177770), "Ds", mcfisa_b | mcfisa_c },
 
 {"sbcd", 2,	one(0100400),		one(0170770), "DsDd", m68000up },
 {"sbcd", 2,	one(0100410),		one(0170770), "-s-d", m68000up },
-  
+
 {"stldsr", 6,   two(0x40e7, 0x46fc),    two(0xffff, 0xffff), "#w", mcfisa_aa | mcfisa_c },
-  
+
   /* Traps have to come before conditional sets, as they have a more
      specific opcode.  */
 {"trapcc", 2,	one(0052374),	one(0177777), "", m68020up | cpu32 | fido_a },
--- a/opcodes/m88k-dis.c
+++ b/opcodes/m88k-dis.c
@@ -522,7 +522,7 @@ HASHTAB  *hashtable[HASHVAL] = {0};
 
 
 /* Initialize the disassembler instruction table.
-  
+
    Initialize the hash table and instruction table for the
    disassembler.  This should be called once before the first call to
    disasm().  */
@@ -549,14 +549,14 @@ init_disasm (void)
       hashtable[hashvalue] = &hashentries[i];
     }
 }
- 
+
 /* Decode an Operand of an instruction.
-  
+
    This function formats and writes an operand of an instruction to
    info based on the operand specification.  When the `first' flag is
    set this is the first operand of an instruction.  Undefined operand
    types cause a <dis error> message.
-  
+
    Parameters:
     disassemble_info	where the operand may be printed
     OPSPEC  *opptr      pointer to an operand specification
@@ -564,7 +564,7 @@ init_disasm (void)
     UINT    pc		pc of instruction; used for pc-relative disp.
     int     first       flag which if nonzero indicates the first
                         operand of an instruction
-  
+
    The operand specified is extracted from the instruction and is
    written to buf in the format specified. The operand is preceded by
    a comma if it is not the first operand of an instruction and it is
@@ -654,7 +654,7 @@ printop (struct disassemble_info *info,
       else
 	(*info->fprintf_func) (info->stream, "%x", extracted_field);
       break;
-                       
+
     case PCREL:
       (*info->print_address_func)
 	(pc + (4 * (SEXT (inst, opptr->offset, opptr->width))),
@@ -683,7 +683,7 @@ printop (struct disassemble_info *info,
    `pc' should be the address of this instruction, it will be used to
    print the target address if this is a relative jump or call the
    disassembled instruction is written to `info'.
-  
+
    The function returns the length of this instruction in bytes.  */
 
 static int
--- a/opcodes/makefile.vms
+++ b/opcodes/makefile.vms
@@ -11,12 +11,12 @@
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 3 of the License, or
 # (at your option) any later version.
-# 
+#
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
-# 
+#
 # You should have received a copy of the GNU General Public License
 # along with this program; see the file COPYING3.  If not see
 # <http://www.gnu.org/licenses/>.
--- a/opcodes/mcore-opc.h
+++ b/opcodes/mcore-opc.h
@@ -128,14 +128,14 @@ const mcore_opcode_info mcore_table[] =
   { "cmpnei",	OB,	0,	0x2A00 },
   { "bmaski",	OMa,	0,	0x2C00 },
   { "divu",	O1R1,	0,	0x2C10 },
-/* SPACE:                       0x2c20 - 0x2c7f */  
+/* SPACE:                       0x2c20 - 0x2c7f */
   { "bmaski",	OMb,	0,	0x2C80 },
   { "bmaski",	OMc,	0,	0x2D00 },
   { "andi",	OB,	0,	0x2E00 },
   { "bclri",	OB,	0,	0x3000 },
 /* SPACE:                       0x3200 - 0x320f */
   { "divs",	O1R1,	0,	0x3210 },
-/* SPACE:                       0x3220 - 0x326f */  
+/* SPACE:                       0x3220 - 0x326f */
   { "bgeni",	OBRa,	0,	0x3270 },
   { "bgeni",	OBRb,	0,	0x3280 },
   { "bgeni",	OBRc,	0,	0x3300 },
--- a/opcodes/mep-asm.c
+++ b/opcodes/mep-asm.c
@@ -488,7 +488,7 @@ parse_unsigned7 (CGEN_CPU_DESC cd, const char **strp,
 	  break;
 	default:
 	  /* Safe assumption?  */
-	  abort (); 
+	  abort ();
 	}
       errmsg = cgen_parse_address (cd, strp, opindex, reloc,
 				   NULL, &value);
@@ -534,7 +534,7 @@ parse_cdisp10 (CGEN_CPU_DESC cd,
   if ((MEP_CPU & EF_MEP_CPU_MASK) == EF_MEP_CPU_C5)
     wide = 1;
 
-  if (strncmp (*strp, "0x0", 3) == 0 
+  if (strncmp (*strp, "0x0", 3) == 0
       || (**strp == '0' && *(*strp + 1) != 'x'))
     have_zero = 1;
 
@@ -601,7 +601,7 @@ mep_cgen_expand_macros_and_parse_operand
 
 static char *
 str_append (char *dest, const char *input, int len)
-{  
+{
   char *new_dest;
   int oldlen;
 
@@ -637,8 +637,8 @@ expand_macro (arg *args, int narg, macro *mac)
   /*  printf("expanding macro %s with %d args\n", mac->name, narg + 1); */
   while (*e)
     {
-      if (*e == '`' && 
-	  (*e+1) && 
+      if (*e == '`' &&
+	  (*e+1) &&
 	  ((*(e + 1) - '1') <= MAXARGS) &&
 	  ((*(e + 1) - '1') <= narg))
 	{
@@ -661,7 +661,7 @@ expand_macro (arg *args, int narg, macro *mac)
       free (result);
       return rescanned_result;
     }
-  else 
+  else
     return result;
 }
 
@@ -686,8 +686,8 @@ expand_string (const char *in, int first_only)
       switch (state)
 	{
 	case IN_TEXT:
-	  if (*in == '%' && *(in + 1) && (!first_only || num_expansions == 0)) 
-	    {	      
+	  if (*in == '%' && *(in + 1) && (!first_only || num_expansions == 0))
+	    {
 	      pmacro = lookup_macro (in + 1);
 	      if (pmacro)
 		{
@@ -698,7 +698,7 @@ expand_string (const char *in, int first_only)
 		  while (*in == ' ') ++in;
 		  if (*in != '(')
 		    {
-		      state = IN_TEXT;		      
+		      state = IN_TEXT;
 		      pmacro = NULL;
 		    }
 		  else
@@ -707,7 +707,7 @@ expand_string (const char *in, int first_only)
 		      narg = 0;
 		      args[narg].start = in + 1;
 		      args[narg].len = 0;
-		      mark = in + 1;	      		      
+		      mark = in + 1;
 		    }
 		}
 	    }
@@ -747,9 +747,9 @@ expand_string (const char *in, int first_only)
 		  depth++;
 		default:
 		  args[narg].len++;
-		  break;		  
+		  break;
 		}
-	    } 
+	    }
 	  else
 	    {
 	      if (*in == ')')
@@ -757,14 +757,14 @@ expand_string (const char *in, int first_only)
 	      if (narg > -1)
 		args[narg].len++;
 	    }
-	  
+
 	}
       ++in;
     }
-  
+
   if (mark != in)
     result = str_append (result, mark, in - mark);
-  
+
   return result;
 }
 
@@ -803,10 +803,10 @@ mep_cgen_expand_macros_and_parse_operand (CGEN_CPU_DESC cd, int opindex,
     {
       if (strstr (*strp_in, str))
 	/* A macro-expansion was pulled off the front.  */
-	*strp_in = strstr (*strp_in, str);  
+	*strp_in = strstr (*strp_in, str);
       else
 	/* A non-macro-expansion was pulled off the front.  */
-	*strp_in += (str - hold); 
+	*strp_in += (str - hold);
     }
 
   if (hold)
@@ -815,7 +815,7 @@ mep_cgen_expand_macros_and_parse_operand (CGEN_CPU_DESC cd, int opindex,
   return errmsg;
 }
 
-#define CGEN_ASM_INIT_HOOK (cd->parse_operand = mep_cgen_expand_macros_and_parse_operand); 
+#define CGEN_ASM_INIT_HOOK (cd->parse_operand = mep_cgen_expand_macros_and_parse_operand);
 
 /* -- dis.c */
 
@@ -1289,7 +1289,7 @@ mep_cgen_parse_operand (CGEN_CPU_DESC cd,
   return errmsg;
 }
 
-cgen_parse_fn * const mep_cgen_parse_handlers[] = 
+cgen_parse_fn * const mep_cgen_parse_handlers[] =
 {
   parse_insn_normal,
 };
@@ -1319,9 +1319,9 @@ CGEN_ASM_INIT_HOOK
 
    Returns NULL for success, an error message for failure.  */
 
-char * 
+char *
 mep_cgen_build_insn_regex (CGEN_INSN *insn)
-{  
+{
   CGEN_OPCODE *opc = (CGEN_OPCODE *) CGEN_INSN_OPCODE (insn);
   const char *mnem = CGEN_INSN_MNEMONIC (insn);
   char rxbuf[CGEN_MAX_RX_ELEMENTS];
@@ -1360,18 +1360,18 @@ mep_cgen_build_insn_regex (CGEN_INSN *insn)
   /* Copy any remaining literals from the syntax string into the rx.  */
   for(; * syn != 0 && rx <= rxbuf + (CGEN_MAX_RX_ELEMENTS - 7 - 4); ++syn)
     {
-      if (CGEN_SYNTAX_CHAR_P (* syn)) 
+      if (CGEN_SYNTAX_CHAR_P (* syn))
 	{
 	  char c = CGEN_SYNTAX_CHAR (* syn);
 
-	  switch (c) 
+	  switch (c)
 	    {
 	      /* Escape any regex metacharacters in the syntax.  */
-	    case '.': case '[': case '\\': 
-	    case '*': case '^': case '$': 
+	    case '.': case '[': case '\\':
+	    case '*': case '^': case '$':
 
 #ifdef CGEN_ESCAPE_EXTENDED_REGEX
-	    case '?': case '{': case '}': 
+	    case '?': case '{': case '}':
 	    case '(': case ')': case '*':
 	    case '|': case '+': case ']':
 #endif
@@ -1401,20 +1401,20 @@ mep_cgen_build_insn_regex (CGEN_INSN *insn)
     }
 
   /* Trailing whitespace ok.  */
-  * rx++ = '['; 
-  * rx++ = ' '; 
-  * rx++ = '\t'; 
-  * rx++ = ']'; 
-  * rx++ = '*'; 
+  * rx++ = '[';
+  * rx++ = ' ';
+  * rx++ = '\t';
+  * rx++ = ']';
+  * rx++ = '*';
 
   /* But anchor it after that.  */
-  * rx++ = '$'; 
+  * rx++ = '$';
   * rx = '\0';
 
   CGEN_INSN_RX (insn) = xmalloc (sizeof (regex_t));
   reg_err = regcomp ((regex_t *) CGEN_INSN_RX (insn), rxbuf, REG_NOSUB);
 
-  if (reg_err == 0) 
+  if (reg_err == 0)
     return NULL;
   else
     {
@@ -1613,7 +1613,7 @@ mep_cgen_assemble_insn (CGEN_CPU_DESC cd,
       const CGEN_INSN *insn = ilist->insn;
       recognized_mnemonic = 1;
 
-#ifdef CGEN_VALIDATE_INSN_SUPPORTED 
+#ifdef CGEN_VALIDATE_INSN_SUPPORTED
       /* Not usually needed as unsupported opcodes
 	 shouldn't be in the hash lists.  */
       /* Is this insn supported by the selected cpu?  */
@@ -1673,7 +1673,7 @@ mep_cgen_assemble_insn (CGEN_CPU_DESC cd,
 	if (strlen (start) > 50)
 	  /* xgettext:c-format */
 	  sprintf (errbuf, "%s `%.50s...'", tmp_errmsg, start);
-	else 
+	else
 	  /* xgettext:c-format */
 	  sprintf (errbuf, "%s `%.50s'", tmp_errmsg, start);
       }
@@ -1682,11 +1682,11 @@ mep_cgen_assemble_insn (CGEN_CPU_DESC cd,
 	if (strlen (start) > 50)
 	  /* xgettext:c-format */
 	  sprintf (errbuf, _("bad instruction `%.50s...'"), start);
-	else 
+	else
 	  /* xgettext:c-format */
 	  sprintf (errbuf, _("bad instruction `%.50s'"), start);
       }
-      
+
     *errmsg = errbuf;
     return NULL;
   }
--- a/opcodes/mep-desc.c
+++ b/opcodes/mep-desc.c
@@ -103,13 +103,13 @@ static const CGEN_ATTR_ENTRY CRET_attr[] ATTRIBUTE_UNUSED =
   { 0, 0 }
 };
 
-static const CGEN_ATTR_ENTRY ALIGN_attr [] ATTRIBUTE_UNUSED = 
+static const CGEN_ATTR_ENTRY ALIGN_attr [] ATTRIBUTE_UNUSED =
 {
   {"integer", 1},
   { 0, 0 }
 };
 
-static const CGEN_ATTR_ENTRY LATENCY_attr [] ATTRIBUTE_UNUSED = 
+static const CGEN_ATTR_ENTRY LATENCY_attr [] ATTRIBUTE_UNUSED =
 {
   {"integer", 0},
   { 0, 0 }
@@ -880,583 +880,583 @@ const CGEN_OPERAND mep_cgen_operand_table[] =
 {
 /* pc: program counter */
   { "pc", MEP_OPERAND_PC, HW_H_PC, 0, 0,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_NIL] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_NIL] } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xfc" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* r0: register 0 */
   { "r0", MEP_OPERAND_R0, HW_H_GPR, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* rn: register Rn */
   { "rn", MEP_OPERAND_RN, HW_H_GPR, 4, 4,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_RN] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_RN] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* rm: register Rm */
   { "rm", MEP_OPERAND_RM, HW_H_GPR, 8, 4,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_RM] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_RM] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* rl: register Rl */
   { "rl", MEP_OPERAND_RL, HW_H_GPR, 12, 4,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_RL] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_RL] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* rn3: register 0-7 */
   { "rn3", MEP_OPERAND_RN3, HW_H_GPR, 5, 3,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_RN3] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_RN3] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* rma: register Rm holding pointer */
   { "rma", MEP_OPERAND_RMA, HW_H_GPR, 8, 4,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_RM] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_RM] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_POINTER, 0 } }, { { 1, 0 } } } }  },
 /* rnc: register Rn holding char */
   { "rnc", MEP_OPERAND_RNC, HW_H_GPR, 4, 4,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_RN] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_RN] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* rnuc: register Rn holding unsigned char */
   { "rnuc", MEP_OPERAND_RNUC, HW_H_GPR, 4, 4,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_RN] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_RN] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* rns: register Rn holding short */
   { "rns", MEP_OPERAND_RNS, HW_H_GPR, 4, 4,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_RN] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_RN] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* rnus: register Rn holding unsigned short */
   { "rnus", MEP_OPERAND_RNUS, HW_H_GPR, 4, 4,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_RN] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_RN] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* rnl: register Rn holding long */
   { "rnl", MEP_OPERAND_RNL, HW_H_GPR, 4, 4,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_RN] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_RN] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* rnul: register Rn holding unsigned  long */
   { "rnul", MEP_OPERAND_RNUL, HW_H_GPR, 4, 4,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_RN] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_RN] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_ULONG, 0 } }, { { 1, 0 } } } }  },
 /* rn3c: register 0-7 holding unsigned char */
   { "rn3c", MEP_OPERAND_RN3C, HW_H_GPR, 5, 3,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_RN3] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_RN3] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* rn3uc: register 0-7 holding byte */
   { "rn3uc", MEP_OPERAND_RN3UC, HW_H_GPR, 5, 3,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_RN3] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_RN3] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* rn3s: register 0-7 holding unsigned short */
   { "rn3s", MEP_OPERAND_RN3S, HW_H_GPR, 5, 3,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_RN3] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_RN3] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* rn3us: register 0-7 holding short */
   { "rn3us", MEP_OPERAND_RN3US, HW_H_GPR, 5, 3,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_RN3] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_RN3] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* rn3l: register 0-7 holding unsigned long */
   { "rn3l", MEP_OPERAND_RN3L, HW_H_GPR, 5, 3,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_RN3] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_RN3] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* rn3ul: register 0-7 holding long */
   { "rn3ul", MEP_OPERAND_RN3UL, HW_H_GPR, 5, 3,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_RN3] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_RN3] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_ULONG, 0 } }, { { 1, 0 } } } }  },
 /* lp: link pointer */
   { "lp", MEP_OPERAND_LP, HW_H_CSR, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* sar: shift amount register */
   { "sar", MEP_OPERAND_SAR, HW_H_CSR, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* hi: high result */
   { "hi", MEP_OPERAND_HI, HW_H_CSR, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* lo: low result */
   { "lo", MEP_OPERAND_LO, HW_H_CSR, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* mb0: modulo begin register 0 */
   { "mb0", MEP_OPERAND_MB0, HW_H_CSR, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* me0: modulo end register 0 */
   { "me0", MEP_OPERAND_ME0, HW_H_CSR, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* mb1: modulo begin register 1 */
   { "mb1", MEP_OPERAND_MB1, HW_H_CSR, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* me1: modulo end register 1 */
   { "me1", MEP_OPERAND_ME1, HW_H_CSR, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* psw: program status word */
   { "psw", MEP_OPERAND_PSW, HW_H_CSR, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* epc: exception prog counter */
   { "epc", MEP_OPERAND_EPC, HW_H_CSR, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* exc: exception cause */
   { "exc", MEP_OPERAND_EXC, HW_H_CSR, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* npc: nmi program counter */
   { "npc", MEP_OPERAND_NPC, HW_H_CSR, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* dbg: debug register */
   { "dbg", MEP_OPERAND_DBG, HW_H_CSR, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* depc: debug exception pc */
   { "depc", MEP_OPERAND_DEPC, HW_H_CSR, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* opt: option register */
   { "opt", MEP_OPERAND_OPT, HW_H_CSR, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* r1: register 1 */
   { "r1", MEP_OPERAND_R1, HW_H_GPR, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* tp: tiny data area pointer */
   { "tp", MEP_OPERAND_TP, HW_H_GPR, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* sp: stack pointer */
   { "sp", MEP_OPERAND_SP, HW_H_GPR, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* tpr: comment */
   { "tpr", MEP_OPERAND_TPR, HW_H_GPR, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* spr: comment */
   { "spr", MEP_OPERAND_SPR, HW_H_GPR, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* csrn: control/special register */
   { "csrn", MEP_OPERAND_CSRN, HW_H_CSR, 8, 5,
-    { 2, { (const PTR) &MEP_F_CSRN_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &MEP_F_CSRN_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_REGNUM, 0 } }, { { 1, 0 } } } }  },
 /* csrn-idx: control/special reg idx */
   { "csrn-idx", MEP_OPERAND_CSRN_IDX, HW_H_UINT, 8, 5,
-    { 2, { (const PTR) &MEP_F_CSRN_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &MEP_F_CSRN_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* crn64: copro Rn (64-bit) */
   { "crn64", MEP_OPERAND_CRN64, HW_H_CR64, 4, 4,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_CRN] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_CRN] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_CP_DATA_BUS_INT, 0 } }, { { 1, 0 } } } }  },
 /* crn: copro Rn (32-bit) */
   { "crn", MEP_OPERAND_CRN, HW_H_CR, 4, 4,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_CRN] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_CRN] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_CP_DATA_BUS_INT, 0 } }, { { 1, 0 } } } }  },
 /* crnx64: copro Rn (0-31, 64-bit) */
   { "crnx64", MEP_OPERAND_CRNX64, HW_H_CR64, 4, 5,
-    { 2, { (const PTR) &MEP_F_CRNX_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &MEP_F_CRNX_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_CP_DATA_BUS_INT, 0 } }, { { 1, 0 } } } }  },
 /* crnx: copro Rn (0-31, 32-bit) */
   { "crnx", MEP_OPERAND_CRNX, HW_H_CR, 4, 5,
-    { 2, { (const PTR) &MEP_F_CRNX_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &MEP_F_CRNX_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_CP_DATA_BUS_INT, 0 } }, { { 1, 0 } } } }  },
 /* ccrn: copro control reg CCRn */
   { "ccrn", MEP_OPERAND_CCRN, HW_H_CCR, 4, 6,
-    { 2, { (const PTR) &MEP_F_CCRN_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &MEP_F_CCRN_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_REGNUM, 0 } }, { { 1, 0 } } } }  },
 /* cccc: copro flags */
   { "cccc", MEP_OPERAND_CCCC, HW_H_UINT, 8, 4,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_RM] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_RM] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* pcrel8a2: comment */
   { "pcrel8a2", MEP_OPERAND_PCREL8A2, HW_H_SINT, 8, 7,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_8S8A2] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_8S8A2] } },
     { 0|A(RELAX)|A(PCREL_ADDR), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LABEL, 0 } }, { { 1, 0 } } } }  },
 /* pcrel12a2: comment */
   { "pcrel12a2", MEP_OPERAND_PCREL12A2, HW_H_SINT, 4, 11,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_12S4A2] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_12S4A2] } },
     { 0|A(RELAX)|A(PCREL_ADDR), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LABEL, 0 } }, { { 1, 0 } } } }  },
 /* pcrel17a2: comment */
   { "pcrel17a2", MEP_OPERAND_PCREL17A2, HW_H_SINT, 16, 16,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_17S16A2] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_17S16A2] } },
     { 0|A(RELAX)|A(PCREL_ADDR), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LABEL, 0 } }, { { 1, 0 } } } }  },
 /* pcrel24a2: comment */
   { "pcrel24a2", MEP_OPERAND_PCREL24A2, HW_H_SINT, 5, 23,
-    { 2, { (const PTR) &MEP_F_24S5A2N_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &MEP_F_24S5A2N_MULTI_IFIELD[0] } },
     { 0|A(PCREL_ADDR)|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LABEL, 0 } }, { { 1, 0 } } } }  },
 /* pcabs24a2: comment */
   { "pcabs24a2", MEP_OPERAND_PCABS24A2, HW_H_UINT, 5, 23,
-    { 2, { (const PTR) &MEP_F_24U5A2N_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &MEP_F_24U5A2N_MULTI_IFIELD[0] } },
     { 0|A(ABS_ADDR)|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LABEL, 0 } }, { { 1, 0 } } } }  },
 /* sdisp16: comment */
   { "sdisp16", MEP_OPERAND_SDISP16, HW_H_SINT, 16, 16,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_16S16] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_16S16] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* simm16: comment */
   { "simm16", MEP_OPERAND_SIMM16, HW_H_SINT, 16, 16,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_16S16] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_16S16] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* uimm16: comment */
   { "uimm16", MEP_OPERAND_UIMM16, HW_H_UINT, 16, 16,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_16U16] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_16U16] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* code16: uci/dsp code (16 bits) */
   { "code16", MEP_OPERAND_CODE16, HW_H_UINT, 16, 16,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_16U16] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_16U16] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* udisp2: SSARB addend (2 bits) */
   { "udisp2", MEP_OPERAND_UDISP2, HW_H_SINT, 6, 2,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_2U6] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_2U6] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* uimm2: interrupt (2 bits) */
   { "uimm2", MEP_OPERAND_UIMM2, HW_H_UINT, 10, 2,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_2U10] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_2U10] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* simm6: add const (6 bits) */
   { "simm6", MEP_OPERAND_SIMM6, HW_H_SINT, 8, 6,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_6S8] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_6S8] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* simm8: mov const (8 bits) */
   { "simm8", MEP_OPERAND_SIMM8, HW_H_SINT, 8, 8,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_8S8] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_8S8] } },
     { 0|A(RELOC_IMPLIES_OVERFLOW), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* addr24a4: comment */
   { "addr24a4", MEP_OPERAND_ADDR24A4, HW_H_UINT, 8, 22,
-    { 2, { (const PTR) &MEP_F_24U8A4N_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &MEP_F_24U8A4N_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 4, 0 } } } }  },
 /* code24: coprocessor code */
   { "code24", MEP_OPERAND_CODE24, HW_H_UINT, 4, 24,
-    { 2, { (const PTR) &MEP_F_24U4N_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &MEP_F_24U4N_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* callnum: system call number */
   { "callnum", MEP_OPERAND_CALLNUM, HW_H_UINT, 5, 4,
-    { 4, { (const PTR) &MEP_F_CALLNUM_MULTI_IFIELD[0] } }, 
+    { 4, { (const PTR) &MEP_F_CALLNUM_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* uimm3: bit immediate (3 bits) */
   { "uimm3", MEP_OPERAND_UIMM3, HW_H_UINT, 5, 3,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_3U5] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_3U5] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* uimm4: bCC const (4 bits) */
   { "uimm4", MEP_OPERAND_UIMM4, HW_H_UINT, 8, 4,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_4U8] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_4U8] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* uimm5: bit/shift val (5 bits) */
   { "uimm5", MEP_OPERAND_UIMM5, HW_H_UINT, 8, 5,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_5U8] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_5U8] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* udisp7: comment */
   { "udisp7", MEP_OPERAND_UDISP7, HW_H_UINT, 9, 7,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_7U9] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_7U9] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* udisp7a2: comment */
   { "udisp7a2", MEP_OPERAND_UDISP7A2, HW_H_UINT, 9, 6,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_7U9A2] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_7U9A2] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 2, 0 } } } }  },
 /* udisp7a4: comment */
   { "udisp7a4", MEP_OPERAND_UDISP7A4, HW_H_UINT, 9, 5,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_7U9A4] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_7U9A4] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 4, 0 } } } }  },
 /* uimm7a4: comment */
   { "uimm7a4", MEP_OPERAND_UIMM7A4, HW_H_UINT, 9, 5,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_7U9A4] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_7U9A4] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 4, 0 } } } }  },
 /* uimm24: immediate (24 bits) */
   { "uimm24", MEP_OPERAND_UIMM24, HW_H_UINT, 8, 24,
-    { 2, { (const PTR) &MEP_F_24U8N_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &MEP_F_24U8N_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* cimm4: cache immed'te (4 bits) */
   { "cimm4", MEP_OPERAND_CIMM4, HW_H_UINT, 4, 4,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_RN] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_RN] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* cimm5: clip immediate (5 bits) */
   { "cimm5", MEP_OPERAND_CIMM5, HW_H_UINT, 24, 5,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_5U24] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_5U24] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* cdisp10: comment */
   { "cdisp10", MEP_OPERAND_CDISP10, HW_H_SINT, 22, 10,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_CDISP10] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_CDISP10] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* cdisp10a2: comment */
   { "cdisp10a2", MEP_OPERAND_CDISP10A2, HW_H_SINT, 22, 10,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_CDISP10] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_CDISP10] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* cdisp10a4: comment */
   { "cdisp10a4", MEP_OPERAND_CDISP10A4, HW_H_SINT, 22, 10,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_CDISP10] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_CDISP10] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* cdisp10a8: comment */
   { "cdisp10a8", MEP_OPERAND_CDISP10A8, HW_H_SINT, 22, 10,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_CDISP10] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_CDISP10] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* zero: Zero operand */
   { "zero", MEP_OPERAND_ZERO, HW_H_SINT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* rl5: register Rl c5 */
   { "rl5", MEP_OPERAND_RL5, HW_H_GPR, 20, 4,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_RL5] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_RL5] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* cdisp12: copro addend (12 bits) */
   { "cdisp12", MEP_OPERAND_CDISP12, HW_H_SINT, 20, 12,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_12S20] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_12S20] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* c5rmuimm20: 20-bit immediate in rm and imm16 */
   { "c5rmuimm20", MEP_OPERAND_C5RMUIMM20, HW_H_UINT, 8, 20,
-    { 2, { (const PTR) &MEP_F_C5_RMUIMM20_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &MEP_F_C5_RMUIMM20_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* c5rnmuimm24: 24-bit immediate in rn, rm, and imm16 */
   { "c5rnmuimm24", MEP_OPERAND_C5RNMUIMM24, HW_H_UINT, 4, 24,
-    { 2, { (const PTR) &MEP_F_C5_RNMUIMM24_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &MEP_F_C5_RNMUIMM24_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xd0" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* cp_flag: branch condition register */
   { "cp_flag", MEP_OPERAND_CP_FLAG, HW_H_CCR, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xfc" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* ivc2_csar0: ivc2_csar0 */
   { "ivc2_csar0", MEP_OPERAND_IVC2_CSAR0, HW_H_CCR_IVC2, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\x7c" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* ivc2_cc: ivc2_cc */
   { "ivc2_cc", MEP_OPERAND_IVC2_CC, HW_H_CCR_IVC2, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\x7c" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* ivc2_cofr0: ivc2_cofr0 */
   { "ivc2_cofr0", MEP_OPERAND_IVC2_COFR0, HW_H_CCR_IVC2, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\x7c" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* ivc2_cofr1: ivc2_cofr1 */
   { "ivc2_cofr1", MEP_OPERAND_IVC2_COFR1, HW_H_CCR_IVC2, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\x7c" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* ivc2_cofa0: ivc2_cofa0 */
   { "ivc2_cofa0", MEP_OPERAND_IVC2_COFA0, HW_H_CCR_IVC2, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\x7c" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* ivc2_cofa1: ivc2_cofa1 */
   { "ivc2_cofa1", MEP_OPERAND_IVC2_COFA1, HW_H_CCR_IVC2, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\x7c" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* ivc2_csar1: ivc2_csar1 */
   { "ivc2_csar1", MEP_OPERAND_IVC2_CSAR1, HW_H_CCR_IVC2, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\x7c" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* ivc2_acc0_0: acc0_0 */
   { "ivc2_acc0_0", MEP_OPERAND_IVC2_ACC0_0, HW_H_CCR_IVC2, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\x7c" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* ivc2_acc0_1: acc0_1 */
   { "ivc2_acc0_1", MEP_OPERAND_IVC2_ACC0_1, HW_H_CCR_IVC2, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\x7c" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* ivc2_acc0_2: acc0_2 */
   { "ivc2_acc0_2", MEP_OPERAND_IVC2_ACC0_2, HW_H_CCR_IVC2, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\x7c" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* ivc2_acc0_3: acc0_3 */
   { "ivc2_acc0_3", MEP_OPERAND_IVC2_ACC0_3, HW_H_CCR_IVC2, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\x7c" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* ivc2_acc0_4: acc0_4 */
   { "ivc2_acc0_4", MEP_OPERAND_IVC2_ACC0_4, HW_H_CCR_IVC2, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\x7c" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* ivc2_acc0_5: acc0_5 */
   { "ivc2_acc0_5", MEP_OPERAND_IVC2_ACC0_5, HW_H_CCR_IVC2, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\x7c" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* ivc2_acc0_6: acc0_6 */
   { "ivc2_acc0_6", MEP_OPERAND_IVC2_ACC0_6, HW_H_CCR_IVC2, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\x7c" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* ivc2_acc0_7: acc0_7 */
   { "ivc2_acc0_7", MEP_OPERAND_IVC2_ACC0_7, HW_H_CCR_IVC2, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\x7c" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* ivc2_acc1_0: acc1_0 */
   { "ivc2_acc1_0", MEP_OPERAND_IVC2_ACC1_0, HW_H_CCR_IVC2, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\x7c" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* ivc2_acc1_1: acc1_1 */
   { "ivc2_acc1_1", MEP_OPERAND_IVC2_ACC1_1, HW_H_CCR_IVC2, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\x7c" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* ivc2_acc1_2: acc1_2 */
   { "ivc2_acc1_2", MEP_OPERAND_IVC2_ACC1_2, HW_H_CCR_IVC2, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\x7c" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* ivc2_acc1_3: acc1_3 */
   { "ivc2_acc1_3", MEP_OPERAND_IVC2_ACC1_3, HW_H_CCR_IVC2, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\x7c" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* ivc2_acc1_4: acc1_4 */
   { "ivc2_acc1_4", MEP_OPERAND_IVC2_ACC1_4, HW_H_CCR_IVC2, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\x7c" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* ivc2_acc1_5: acc1_5 */
   { "ivc2_acc1_5", MEP_OPERAND_IVC2_ACC1_5, HW_H_CCR_IVC2, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\x7c" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* ivc2_acc1_6: acc1_6 */
   { "ivc2_acc1_6", MEP_OPERAND_IVC2_ACC1_6, HW_H_CCR_IVC2, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\x7c" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* ivc2_acc1_7: acc1_7 */
   { "ivc2_acc1_7", MEP_OPERAND_IVC2_ACC1_7, HW_H_CCR_IVC2, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\x7c" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* croc: $CRo C3 */
   { "croc", MEP_OPERAND_CROC, HW_H_CR64, 7, 5,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_5U7] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_5U7] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xfc" } }, { { CDATA_CP_DATA_BUS_INT, 0 } }, { { 1, 0 } } } }  },
 /* crqc: $CRq C3 */
   { "crqc", MEP_OPERAND_CRQC, HW_H_CR64, 21, 5,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_5U21] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_5U21] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xfc" } }, { { CDATA_CP_DATA_BUS_INT, 0 } }, { { 1, 0 } } } }  },
 /* crpc: $CRp C3 */
   { "crpc", MEP_OPERAND_CRPC, HW_H_CR64, 26, 5,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_5U26] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_5U26] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xfc" } }, { { CDATA_CP_DATA_BUS_INT, 0 } }, { { 1, 0 } } } }  },
 /* ivc-x-6-1: filler */
   { "ivc-x-6-1", MEP_OPERAND_IVC_X_6_1, HW_H_UINT, 6, 1,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_1U6] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_1U6] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xfc" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* ivc-x-6-2: filler */
   { "ivc-x-6-2", MEP_OPERAND_IVC_X_6_2, HW_H_UINT, 6, 2,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_2U6] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_2U6] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xfc" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* ivc-x-6-3: filler */
   { "ivc-x-6-3", MEP_OPERAND_IVC_X_6_3, HW_H_UINT, 6, 3,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_3U6] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_3U6] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xfc" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* imm3p4: Imm3p4 */
   { "imm3p4", MEP_OPERAND_IMM3P4, HW_H_UINT, 4, 3,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_3U4] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_3U4] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xfc" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* imm3p9: Imm3p9 */
   { "imm3p9", MEP_OPERAND_IMM3P9, HW_H_UINT, 9, 3,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_3U9] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_3U9] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xfc" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* imm4p8: Imm4p8 */
   { "imm4p8", MEP_OPERAND_IMM4P8, HW_H_UINT, 8, 4,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_4U8] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_4U8] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xfc" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* imm5p7: Imm5p7 */
   { "imm5p7", MEP_OPERAND_IMM5P7, HW_H_UINT, 7, 5,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_5U7] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_5U7] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xfc" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* imm6p6: Imm6p6 */
   { "imm6p6", MEP_OPERAND_IMM6P6, HW_H_UINT, 6, 6,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_6U6] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_6U6] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xfc" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* imm8p4: Imm8p4 */
   { "imm8p4", MEP_OPERAND_IMM8P4, HW_H_UINT, 4, 8,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_8U4] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_8U4] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xfc" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* simm8p4: sImm8p4 */
   { "simm8p4", MEP_OPERAND_SIMM8P4, HW_H_SINT, 4, 8,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_8S4] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_8S4] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xfc" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* imm3p5: Imm3p5 */
   { "imm3p5", MEP_OPERAND_IMM3P5, HW_H_UINT, 5, 3,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_3U5] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_3U5] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xfc" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* imm3p12: Imm3p12 */
   { "imm3p12", MEP_OPERAND_IMM3P12, HW_H_UINT, 12, 3,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_3U12] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_3U12] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xfc" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* imm4p4: Imm4p4 */
   { "imm4p4", MEP_OPERAND_IMM4P4, HW_H_UINT, 4, 4,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_4U4] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_4U4] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xfc" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* imm4p10: Imm4p10 */
   { "imm4p10", MEP_OPERAND_IMM4P10, HW_H_UINT, 10, 4,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_4U10] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_4U10] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xfc" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* imm5p8: Imm5p8 */
   { "imm5p8", MEP_OPERAND_IMM5P8, HW_H_UINT, 8, 5,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_5U8] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_5U8] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xfc" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* imm5p3: Imm5p3 */
   { "imm5p3", MEP_OPERAND_IMM5P3, HW_H_UINT, 3, 5,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_5U3] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_5U3] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xfc" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* imm6p2: Imm6p2 */
   { "imm6p2", MEP_OPERAND_IMM6P2, HW_H_UINT, 2, 6,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_6U2] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_6U2] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xfc" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* imm5p23: Imm5p23 */
   { "imm5p23", MEP_OPERAND_IMM5P23, HW_H_UINT, 23, 5,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_5U23] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_5U23] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xfc" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* imm3p25: Imm3p25 */
   { "imm3p25", MEP_OPERAND_IMM3P25, HW_H_UINT, 25, 3,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_3U25] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_3U25] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xfc" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* imm8p0: Imm8p0 */
   { "imm8p0", MEP_OPERAND_IMM8P0, HW_H_UINT, 0, 8,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_8U0] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_8U0] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xfc" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* simm8p0: sImm8p0 */
   { "simm8p0", MEP_OPERAND_SIMM8P0, HW_H_SINT, 0, 8,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_8S0] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_8S0] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xfc" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* simm8p20: sImm8p20 */
   { "simm8p20", MEP_OPERAND_SIMM8P20, HW_H_SINT, 20, 8,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_8S20] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_8S20] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xfc" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* imm8p20: Imm8p20 */
   { "imm8p20", MEP_OPERAND_IMM8P20, HW_H_UINT, 20, 8,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_8U20] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_8U20] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xfc" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* crop: $CRo Pn */
   { "crop", MEP_OPERAND_CROP, HW_H_CR64, 23, 5,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_5U23] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_5U23] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xfc" } }, { { CDATA_CP_DATA_BUS_INT, 0 } }, { { 1, 0 } } } }  },
 /* crqp: $CRq Pn */
   { "crqp", MEP_OPERAND_CRQP, HW_H_CR64, 13, 5,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_5U13] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_5U13] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xfc" } }, { { CDATA_CP_DATA_BUS_INT, 0 } }, { { 1, 0 } } } }  },
 /* crpp: $CRp Pn */
   { "crpp", MEP_OPERAND_CRPP, HW_H_CR64, 18, 5,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_5U18] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_5U18] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xfc" } }, { { CDATA_CP_DATA_BUS_INT, 0 } }, { { 1, 0 } } } }  },
 /* ivc-x-0-2: filler */
   { "ivc-x-0-2", MEP_OPERAND_IVC_X_0_2, HW_H_UINT, 0, 2,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_2U0] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_2U0] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xfc" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* ivc-x-0-3: filler */
   { "ivc-x-0-3", MEP_OPERAND_IVC_X_0_3, HW_H_UINT, 0, 3,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_3U0] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_3U0] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xfc" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* ivc-x-0-4: filler */
   { "ivc-x-0-4", MEP_OPERAND_IVC_X_0_4, HW_H_UINT, 0, 4,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_4U0] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_4U0] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xfc" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* ivc-x-0-5: filler */
   { "ivc-x-0-5", MEP_OPERAND_IVC_X_0_5, HW_H_UINT, 0, 5,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_5U0] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_5U0] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xfc" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* imm16p0: comment */
   { "imm16p0", MEP_OPERAND_IMM16P0, HW_H_UINT, 0, 16,
-    { 2, { (const PTR) &MEP_F_IVC2_IMM16P0_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &MEP_F_IVC2_IMM16P0_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xfc" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* simm16p0: comment */
   { "simm16p0", MEP_OPERAND_SIMM16P0, HW_H_SINT, 0, 16,
-    { 2, { (const PTR) &MEP_F_IVC2_SIMM16P0_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &MEP_F_IVC2_SIMM16P0_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xfc" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* ivc2rm: reg Rm */
   { "ivc2rm", MEP_OPERAND_IVC2RM, HW_H_GPR, 4, 4,
-    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_CRM] } }, 
+    { 0, { (const PTR) &mep_cgen_ifld_table[MEP_F_IVC2_CRM] } },
     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, "\xfc" } }, { { CDATA_LONG, 0 } }, { { 1, 0 } } } }  },
 /* ivc2crn: copro Rn (0-31, 64-bit */
   { "ivc2crn", MEP_OPERAND_IVC2CRN, HW_H_CR64, 0, 5,
-    { 2, { (const PTR) &MEP_F_IVC2_CRNX_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &MEP_F_IVC2_CRNX_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xfc" } }, { { CDATA_CP_DATA_BUS_INT, 0 } }, { { 1, 0 } } } }  },
 /* ivc2ccrn: copro control reg CCRn */
   { "ivc2ccrn", MEP_OPERAND_IVC2CCRN, HW_H_CCR_IVC2, 0, 6,
-    { 2, { (const PTR) &MEP_F_IVC2_CCRN_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &MEP_F_IVC2_CCRN_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xfc" } }, { { CDATA_REGNUM, 0 } }, { { 1, 0 } } } }  },
 /* ivc2c3ccrn: copro control reg CCRn */
   { "ivc2c3ccrn", MEP_OPERAND_IVC2C3CCRN, HW_H_CCR_IVC2, 4, 6,
-    { 2, { (const PTR) &MEP_F_IVC2_CCRN_C3_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &MEP_F_IVC2_CCRN_C3_MULTI_IFIELD[0] } },
     { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, "\xfc" } }, { { CDATA_REGNUM, 0 } }, { { 1, 0 } } } }  },
 /* sentinel */
   { 0, 0, 0, 0, 0,
@@ -6329,7 +6329,7 @@ mep_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)
 
   /* Default to not allowing signed overflow.  */
   cd->signed_overflow_ok_p = 0;
-  
+
   return (CGEN_CPU_DESC) cd;
 }
 
@@ -6369,7 +6369,7 @@ mep_cgen_cpu_close (CGEN_CPU_DESC cd)
       for (i = 0; i < cd->insn_table.num_init_entries; ++i, ++insns)
 	if (CGEN_INSN_RX (insns))
 	  regfree (CGEN_INSN_RX (insns));
-    }  
+    }
 
   if (cd->macro_insn_table.init_entries)
     free ((CGEN_INSN *) cd->macro_insn_table.init_entries);
--- a/opcodes/mep-dis.c
+++ b/opcodes/mep-dis.c
@@ -78,7 +78,7 @@ print_tpreg (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED, PTR dis_info,
 }
 
 static void
-print_spreg (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED, PTR dis_info, 
+print_spreg (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED, PTR dis_info,
 	     CGEN_KEYWORD *table ATTRIBUTE_UNUSED, long val ATTRIBUTE_UNUSED,
 	     unsigned int flags ATTRIBUTE_UNUSED)
 {
@@ -143,11 +143,11 @@ mep_print_vliw_insns (CGEN_CPU_DESC cd, bfd_vma pc, disassemble_info *info,
   if (corelength > 0)
     {
       int my_status = 0;
-	 
+
       for (i = 0; i < corelength; i++ )
 	insnbuf[i] = buf[i];
       cd->isas = & MEP_CORE_ISA;
-	 
+
       my_status = print_insn (cd, pc, info, insnbuf, corelength);
       if (my_status != corelength)
 	{
@@ -159,7 +159,7 @@ mep_print_vliw_insns (CGEN_CPU_DESC cd, bfd_vma pc, disassemble_info *info,
       /* Print the + to indicate that the following copro insn is   */
       /* part of a vliw group.                                      */
       if (copro1length > 0)
-	(*info->fprintf_func) (info->stream, " + "); 
+	(*info->fprintf_func) (info->stream, " + ");
     }
 
   /* Now all that is left to be processed is the coprocessor insns
@@ -171,7 +171,7 @@ mep_print_vliw_insns (CGEN_CPU_DESC cd, bfd_vma pc, disassemble_info *info,
   if (copro1length > 0)
     {
       int my_status = 0;
-	 
+
       for (i = corelength; i < corelength + copro1length; i++ )
 	insnbuf[i - corelength] = buf[i];
 
@@ -190,7 +190,7 @@ mep_print_vliw_insns (CGEN_CPU_DESC cd, bfd_vma pc, disassemble_info *info,
 	  break;
 	case 8:
 	  cd->isas = & MEP_COP64_ISA;
-	  break; 
+	  break;
 	default:
 	  /* Shouldn't be anything but 16,32,48,64.  */
 	  break;
@@ -223,7 +223,7 @@ mep_print_vliw_insns (CGEN_CPU_DESC cd, bfd_vma pc, disassemble_info *info,
 
       for (i = corelength + copro1length; i < 64; i++)
 	insnbuf[i - (corelength + copro1length)] = buf[i];
-      
+
       switch (copro2length)
 	{
 	case 2:
@@ -236,7 +236,7 @@ mep_print_vliw_insns (CGEN_CPU_DESC cd, bfd_vma pc, disassemble_info *info,
 	  cd->isas = 1 << ISA_EXT_COP1_48;
 	  break;
 	case 8:
-	  cd->isas = 1 << ISA_EXT_COP1_64; 
+	  cd->isas = 1 << ISA_EXT_COP1_64;
 	  break;
 	default:
 	  /* Shouldn't be anything but 16,32,48,64.  */
@@ -264,29 +264,29 @@ mep_print_vliw_insns (CGEN_CPU_DESC cd, bfd_vma pc, disassemble_info *info,
     return status;
 }
 
-/* The two functions mep_examine_vliw[32,64]_insns are used find out 
-   which vliw combinaion (16 bit core with 48 bit copro, 32 bit core 
-   with 32 bit copro, etc.) is present.  Later on, when internally   
-   parallel coprocessors are handled, only these functions should    
-   need to be changed.                                               
+/* The two functions mep_examine_vliw[32,64]_insns are used find out
+   which vliw combinaion (16 bit core with 48 bit copro, 32 bit core
+   with 32 bit copro, etc.) is present.  Later on, when internally
+   parallel coprocessors are handled, only these functions should
+   need to be changed.
+
+   At this time only the following combinations are supported:
 
-   At this time only the following combinations are supported: 
-   
    VLIW32 Mode:
    16 bit core insn (core) and 16 bit coprocessor insn (cop1)
    32 bit core insn (core)
    32 bit coprocessor insn (cop1)
    Note: As of this time, I do not believe we have enough information
          to distinguish a 32 bit core insn from a 32 bit cop insn. Also,
-         no 16 bit coprocessor insns have been specified.  
+         no 16 bit coprocessor insns have been specified.
 
    VLIW64 Mode:
    16 bit core insn (core) and 48 bit coprocessor insn (cop1)
    32 bit core insn (core) and 32 bit coprocessor insn (cop1)
    64 bit coprocessor insn (cop1)
-  
+
    The framework for an internally parallel coprocessor is also
-   present (2nd coprocessor insn is cop2), but at this time it 
+   present (2nd coprocessor insn is cop2), but at this time it
    is not used.  This only appears to be valid in VLIW64 mode.  */
 
 static int
@@ -297,9 +297,9 @@ mep_examine_vliw32_insns (CGEN_CPU_DESC cd, bfd_vma pc, disassemble_info *info)
   int corebuflength;
   int cop1buflength;
   int cop2buflength;
-  bfd_byte buf[CGEN_MAX_INSN_SIZE];  
+  bfd_byte buf[CGEN_MAX_INSN_SIZE];
   char indicator16[1];
-  char indicatorcop32[2]; 
+  char indicatorcop32[2];
 
   /* At this time we're not supporting internally parallel coprocessors,
      so cop2buflength will always be 0.  */
@@ -1189,7 +1189,7 @@ mep_cgen_print_operand (CGEN_CPU_DESC cd,
   }
 }
 
-cgen_print_fn * const mep_cgen_print_handlers[] = 
+cgen_print_fn * const mep_cgen_print_handlers[] =
 {
   print_insn_normal,
 };
@@ -1379,7 +1379,7 @@ print_insn (CGEN_CPU_DESC cd,
       int length;
       unsigned long insn_value_cropped;
 
-#ifdef CGEN_VALIDATE_INSN_SUPPORTED 
+#ifdef CGEN_VALIDATE_INSN_SUPPORTED
       /* Not needed as insn shouldn't be in hash lists if not supported.  */
       /* Supported by this cpu?  */
       if (! mep_cgen_insn_supported (cd, insn))
@@ -1397,7 +1397,7 @@ print_insn (CGEN_CPU_DESC cd,
          relevant part from the buffer. */
       if ((unsigned) (CGEN_INSN_BITSIZE (insn) / 8) < buflen &&
 	  (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
-	insn_value_cropped = bfd_get_bits (buf, CGEN_INSN_BITSIZE (insn), 
+	insn_value_cropped = bfd_get_bits (buf, CGEN_INSN_BITSIZE (insn),
 					   info->endian == BFD_ENDIAN_BIG);
       else
 	insn_value_cropped = insn_value;
@@ -1516,7 +1516,7 @@ print_insn_mep (bfd_vma pc, disassemble_info *info)
   arch = info->arch;
   if (arch == bfd_arch_unknown)
     arch = CGEN_BFD_ARCH;
-   
+
   /* There's no standard way to compute the machine or isa number
      so we leave it to the target.  */
 #ifdef CGEN_COMPUTE_MACH
@@ -1557,7 +1557,7 @@ print_insn_mep (bfd_vma pc, disassemble_info *info)
 	      break;
 	    }
 	}
-    } 
+    }
 
   /* If we haven't initialized yet, initialize the opcode table.  */
   if (! cd)
--- a/opcodes/mep-ibld.c
+++ b/opcodes/mep-ibld.c
@@ -154,7 +154,7 @@ insert_normal (CGEN_CPU_DESC cd,
     {
       long minval = - (1L << (length - 1));
       unsigned long maxval = mask;
-      
+
       if ((value > 0 && (unsigned long) value > maxval)
 	  || value < minval)
 	{
@@ -192,7 +192,7 @@ insert_normal (CGEN_CPU_DESC cd,
 	{
 	  long minval = - (1L << (length - 1));
 	  long maxval =   (1L << (length - 1)) - 1;
-	  
+
 	  if (value < minval || value > maxval)
 	    {
 	      sprintf
@@ -1808,12 +1808,12 @@ mep_cgen_extract_operand (CGEN_CPU_DESC cd,
   return length;
 }
 
-cgen_insert_fn * const mep_cgen_insert_handlers[] = 
+cgen_insert_fn * const mep_cgen_insert_handlers[] =
 {
   insert_insn_normal,
 };
 
-cgen_extract_fn * const mep_cgen_extract_handlers[] = 
+cgen_extract_fn * const mep_cgen_extract_handlers[] =
 {
   extract_insn_normal,
 };
--- a/opcodes/mep-opc.h
+++ b/opcodes/mep-opc.h
@@ -87,7 +87,7 @@ extern CGEN_ATTR_VALUE_BITSET_TYPE mep_all_core_isas_mask;
 )
 
 /* A mask for all ISAs executed by a VLIW coprocessor.  */
-#define MEP_ALL_COP_ISAS_MASK mep_all_cop_isas_mask 
+#define MEP_ALL_COP_ISAS_MASK mep_all_cop_isas_mask
 extern CGEN_ATTR_VALUE_BITSET_TYPE mep_all_cop_isas_mask;
 
 #define MEP_INSN_COP_P(insn) ( \
#--- a/opcodes/microblaze-dis.h
#+++ b/opcodes/microblaze-dis.h
#@@ -26,12 +26,12 @@
# extern "C" {
# #endif
# 
#-extern enum microblaze_instr microblaze_decode_insn (long, int *, int *, 
#+extern enum microblaze_instr microblaze_decode_insn (long, int *, int *,
# 						     int *, int *);
# extern unsigned long microblaze_get_target_address (long, bfd_boolean, int,
# 			       long, long, long, bfd_boolean *, bfd_boolean *);
# 
#-extern enum microblaze_instr get_insn_microblaze (long, bfd_boolean *, 
#+extern enum microblaze_instr get_insn_microblaze (long, bfd_boolean *,
# 						  enum microblaze_instr_type *,
#   		     				  short *);
# 
#--- a/opcodes/microblaze-opc.h
#+++ b/opcodes/microblaze-opc.h
#@@ -1,5 +1,5 @@
# /* microblaze-opc.h -- MicroBlaze Opcodes
#- 
#+
#    Copyright (C) 2009-2015 Free Software Foundation, Inc.
# 
#    This file is part of the GNU opcodes library.
#@@ -63,12 +63,12 @@
# 
# 
# 
#-/* Instructions where the label address is resolved as a PC offset 
#+/* Instructions where the label address is resolved as a PC offset
#    (for branch label).  */
#-#define INST_PC_OFFSET 1 
#-/* Instructions where the label address is resolved as an absolute 
#+#define INST_PC_OFFSET 1
#+/* Instructions where the label address is resolved as an absolute
#    value (for data mem or abs address).  */
#-#define INST_NO_OFFSET 0 
#+#define INST_NO_OFFSET 0
# 
# #define IMMVAL_MASK_NON_SPECIAL 0x0000
# #define IMMVAL_MASK_MTS 0x4000
#@@ -81,14 +81,14 @@
# #define OPCODE_MASK_H4  0xFC0007FF  /* High 6 and low 11 bits.  */
# #define OPCODE_MASK_H13S 0xFFE0E7F0 /* High 11 16:18 21:27 bits, 19:20 bits
#                                        and last nibble of last byte for spr.  */
#-#define OPCODE_MASK_H23S 0xFC1FC000 /* High 6, 20-16 and 15:1 bits and last 
#+#define OPCODE_MASK_H23S 0xFC1FC000 /* High 6, 20-16 and 15:1 bits and last
# 				       nibble of last byte for spr.  */
# #define OPCODE_MASK_H34 0xFC00FFFF  /* High 6 and low 16 bits.  */
# #define OPCODE_MASK_H14 0xFFE007FF  /* High 11 and low 11 bits.  */
# #define OPCODE_MASK_H24 0xFC1F07FF  /* High 6, bits 20-16 and low 11 bits.  */
# #define OPCODE_MASK_H124  0xFFFF07FF /* High 16, and low 11 bits.  */
# #define OPCODE_MASK_H1234 0xFFFFFFFF /* All 32 bits.  */
#-#define OPCODE_MASK_H3  0xFC000600  /* High 6 bits and bits 21, 22.  */  
#+#define OPCODE_MASK_H3  0xFC000600  /* High 6 bits and bits 21, 22.  */
# #define OPCODE_MASK_H32 0xFC00FC00  /* High 6 bits and bit 16-21.  */
# #define OPCODE_MASK_H34B 0xFC0000FF /* High 6 bits and low 8 bits.  */
# #define OPCODE_MASK_H34C 0xFC0007E0 /* High 6 bits and bits 21-26.  */
#@@ -110,15 +110,15 @@ struct op_code_struct
#   short inst_offset_type;     /* Immediate vals offset from PC? (= 1 for branches).  */
#   short delay_slots;          /* Info about delay slots needed after this instr. */
#   short immval_mask;
#-  unsigned long bit_sequence; /* All the fixed bits for the op are set and 
#-				 all the variable bits (reg names, imm vals) 
#-				 are set to 0.  */ 
#+  unsigned long bit_sequence; /* All the fixed bits for the op are set and
#+				 all the variable bits (reg names, imm vals)
#+				 are set to 0.  */
#   unsigned long opcode_mask;  /* Which bits define the opcode.  */
#   enum microblaze_instr instr;
#   enum microblaze_instr_type instr_type;
#   /* More info about output format here.  */
#-} opcodes[MAX_OPCODES] = 
#-{ 
#+} opcodes[MAX_OPCODES] =
#+{
#   {"add",   INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x00000000, OPCODE_MASK_H4, add, arithmetic_inst },
#   {"rsub",  INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x04000000, OPCODE_MASK_H4, rsub, arithmetic_inst },
#   {"addc",  INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x08000000, OPCODE_MASK_H4, addc, arithmetic_inst },
#@@ -277,7 +277,7 @@ struct op_code_struct
#   {"tcput",  INST_TYPE_RFSL,    INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x6C00B000, OPCODE_MASK_H32, tcput,  anyware_inst },
#   {"tnput",  INST_TYPE_RFSL,    INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x6C00D000, OPCODE_MASK_H32, tnput,  anyware_inst },
#   {"tncput", INST_TYPE_RFSL,    INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x6C00F000, OPCODE_MASK_H32, tncput, anyware_inst },
#- 
#+
#   {"eget",   INST_TYPE_RD_RFSL,  INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x6C000400, OPCODE_MASK_H32, eget,   anyware_inst },
#   {"ecget",  INST_TYPE_RD_RFSL,  INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x6C002400, OPCODE_MASK_H32, ecget,  anyware_inst },
#   {"neget",  INST_TYPE_RD_RFSL,  INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x6C004400, OPCODE_MASK_H32, neget,  anyware_inst },
#@@ -286,7 +286,7 @@ struct op_code_struct
#   {"ecput",  INST_TYPE_R1_RFSL,  INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x6C00A400, OPCODE_MASK_H32, ecput,  anyware_inst },
#   {"neput",  INST_TYPE_R1_RFSL,  INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x6C00C400, OPCODE_MASK_H32, neput,  anyware_inst },
#   {"necput", INST_TYPE_R1_RFSL,  INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x6C00E400, OPCODE_MASK_H32, necput, anyware_inst },
#- 
#+
#   {"teget",   INST_TYPE_RD_RFSL, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x6C001400, OPCODE_MASK_H32, teget,   anyware_inst },
#   {"tecget",  INST_TYPE_RD_RFSL, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x6C003400, OPCODE_MASK_H32, tecget,  anyware_inst },
#   {"tneget",  INST_TYPE_RD_RFSL, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x6C005400, OPCODE_MASK_H32, tneget,  anyware_inst },
#@@ -295,7 +295,7 @@ struct op_code_struct
#   {"tecput",  INST_TYPE_RFSL,    INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x6C00B400, OPCODE_MASK_H32, tecput,  anyware_inst },
#   {"tneput",  INST_TYPE_RFSL,    INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x6C00D400, OPCODE_MASK_H32, tneput,  anyware_inst },
#   {"tnecput", INST_TYPE_RFSL,    INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x6C00F400, OPCODE_MASK_H32, tnecput, anyware_inst },
#- 
#+
#   {"aget",   INST_TYPE_RD_RFSL,  INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x6C000800, OPCODE_MASK_H32, aget,   anyware_inst },
#   {"caget",  INST_TYPE_RD_RFSL,  INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x6C002800, OPCODE_MASK_H32, caget,  anyware_inst },
#   {"naget",  INST_TYPE_RD_RFSL,  INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x6C004800, OPCODE_MASK_H32, naget,  anyware_inst },
#@@ -304,7 +304,7 @@ struct op_code_struct
#   {"caput",  INST_TYPE_R1_RFSL,  INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x6C00A800, OPCODE_MASK_H32, caput,  anyware_inst },
#   {"naput",  INST_TYPE_R1_RFSL,  INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x6C00C800, OPCODE_MASK_H32, naput,  anyware_inst },
#   {"ncaput", INST_TYPE_R1_RFSL,  INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x6C00E800, OPCODE_MASK_H32, ncaput, anyware_inst },
#- 
#+
#   {"taget",   INST_TYPE_RD_RFSL, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x6C001800, OPCODE_MASK_H32, taget,   anyware_inst },
#   {"tcaget",  INST_TYPE_RD_RFSL, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x6C003800, OPCODE_MASK_H32, tcaget,  anyware_inst },
#   {"tnaget",  INST_TYPE_RD_RFSL, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x6C005800, OPCODE_MASK_H32, tnaget,  anyware_inst },
#@@ -313,7 +313,7 @@ struct op_code_struct
#   {"tcaput",  INST_TYPE_RFSL,    INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x6C00B800, OPCODE_MASK_H32, tcaput,  anyware_inst },
#   {"tnaput",  INST_TYPE_RFSL,    INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x6C00D800, OPCODE_MASK_H32, tnaput,  anyware_inst },
#   {"tncaput", INST_TYPE_RFSL,    INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x6C00F800, OPCODE_MASK_H32, tncaput, anyware_inst },
#- 
#+
#   {"eaget",   INST_TYPE_RD_RFSL,  INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x6C000C00, OPCODE_MASK_H32, eget,   anyware_inst },
#   {"ecaget",  INST_TYPE_RD_RFSL,  INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x6C002C00, OPCODE_MASK_H32, ecget,  anyware_inst },
#   {"neaget",  INST_TYPE_RD_RFSL,  INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x6C004C00, OPCODE_MASK_H32, neget,  anyware_inst },
#@@ -322,7 +322,7 @@ struct op_code_struct
#   {"ecaput",  INST_TYPE_R1_RFSL,  INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x6C00AC00, OPCODE_MASK_H32, ecput,  anyware_inst },
#   {"neaput",  INST_TYPE_R1_RFSL,  INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x6C00CC00, OPCODE_MASK_H32, neput,  anyware_inst },
#   {"necaput", INST_TYPE_R1_RFSL,  INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x6C00EC00, OPCODE_MASK_H32, necput, anyware_inst },
#- 
#+
#   {"teaget",   INST_TYPE_RD_RFSL, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x6C001C00, OPCODE_MASK_H32, teaget,   anyware_inst },
#   {"tecaget",  INST_TYPE_RD_RFSL, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x6C003C00, OPCODE_MASK_H32, tecaget,  anyware_inst },
#   {"tneaget",  INST_TYPE_RD_RFSL, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x6C005C00, OPCODE_MASK_H32, tneaget,  anyware_inst },
#@@ -331,7 +331,7 @@ struct op_code_struct
#   {"tecaput",  INST_TYPE_RFSL,    INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x6C00BC00, OPCODE_MASK_H32, tecaput,  anyware_inst },
#   {"tneaput",  INST_TYPE_RFSL,    INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x6C00DC00, OPCODE_MASK_H32, tneaput,  anyware_inst },
#   {"tnecaput", INST_TYPE_RFSL,    INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x6C00FC00, OPCODE_MASK_H32, tnecaput, anyware_inst },
#- 
#+
#   {"getd",    INST_TYPE_RD_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x4C000000, OPCODE_MASK_H34C, getd,    anyware_inst },
#   {"tgetd",   INST_TYPE_RD_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x4C000080, OPCODE_MASK_H34C, tgetd,   anyware_inst },
#   {"cgetd",   INST_TYPE_RD_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x4C000100, OPCODE_MASK_H34C, cgetd,   anyware_inst },
#@@ -348,7 +348,7 @@ struct op_code_struct
#   {"tnputd",  INST_TYPE_R2,    INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x4C000680, OPCODE_MASK_H34C, tnputd,  anyware_inst },
#   {"ncputd",  INST_TYPE_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x4C000700, OPCODE_MASK_H34C, ncputd,  anyware_inst },
#   {"tncputd", INST_TYPE_R2,    INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x4C000780, OPCODE_MASK_H34C, tncputd, anyware_inst },
#- 
#+
#   {"egetd",    INST_TYPE_RD_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x4C000020, OPCODE_MASK_H34C, egetd,    anyware_inst },
#   {"tegetd",   INST_TYPE_RD_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x4C0000A0, OPCODE_MASK_H34C, tegetd,   anyware_inst },
#   {"ecgetd",   INST_TYPE_RD_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x4C000120, OPCODE_MASK_H34C, ecgetd,   anyware_inst },
#@@ -365,7 +365,7 @@ struct op_code_struct
#   {"tneputd",  INST_TYPE_R2,    INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x4C0006A0, OPCODE_MASK_H34C, tneputd,  anyware_inst },
#   {"necputd",  INST_TYPE_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x4C000720, OPCODE_MASK_H34C, necputd,  anyware_inst },
#   {"tnecputd", INST_TYPE_R2,    INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x4C0007A0, OPCODE_MASK_H34C, tnecputd, anyware_inst },
#- 
#+
#   {"agetd",    INST_TYPE_RD_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x4C000040, OPCODE_MASK_H34C, agetd,    anyware_inst },
#   {"tagetd",   INST_TYPE_RD_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x4C0000C0, OPCODE_MASK_H34C, tagetd,   anyware_inst },
#   {"cagetd",   INST_TYPE_RD_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x4C000140, OPCODE_MASK_H34C, cagetd,   anyware_inst },
#@@ -382,7 +382,7 @@ struct op_code_struct
#   {"tnaputd",  INST_TYPE_R2,    INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x4C0006C0, OPCODE_MASK_H34C, tnaputd,  anyware_inst },
#   {"ncaputd",  INST_TYPE_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x4C000740, OPCODE_MASK_H34C, ncaputd,  anyware_inst },
#   {"tncaputd", INST_TYPE_R2,    INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x4C0007C0, OPCODE_MASK_H34C, tncaputd, anyware_inst },
#- 
#+
#   {"eagetd",    INST_TYPE_RD_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x4C000060, OPCODE_MASK_H34C, eagetd,    anyware_inst },
#   {"teagetd",   INST_TYPE_RD_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x4C0000E0, OPCODE_MASK_H34C, teagetd,   anyware_inst },
#   {"ecagetd",   INST_TYPE_RD_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x4C000160, OPCODE_MASK_H34C, ecagetd,   anyware_inst },
#--- a/opcodes/microblaze-opcm.h
#+++ b/opcodes/microblaze-opcm.h
#@@ -18,7 +18,7 @@
#    along with this file; see the file COPYING.  If not, write to the
#    Free Software Foundation, 51 Franklin Street - Fifth Floor, Boston,
#    MA 02110-1301, USA.  */
#- 
#+
# 
# #ifndef MICROBLAZE_OPCM
# #define MICROBLAZE_OPCM
#@@ -26,23 +26,23 @@
# enum microblaze_instr
# {
#   add, rsub, addc, rsubc, addk, rsubk, addkc, rsubkc, clz, cmp, cmpu,
#-  addi, rsubi, addic, rsubic, addik, rsubik, addikc, rsubikc, mul, 
#+  addi, rsubi, addic, rsubic, addik, rsubik, addikc, rsubikc, mul,
#   mulh, mulhu, mulhsu,swapb,swaph,
#   idiv, idivu, bsll, bsra, bsrl, get, put, nget, nput, cget, cput,
#   ncget, ncput, muli, bslli, bsrai, bsrli, mului,
#   /* 'or/and/xor' are C++ keywords.  */
#   microblaze_or, microblaze_and, microblaze_xor,
#-  andn, pcmpbf, pcmpbc, pcmpeq, pcmpne, sra, src, srl, sext8, sext16, 
#+  andn, pcmpbf, pcmpbc, pcmpeq, pcmpne, sra, src, srl, sext8, sext16,
#   wic, wdc, wdcclear, wdcflush, mts, mfs, mbar, br, brd,
#   brld, bra, brad, brald, microblaze_brk, beq, beqd, bne, bned, blt,
#   bltd, ble, bled, bgt, bgtd, bge, bged, ori, andi, xori, andni,
#   imm, rtsd, rtid, rtbd, rted, bri, brid, brlid, brai, braid, bralid,
#   brki, beqi, beqid, bnei, bneid, blti, bltid, blei, bleid, bgti,
#-  bgtid, bgei, bgeid, lbu, lbur, lhu, lhur, lw, lwr, lwx, sb, sbr, sh, 
#+  bgtid, bgei, bgeid, lbu, lbur, lhu, lhur, lw, lwr, lwx, sb, sbr, sh,
#   shr, sw, swr, swx, lbui, lhui, lwi,
#-  sbi, shi, swi, msrset, msrclr, tuqula, fadd, frsub, fmul, fdiv, 
#-  fcmp_lt, fcmp_eq, fcmp_le, fcmp_gt, fcmp_ne, fcmp_ge, fcmp_un, flt, 
#-  fint, fsqrt, 
#+  sbi, shi, swi, msrset, msrclr, tuqula, fadd, frsub, fmul, fdiv,
#+  fcmp_lt, fcmp_eq, fcmp_le, fcmp_gt, fcmp_ne, fcmp_ge, fcmp_un, flt,
#+  fint, fsqrt,
#   tget, tcget, tnget, tncget, tput, tcput, tnput, tncput,
#   eget, ecget, neget, necget, eput, ecput, neput, necput,
#   teget, tecget, tneget, tnecget, teput, tecput, tneput, tnecput,
#@@ -123,7 +123,7 @@ enum microblaze_instr_type
# /* Assembler Register - Used in Delay Slot Optimization.  */
# #define REG_AS    18
# #define REG_ZERO  0
#- 
#+
# #define RD_LOW  21 /* Low bit for RD.  */
# #define RA_LOW  16 /* Low bit for RA.  */
# #define RB_LOW  11 /* Low bit for RB.  */
#--- a/opcodes/mips-dis.c
#+++ b/opcodes/mips-dis.c
#@@ -875,8 +875,8 @@ parse_mips_dis_option (const char *option, unsigned int len)
#       mips_ase |= ASE_XPA;
#       return;
#     }
#-  
#-  
#+
#+
#   /* Look for the = that delimits the end of the option name.  */
#   for (i = 0; i < len; i++)
#     if (option[i] == '=')
#@@ -1709,7 +1709,7 @@ print_insn_mips (bfd_vma memaddr,
#     {
#       for (; op < &mips_opcodes[NUMOPCODES]; op++)
# 	{
#-	  if (op->pinfo != INSN_MACRO 
#+	  if (op->pinfo != INSN_MACRO
# 	      && !(no_aliases && (op->pinfo2 & INSN2_ALIAS))
# 	      && (word & op->mask) == op->match)
# 	    {
#--- a/opcodes/mips-opc.c
#+++ b/opcodes/mips-opc.c
#@@ -404,7 +404,7 @@ decode_mips_operand (const char *p)
# 
#    Because of the lookup algorithm used, entries with the same opcode
#    name must be contiguous.
#- 
#+
#    Many instructions are short hand for other instructions (i.e., The
#    jal <register> instruction is short for jalr <register>).  */
# 
#@@ -2062,8 +2062,8 @@ const struct mips_opcode mips_builtin_opcodes[] =
# {"zcb",			"(b)",		0x7000071f, 0xfc1fffff, RD_1|SM,		0,		IOCT2,		0,	0 },
# {"zcbt",		"(b)",		0x7000075f, 0xfc1fffff, RD_1|SM,		0,		IOCT2,		0,	0 },
# 
#-/* Coprocessor 0 move instructions cfc0 and ctc0 conflict with the 
#-   mfhc0 and mthc0 XPA instructions, so they have been placed here 
#+/* Coprocessor 0 move instructions cfc0 and ctc0 conflict with the
#+   mfhc0 and mthc0 XPA instructions, so they have been placed here
#    to allow the XPA instructions to take precedence.  */
# {"ctc0",		"t,G",		0x40c00000, 0xffe007ff,	RD_1|WR_CC|CM,		0,		I1,		0,	IOCT|IOCTP|IOCT2 },
# {"cfc0",		"t,G",		0x40400000, 0xffe007ff,	WR_1|RD_C0|LC,		0,		I1,		0,	IOCT|IOCTP|IOCT2 },
#@@ -2110,7 +2110,7 @@ const struct mips_opcode mips_builtin_opcodes[] =
# {"qmtc2",		"t,+6",		0x48a00000, 0xffe007ff,	RD_1|WR_C2,		0,		EE,		0,	0 },
# {"qmtc2.i",		"t,+6",		0x48a00001, 0xffe007ff,	RD_1|WR_C2,		0,		EE,		0,	0 },
# {"qmtc2.ni",		"t,+6",		0x48a00000, 0xffe007ff,	RD_1|WR_C2,		0,		EE,		0,	0 },
#-/* Coprocessor 3 move/branch operations overlap with MIPS IV COP1X 
#+/* Coprocessor 3 move/branch operations overlap with MIPS IV COP1X
#    instructions, so they are here for the latters to take precedence.  */
# {"bc3f",		"p",		0x4d000000, 0xffff0000,	RD_CC|CBD,		0,		I1,		0,	IOCT|IOCTP|IOCT2|EE|I37 },
# {"bc3fl",		"p",		0x4d020000, 0xffff0000,	RD_CC|CBL,		0,		I2|T3,		0,	IOCT|IOCTP|IOCT2|EE|I37 },
--- a/opcodes/moxie-dis.c
+++ b/opcodes/moxie-dis.c
@@ -210,7 +210,7 @@ print_insn_moxie (bfd_vma addr, struct disassemble_info * info)
 	{
 	case MOXIE_F3_PCREL:
 	  fpr (stream, "%s\t", opcode->name);
-	  info->print_address_func ((bfd_vma) (addr + INST2OFFSET(iword) + 2), 
+	  info->print_address_func ((bfd_vma) (addr + INST2OFFSET(iword) + 2),
 				    info);
 	  break;
         case MOXIE_BAD:
#--- a/opcodes/msp430-decode.c
#+++ b/opcodes/msp430-decode.c
#@@ -375,7 +375,7 @@ msp430_decode_opcode (unsigned long pc,
#                 ID (MSO_mov); SM (srcr, 0); DR (dstr);
#                 msp430->size = 20;
#                 msp430->ofs_430x = 1;
#-              
#+
#               }
#             break;
#           case 0x10:
#@@ -399,7 +399,7 @@ msp430_decode_opcode (unsigned long pc,
#                 ID (MSO_mov); SI (srcr); DR (dstr);
#                 msp430->size = 20;
#                 msp430->ofs_430x = 1;
#-              
#+
#               }
#             break;
#           case 0x20:
#@@ -423,7 +423,7 @@ msp430_decode_opcode (unsigned long pc,
#                 ID (MSO_mov); SA ((srcr << 16) + IMMU(2)); DR (dstr);
#                 msp430->size = 20;
#                 msp430->ofs_430x = 1;
#-              
#+
#               }
#             break;
#           case 0x30:
#@@ -447,7 +447,7 @@ msp430_decode_opcode (unsigned long pc,
#                 ID (MSO_mov); SM (srcr, IMMS(2)); DR (dstr);
#                 msp430->size = 20;
#                 msp430->ofs_430x = 1;
#-              
#+
#               }
#             break;
#           case 0x40:
#@@ -477,7 +477,7 @@ msp430_decode_opcode (unsigned long pc,
#                 msp430->size = w ? 16 : 20;
#                 msp430->ofs_430x = 1;
#                 F_0NZC;
#-              
#+
#               }
#             break;
#           case 0x60:
#@@ -501,7 +501,7 @@ msp430_decode_opcode (unsigned long pc,
#                 ID (MSO_mov); SR (srcr); DA ((dstr << 16) + IMMU(2));
#                 msp430->size = 20;
#                 msp430->ofs_430x = 1;
#-              
#+
#               }
#             break;
#           case 0x70:
#@@ -525,7 +525,7 @@ msp430_decode_opcode (unsigned long pc,
#                 ID (MSO_mov); SR (srcr); DM (dstr, IMMS(2));
#                 msp430->size = 20;
#                 msp430->ofs_430x = 1;
#-              
#+
#               }
#             break;
#           case 0x80:
#@@ -549,7 +549,7 @@ msp430_decode_opcode (unsigned long pc,
#                 ID (MSO_mov); SC ((srcr << 16) + IMMU(2)); DR (dstr);
#                 msp430->size = 20;
#                 msp430->ofs_430x = 1;
#-              
#+
#               }
#             break;
#           case 0x90:
#@@ -574,7 +574,7 @@ msp430_decode_opcode (unsigned long pc,
#                 msp430->size = 20;
#                 msp430->ofs_430x = 1;
#                 F_VNZC;
#-              
#+
#               }
#             break;
#           case 0xa0:
#@@ -599,7 +599,7 @@ msp430_decode_opcode (unsigned long pc,
#                 msp430->size = 20;
#                 msp430->ofs_430x = 1;
#                 F_VNZC;
#-              
#+
#               }
#             break;
#           case 0xb0:
#@@ -624,7 +624,7 @@ msp430_decode_opcode (unsigned long pc,
#                 msp430->size = 20;
#                 msp430->ofs_430x = 1;
#                 F_VNZC;
#-              
#+
#               }
#             break;
#           case 0xc0:
#@@ -648,7 +648,7 @@ msp430_decode_opcode (unsigned long pc,
#                 ID (MSO_mov); SR (srcr); DR (dstr);
#                 msp430->size = 20;
#                 msp430->ofs_430x = 1;
#-              
#+
#               }
#             break;
#           case 0xd0:
#@@ -673,7 +673,7 @@ msp430_decode_opcode (unsigned long pc,
#                 msp430->size = 20;
#                 msp430->ofs_430x = 1;
#                 F_VNZC;
#-              
#+
#               }
#             break;
#           case 0xe0:
#@@ -698,7 +698,7 @@ msp430_decode_opcode (unsigned long pc,
#                 msp430->size = 20;
#                 msp430->ofs_430x = 1;
#                 F_VNZC;
#-              
#+
#               }
#             break;
#           case 0xf0:
#@@ -723,7 +723,7 @@ msp430_decode_opcode (unsigned long pc,
#                 msp430->size = 20;
#                 msp430->ofs_430x = 1;
#                 F_VNZC;
#-              
#+
#               }
#             break;
#         }
#@@ -771,7 +771,7 @@ msp430_decode_opcode (unsigned long pc,
#                 msp430->size = w ? 16 : 20;
#                 msp430->ofs_430x = 1;
#                 F_0NZC;
#-              
#+
#               }
#             break;
#           case 0x60:
#@@ -849,7 +849,7 @@ msp430_decode_opcode (unsigned long pc,
#                 msp430->size = w ? 16 : 20;
#                 msp430->ofs_430x = 1;
#                 F_0NZC;
#-              
#+
#               }
#             break;
#           case 0x60:
#@@ -927,7 +927,7 @@ msp430_decode_opcode (unsigned long pc,
#                 msp430->size = w ? 16 : 20;
#                 msp430->ofs_430x = 1;
#                 F_0NZC;
#-              
#+
#               }
#             break;
#           case 0x60:
#@@ -1617,20 +1617,20 @@ msp430_decode_opcode (unsigned long pc,
#                   }
#                 SYNTAX("%S%b	%1");
# #line 394 "msp430-decode.opc"
#-              
#+
#                 ID (sopc_to_id (so,c)); ASX (dreg, ad, srxt_bits); ABW (al_bit, b);
#-              
#+
#                 if (ad == 0)
#                   REPZC (srxt_bits, dsxt_bits);
#-              
#+
#                 /* The helper functions encode for source, but it's
#                    both source and dest, with a few documented exceptions.  */
#                 msp430->op[0] = msp430->op[1];
#-              
#+
#                 /* RETI ignores the operand.  */
#                 if (msp430->id == MSO_reti)
#                   msp430->syntax = "%S";
#-              
#+
#                 switch (msp430->id)
#                   {
#                   case MSO_rrc:	F_VNZC; break;
#@@ -1642,7 +1642,7 @@ msp430_decode_opcode (unsigned long pc,
#                   case MSO_reti:	F_VNZC; break;
#                   default: break;
#                   }
#-              
#+
#                 /* 20xx 0010 0000 ---- ----
#                    3cxx 0011 1100 ---- ----
#                         001j mp-- ---- ----.  */
#@@ -1686,7 +1686,7 @@ msp430_decode_opcode (unsigned long pc,
#                 ID (MSO_reti);
#                 msp430->size = 20;
#                 msp430->ofs_430x = 1;
#-              
#+
#               }
#             break;
#           case 0x01:
#@@ -1917,7 +1917,7 @@ msp430_decode_opcode (unsigned long pc,
#                 ID (MSO_call); AS (dstr, as);
#                 msp430->size = 20;
#                 msp430->ofs_430x = 1;
#-              
#+
#               }
#             break;
#           case 0x80:
#@@ -1952,7 +1952,7 @@ msp430_decode_opcode (unsigned long pc,
#                 ID (MSO_call); SA (IMMU(2) | (extb << 16));
#                 msp430->size = 20;
#                 msp430->ofs_430x = 1;
#-              
#+
#               }
#             break;
#           case 0x90:
#@@ -1990,7 +1990,7 @@ msp430_decode_opcode (unsigned long pc,
#                 ID (MSO_call); SA (pc + raddr + msp430->n_bytes);
#                 msp430->size = 20;
#                 msp430->ofs_430x = 1;
#-              
#+
#               }
#             break;
#           case 0xb0:
#@@ -2025,7 +2025,7 @@ msp430_decode_opcode (unsigned long pc,
#                 ID (MSO_call); SC (IMMU(2) | (extb << 16));
#                 msp430->size = 20;
#                 msp430->ofs_430x = 1;
#-              
#+
#               }
#             break;
#         }
#@@ -2059,7 +2059,7 @@ msp430_decode_opcode (unsigned long pc,
#                 msp430->size = w ? 16 : 20;
#                 msp430->repeats = bits;
#                 msp430->ofs_430x = 1;
#-              
#+
#               }
#             break;
#         }
#@@ -2102,7 +2102,7 @@ msp430_decode_opcode (unsigned long pc,
#                 msp430->size = w ? 16 : 20;
#                 msp430->repeats = bits;
#                 msp430->ofs_430x = 1;
#-              
#+
#               }
#             break;
#         }
#@@ -2144,25 +2144,25 @@ msp430_decode_opcode (unsigned long pc,
#                   }
#                 SYNTAX("430x");
# #line 350 "msp430-decode.opc"
#-              
#+
#                 al_bit = l;
#                 srxt_bits = srx * 2 + t;
#                 dsxt_bits = dsxt;
#                 op = op_buf + lds.op_ptr;
#                 msp430->ofs_430x = 1;
#                 goto post_extension_word;
#-              
#+
#               /* double-op insns:
#                  opcode:4 sreg:4 Ad:1 BW:1 As:2 Dreg:4
#-              
#+
#                  single-op insn:
#                  opcode:9 BW:1 Ad:2 DSreg:4
#-              
#+
#                  jumps:
#                  opcode:3 Cond:3  pcrel:10. */
#-              
#+
#               /* Double-Operand "opcode" fields.  */
#-              
#+
#               }
#             break;
#           default: UNSUPPORTED(); break;
#@@ -2263,7 +2263,7 @@ msp430_decode_opcode (unsigned long pc,
#                   }
#                 SYNTAX("%J	%1");
# #line 424 "msp430-decode.opc"
#-              
#+
#                 raddr = (aa << 9) | (addrlsbs << 1);
#                 if (raddr & 0x400)
#                   raddr = raddr - 0x800;
#@@ -2273,9 +2273,9 @@ msp430_decode_opcode (unsigned long pc,
#                    data at that address.  */
#                 ID (MSO_jmp); SC (pc + raddr + msp430->n_bytes);
#                 msp430->cond = jmp;
#-              
#+
#                 /* Extended instructions.  */
#-              
#+
#               }
#             break;
#         }
#@@ -2593,11 +2593,11 @@ msp430_decode_opcode (unsigned long pc,
#                   }
#                 SYNTAX("%D%b	%1,%0");
# #line 371 "msp430-decode.opc"
#-              
#+
#                 ID (dopc_to_id (dopc)); ASX (sreg, as, srxt_bits); ADX (dreg, a, dsxt_bits); ABW (al_bit, b);
#                 if (a == 0 && as == 0)
#                   REPZC (srxt_bits, dsxt_bits);
#-              
#+
#                 switch (msp430->id)
#                   {
#                   case MSO_mov:	F_____; break;
#@@ -2614,7 +2614,7 @@ msp430_decode_opcode (unsigned long pc,
#                   case MSO_and:	F_0NZC; break;
#                   default: break;
#                   }
#-              
#+
#               }
#             break;
#         }
#--- a/opcodes/msp430-dis.c
#+++ b/opcodes/msp430-dis.c
#@@ -2,7 +2,7 @@
#    Copyright (C) 2002-2015 Free Software Foundation, Inc.
# 
#    Contributed by Dmitry Diky <diwil@mail.ru>
#-        
#+
#    This file is part of the GNU opcodes library.
# 
#    This library is free software; you can redistribute it and/or modify
#@@ -397,7 +397,7 @@ msp430_doubleoperand (disassemble_info *info,
# 	 Rm       	Register,
#          x(Rm)     	Indexed,
#          0xXXXX    	Relative,
#-         &0xXXXX    	Absolute 
#+         &0xXXXX    	Absolute
#          emulated_ins   dst
#          basic_ins      dst, dst.  */
# 
#@@ -936,7 +936,7 @@ print_insn_msp430 (bfd_vma addr, disassemble_info *info)
# 		  sprintf (comm1, "20-bit words");
# 		  bc =".a";
# 		}
#-	      
#+
# 	      cycles = 2; /*FIXME*/
# 	      cmd_len = 2;
# 	      break;
#@@ -984,7 +984,7 @@ print_insn_msp430 (bfd_vma addr, disassemble_info *info)
# 		  if (strcmp (opcode->name, "bra") != 0)
# 		    sprintf (op2, "r%d", reg);
# 		  break;
#-		  
#+
# 		case 1: /* MOVA @Rsrc+, Rdst */
# 		  cmd_len = 2;
# 		  if (strcmp (opcode->name, "reta") != 0)
#@@ -994,7 +994,7 @@ print_insn_msp430 (bfd_vma addr, disassemble_info *info)
# 			sprintf (op2, "r%d", reg);
# 		    }
# 		  break;
#-		  
#+
# 		case 2: /* MOVA &abs20, Rdst */
# 		  cmd_len = 4;
# 		  n <<= 16;
#@@ -1005,7 +1005,7 @@ print_insn_msp430 (bfd_vma addr, disassemble_info *info)
# 		  if (strcmp (opcode->name, "bra") != 0)
# 		    sprintf (op2, "r%d", reg);
# 		  break;
#-		  
#+
# 		case 3: /* MOVA x(Rsrc), Rdst */
# 		  cmd_len = 4;
# 		  if (strcmp (opcode->name, "bra") != 0)
#@@ -1051,7 +1051,7 @@ print_insn_msp430 (bfd_vma addr, disassemble_info *info)
# 			sprintf (comm2, "0x%05x", n);
# 		    }
# 		  break;
#-		  
#+
# 		case 8: /* MOVA #imm20, Rdst */
# 		  cmd_len = 4;
# 		  n <<= 16;
#@@ -1064,7 +1064,7 @@ print_insn_msp430 (bfd_vma addr, disassemble_info *info)
# 		  if (strcmp (opcode->name, "bra") != 0)
# 		    sprintf (op2, "r%d", reg);
# 		  break;
#-		  
#+
# 		case 12: /* MOVA Rsrc, Rdst */
# 		  cmd_len = 2;
# 		  sprintf (op1, "r%d", n);
#@@ -1110,7 +1110,7 @@ print_insn_msp430 (bfd_vma addr, disassemble_info *info)
# 		      sprintf (comm2, _("Reserved use of A/L and B/W bits detected"));
# 		    }
# 		}
#-	      
#+
# 	      break;
# 	    case 1:
# 	      cmd_len +=
--- a/opcodes/mt-asm.c
+++ b/opcodes/mt-asm.c
@@ -52,7 +52,7 @@ static const char * parse_insn_normal
 /* Range checking for signed numbers.  Returns 0 if acceptable
    and 1 if the value is out of bounds for a signed quantity.  */
 
-static int 
+static int
 signed_out_of_bounds (long val)
 {
   if ((val < -32768) || (val > 32767))
@@ -72,7 +72,7 @@ parse_loopsize (CGEN_CPU_DESC cd,
   enum cgen_parse_operand_result result_type;
   bfd_vma value;
 
-  /* Is it a control transfer instructions?  */ 
+  /* Is it a control transfer instructions?  */
   if (opindex == (CGEN_OPERAND_TYPE) MT_OPERAND_LOOPSIZE)
     {
       code = BFD_RELOC_MT_PCINSN8;
@@ -97,7 +97,7 @@ parse_imm16 (CGEN_CPU_DESC cd,
   bfd_reloc_code_real_type code = BFD_RELOC_NONE;
   bfd_vma value;
 
-  /* Is it a control transfer instructions?  */ 
+  /* Is it a control transfer instructions?  */
   if (opindex == (CGEN_OPERAND_TYPE) MT_OPERAND_IMM16O)
     {
       code = BFD_RELOC_16_PCREL;
@@ -144,7 +144,7 @@ parse_imm16 (CGEN_CPU_DESC cd,
 		 value = (value >> 16) & 0xFFFF;
 	       else if (code == BFD_RELOC_LO16)
 		 value = value  & 0xFFFF;
-	       else 
+	       else
 		 errmsg = _("Biiiig Trouble in parse_imm16!");
 	       break;
 
@@ -173,27 +173,27 @@ parse_imm16 (CGEN_CPU_DESC cd,
       if (parse_signed)
 	{
           /* Parse as as signed integer.  */
- 
+
           errmsg = cgen_parse_signed_integer (cd, strp, opindex, valuep);
 
-          if (errmsg == NULL) 
+          if (errmsg == NULL)
 	    {
 #if 0
 	      /* Manual range checking is needed for the signed case.  */
 	      if (*valuep & 0x8000)
                 value = 0xffff0000 | *valuep;
-	      else 
+	      else
                 value = *valuep;
 
 	      if (signed_out_of_bounds (value))
 	        errmsg = _("Operand out of range. Must be between -32768 and 32767.");
 	      /* Truncate to 16 bits. This is necessary
 		 because cgen will have sign extended *valuep.  */
-	      *valuep &= 0xFFFF; 
+	      *valuep &= 0xFFFF;
 #endif
 	    }
 	}
-      else  
+      else
 	{
           /* MT_OPERAND_IMM16Z.  Parse as an unsigned integer.  */
           errmsg = cgen_parse_unsigned_integer (cd, strp, opindex, (unsigned long *) valuep);
@@ -598,7 +598,7 @@ mt_cgen_parse_operand (CGEN_CPU_DESC cd,
   return errmsg;
 }
 
-cgen_parse_fn * const mt_cgen_parse_handlers[] = 
+cgen_parse_fn * const mt_cgen_parse_handlers[] =
 {
   parse_insn_normal,
 };
@@ -628,9 +628,9 @@ CGEN_ASM_INIT_HOOK
 
    Returns NULL for success, an error message for failure.  */
 
-char * 
+char *
 mt_cgen_build_insn_regex (CGEN_INSN *insn)
-{  
+{
   CGEN_OPCODE *opc = (CGEN_OPCODE *) CGEN_INSN_OPCODE (insn);
   const char *mnem = CGEN_INSN_MNEMONIC (insn);
   char rxbuf[CGEN_MAX_RX_ELEMENTS];
@@ -669,18 +669,18 @@ mt_cgen_build_insn_regex (CGEN_INSN *insn)
   /* Copy any remaining literals from the syntax string into the rx.  */
   for(; * syn != 0 && rx <= rxbuf + (CGEN_MAX_RX_ELEMENTS - 7 - 4); ++syn)
     {
-      if (CGEN_SYNTAX_CHAR_P (* syn)) 
+      if (CGEN_SYNTAX_CHAR_P (* syn))
 	{
 	  char c = CGEN_SYNTAX_CHAR (* syn);
 
-	  switch (c) 
+	  switch (c)
 	    {
 	      /* Escape any regex metacharacters in the syntax.  */
-	    case '.': case '[': case '\\': 
-	    case '*': case '^': case '$': 
+	    case '.': case '[': case '\\':
+	    case '*': case '^': case '$':
 
 #ifdef CGEN_ESCAPE_EXTENDED_REGEX
-	    case '?': case '{': case '}': 
+	    case '?': case '{': case '}':
 	    case '(': case ')': case '*':
 	    case '|': case '+': case ']':
 #endif
@@ -710,20 +710,20 @@ mt_cgen_build_insn_regex (CGEN_INSN *insn)
     }
 
   /* Trailing whitespace ok.  */
-  * rx++ = '['; 
-  * rx++ = ' '; 
-  * rx++ = '\t'; 
-  * rx++ = ']'; 
-  * rx++ = '*'; 
+  * rx++ = '[';
+  * rx++ = ' ';
+  * rx++ = '\t';
+  * rx++ = ']';
+  * rx++ = '*';
 
   /* But anchor it after that.  */
-  * rx++ = '$'; 
+  * rx++ = '$';
   * rx = '\0';
 
   CGEN_INSN_RX (insn) = xmalloc (sizeof (regex_t));
   reg_err = regcomp ((regex_t *) CGEN_INSN_RX (insn), rxbuf, REG_NOSUB);
 
-  if (reg_err == 0) 
+  if (reg_err == 0)
     return NULL;
   else
     {
@@ -922,7 +922,7 @@ mt_cgen_assemble_insn (CGEN_CPU_DESC cd,
       const CGEN_INSN *insn = ilist->insn;
       recognized_mnemonic = 1;
 
-#ifdef CGEN_VALIDATE_INSN_SUPPORTED 
+#ifdef CGEN_VALIDATE_INSN_SUPPORTED
       /* Not usually needed as unsupported opcodes
 	 shouldn't be in the hash lists.  */
       /* Is this insn supported by the selected cpu?  */
@@ -982,7 +982,7 @@ mt_cgen_assemble_insn (CGEN_CPU_DESC cd,
 	if (strlen (start) > 50)
 	  /* xgettext:c-format */
 	  sprintf (errbuf, "%s `%.50s...'", tmp_errmsg, start);
-	else 
+	else
 	  /* xgettext:c-format */
 	  sprintf (errbuf, "%s `%.50s'", tmp_errmsg, start);
       }
@@ -991,11 +991,11 @@ mt_cgen_assemble_insn (CGEN_CPU_DESC cd,
 	if (strlen (start) > 50)
 	  /* xgettext:c-format */
 	  sprintf (errbuf, _("bad instruction `%.50s...'"), start);
-	else 
+	else
 	  /* xgettext:c-format */
 	  sprintf (errbuf, _("bad instruction `%.50s'"), start);
       }
-      
+
     *errmsg = errbuf;
     return NULL;
   }
--- a/opcodes/mt-desc.c
+++ b/opcodes/mt-desc.c
@@ -310,223 +310,223 @@ const CGEN_OPERAND mt_cgen_operand_table[] =
 {
 /* pc: program counter */
   { "pc", MT_OPERAND_PC, HW_H_PC, 0, 0,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_NIL] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_NIL] } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* frsr1: register */
   { "frsr1", MT_OPERAND_FRSR1, HW_H_SPR, 23, 4,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_SR1] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_SR1] } },
     { 0|A(ABS_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
 /* frsr2: register */
   { "frsr2", MT_OPERAND_FRSR2, HW_H_SPR, 19, 4,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_SR2] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_SR2] } },
     { 0|A(ABS_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
 /* frdr: register */
   { "frdr", MT_OPERAND_FRDR, HW_H_SPR, 19, 4,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_DR] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_DR] } },
     { 0|A(ABS_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
 /* frdrrr: register */
   { "frdrrr", MT_OPERAND_FRDRRR, HW_H_SPR, 15, 4,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_DRRR] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_DRRR] } },
     { 0|A(ABS_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
 /* imm16: immediate value - sign extd */
   { "imm16", MT_OPERAND_IMM16, HW_H_SINT, 15, 16,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_IMM16S] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_IMM16S] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* imm16z: immediate value - zero extd */
   { "imm16z", MT_OPERAND_IMM16Z, HW_H_UINT, 15, 16,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_IMM16U] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_IMM16U] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* imm16o: immediate value */
   { "imm16o", MT_OPERAND_IMM16O, HW_H_UINT, 15, 16,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_IMM16S] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_IMM16S] } },
     { 0|A(PCREL_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
 /* rc: rc */
   { "rc", MT_OPERAND_RC, HW_H_UINT, 15, 1,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_RC] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_RC] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* rcnum: rcnum */
   { "rcnum", MT_OPERAND_RCNUM, HW_H_UINT, 14, 3,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_RCNUM] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_RCNUM] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* contnum: context number */
   { "contnum", MT_OPERAND_CONTNUM, HW_H_UINT, 8, 9,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_CONTNUM] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_CONTNUM] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* rbbc: omega network configuration */
   { "rbbc", MT_OPERAND_RBBC, HW_H_UINT, 25, 2,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_RBBC] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_RBBC] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* colnum: column number */
   { "colnum", MT_OPERAND_COLNUM, HW_H_UINT, 18, 3,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_COLNUM] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_COLNUM] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* rownum: row number */
   { "rownum", MT_OPERAND_ROWNUM, HW_H_UINT, 14, 3,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_ROWNUM] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_ROWNUM] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* rownum1: row number */
   { "rownum1", MT_OPERAND_ROWNUM1, HW_H_UINT, 12, 3,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_ROWNUM1] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_ROWNUM1] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* rownum2: row number */
   { "rownum2", MT_OPERAND_ROWNUM2, HW_H_UINT, 9, 3,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_ROWNUM2] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_ROWNUM2] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* rc1: rc1 */
   { "rc1", MT_OPERAND_RC1, HW_H_UINT, 11, 1,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_RC1] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_RC1] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* rc2: rc2 */
   { "rc2", MT_OPERAND_RC2, HW_H_UINT, 6, 1,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_RC2] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_RC2] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* cbrb: data-bus orientation */
   { "cbrb", MT_OPERAND_CBRB, HW_H_UINT, 10, 1,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_CBRB] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_CBRB] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* cell: cell */
   { "cell", MT_OPERAND_CELL, HW_H_UINT, 9, 3,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_CELL] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_CELL] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* dup: dup */
   { "dup", MT_OPERAND_DUP, HW_H_UINT, 6, 1,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_DUP] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_DUP] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* ctxdisp: context displacement */
   { "ctxdisp", MT_OPERAND_CTXDISP, HW_H_UINT, 5, 6,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_CTXDISP] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_CTXDISP] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* fbdisp: frame buffer displacement */
   { "fbdisp", MT_OPERAND_FBDISP, HW_H_UINT, 15, 6,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_FBDISP] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_FBDISP] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* type: type */
   { "type", MT_OPERAND_TYPE, HW_H_UINT, 21, 2,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_TYPE] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_TYPE] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* mask: mask */
   { "mask", MT_OPERAND_MASK, HW_H_UINT, 25, 16,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_MASK] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_MASK] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* bankaddr: bank address */
   { "bankaddr", MT_OPERAND_BANKADDR, HW_H_UINT, 25, 13,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_BANKADDR] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_BANKADDR] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* incamt: increment amount */
   { "incamt", MT_OPERAND_INCAMT, HW_H_UINT, 19, 8,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_INCAMT] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_INCAMT] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* xmode: xmode */
   { "xmode", MT_OPERAND_XMODE, HW_H_UINT, 23, 1,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_XMODE] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_XMODE] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* mask1: mask1 */
   { "mask1", MT_OPERAND_MASK1, HW_H_UINT, 22, 3,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_MASK1] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_MASK1] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* ball: b_all */
   { "ball", MT_OPERAND_BALL, HW_H_UINT, 19, 1,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_BALL] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_BALL] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* brc: b_r_c */
   { "brc", MT_OPERAND_BRC, HW_H_UINT, 18, 3,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_BRC] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_BRC] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* rda: rd */
   { "rda", MT_OPERAND_RDA, HW_H_UINT, 25, 1,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_RDA] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_RDA] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* wr: wr */
   { "wr", MT_OPERAND_WR, HW_H_UINT, 24, 1,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_WR] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_WR] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* ball2: b_all2 */
   { "ball2", MT_OPERAND_BALL2, HW_H_UINT, 15, 1,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_BALL2] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_BALL2] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* brc2: b_r_c2 */
   { "brc2", MT_OPERAND_BRC2, HW_H_UINT, 14, 3,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_BRC2] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_BRC2] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* perm: perm */
   { "perm", MT_OPERAND_PERM, HW_H_UINT, 25, 2,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_PERM] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_PERM] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* a23: a23 */
   { "a23", MT_OPERAND_A23, HW_H_UINT, 23, 1,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_A23] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_A23] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* cr: c-r */
   { "cr", MT_OPERAND_CR, HW_H_UINT, 22, 3,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_CR] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_CR] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* cbs: cbs */
   { "cbs", MT_OPERAND_CBS, HW_H_UINT, 19, 2,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_CBS] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_CBS] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* incr: incr */
   { "incr", MT_OPERAND_INCR, HW_H_UINT, 17, 6,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_INCR] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_INCR] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* length: length */
   { "length", MT_OPERAND_LENGTH, HW_H_UINT, 15, 3,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_LENGTH] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_LENGTH] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* cbx: cbx */
   { "cbx", MT_OPERAND_CBX, HW_H_UINT, 14, 3,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_CBX] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_CBX] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* ccb: ccb */
   { "ccb", MT_OPERAND_CCB, HW_H_UINT, 11, 1,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_CCB] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_CCB] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* cdb: cdb */
   { "cdb", MT_OPERAND_CDB, HW_H_UINT, 10, 1,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_CDB] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_CDB] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* mode: mode */
   { "mode", MT_OPERAND_MODE, HW_H_UINT, 25, 2,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_MODE] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_MODE] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* id: i/d */
   { "id", MT_OPERAND_ID, HW_H_UINT, 14, 1,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_ID] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_ID] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* size: size */
   { "size", MT_OPERAND_SIZE, HW_H_UINT, 13, 14,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_SIZE] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_SIZE] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* fbincr: fb incr */
   { "fbincr", MT_OPERAND_FBINCR, HW_H_UINT, 23, 4,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_FBINCR] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_FBINCR] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* loopsize: immediate value */
   { "loopsize", MT_OPERAND_LOOPSIZE, HW_H_UINT, 7, 8,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_LOOPO] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_LOOPO] } },
     { 0|A(PCREL_ADDR), { { { (1<<MACH_MS2), 0 } } } }  },
 /* imm16l: immediate value */
   { "imm16l", MT_OPERAND_IMM16L, HW_H_UINT, 23, 16,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_IMM16L] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_IMM16L] } },
     { 0, { { { (1<<MACH_MS2), 0 } } } }  },
 /* rc3: rc3 */
   { "rc3", MT_OPERAND_RC3, HW_H_UINT, 7, 1,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_RC3] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_RC3] } },
     { 0, { { { (1<<MACH_MS2), 0 } } } }  },
 /* cb1sel: cb1sel */
   { "cb1sel", MT_OPERAND_CB1SEL, HW_H_UINT, 25, 3,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_CB1SEL] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_CB1SEL] } },
     { 0, { { { (1<<MACH_MS2), 0 } } } }  },
 /* cb2sel: cb2sel */
   { "cb2sel", MT_OPERAND_CB2SEL, HW_H_UINT, 22, 3,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_CB2SEL] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_CB2SEL] } },
     { 0, { { { (1<<MACH_MS2), 0 } } } }  },
 /* cb1incr: cb1incr */
   { "cb1incr", MT_OPERAND_CB1INCR, HW_H_SINT, 19, 6,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_CB1INCR] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_CB1INCR] } },
     { 0|A(SIGNED), { { { (1<<MACH_MS2), 0 } } } }  },
 /* cb2incr: cb2incr */
   { "cb2incr", MT_OPERAND_CB2INCR, HW_H_SINT, 13, 6,
-    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_CB2INCR] } }, 
+    { 0, { (const PTR) &mt_cgen_ifld_table[MT_F_CB2INCR] } },
     { 0|A(SIGNED), { { { (1<<MACH_MS2), 0 } } } }  },
 /* sentinel */
   { 0, 0, 0, 0, 0,
@@ -1249,7 +1249,7 @@ mt_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)
 
   /* Default to not allowing signed overflow.  */
   cd->signed_overflow_ok_p = 0;
-  
+
   return (CGEN_CPU_DESC) cd;
 }
 
@@ -1289,7 +1289,7 @@ mt_cgen_cpu_close (CGEN_CPU_DESC cd)
       for (i = 0; i < cd->insn_table.num_init_entries; ++i, ++insns)
 	if (CGEN_INSN_RX (insns))
 	  regfree (CGEN_INSN_RX (insns));
-    }  
+    }
 
   if (cd->macro_insn_table.init_entries)
     free ((CGEN_INSN *) cd->macro_insn_table.init_entries);
--- a/opcodes/mt-dis.c
+++ b/opcodes/mt-dis.c
@@ -292,7 +292,7 @@ mt_cgen_print_operand (CGEN_CPU_DESC cd,
   }
 }
 
-cgen_print_fn * const mt_cgen_print_handlers[] = 
+cgen_print_fn * const mt_cgen_print_handlers[] =
 {
   print_insn_normal,
 };
@@ -482,7 +482,7 @@ print_insn (CGEN_CPU_DESC cd,
       int length;
       unsigned long insn_value_cropped;
 
-#ifdef CGEN_VALIDATE_INSN_SUPPORTED 
+#ifdef CGEN_VALIDATE_INSN_SUPPORTED
       /* Not needed as insn shouldn't be in hash lists if not supported.  */
       /* Supported by this cpu?  */
       if (! mt_cgen_insn_supported (cd, insn))
@@ -500,7 +500,7 @@ print_insn (CGEN_CPU_DESC cd,
          relevant part from the buffer. */
       if ((unsigned) (CGEN_INSN_BITSIZE (insn) / 8) < buflen &&
 	  (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
-	insn_value_cropped = bfd_get_bits (buf, CGEN_INSN_BITSIZE (insn), 
+	insn_value_cropped = bfd_get_bits (buf, CGEN_INSN_BITSIZE (insn),
 					   info->endian == BFD_ENDIAN_BIG);
       else
 	insn_value_cropped = insn_value;
@@ -619,7 +619,7 @@ print_insn_mt (bfd_vma pc, disassemble_info *info)
   arch = info->arch;
   if (arch == bfd_arch_unknown)
     arch = CGEN_BFD_ARCH;
-   
+
   /* There's no standard way to compute the machine or isa number
      so we leave it to the target.  */
 #ifdef CGEN_COMPUTE_MACH
@@ -660,7 +660,7 @@ print_insn_mt (bfd_vma pc, disassemble_info *info)
 	      break;
 	    }
 	}
-    } 
+    }
 
   /* If we haven't initialized yet, initialize the opcode table.  */
   if (! cd)
--- a/opcodes/mt-ibld.c
+++ b/opcodes/mt-ibld.c
@@ -154,7 +154,7 @@ insert_normal (CGEN_CPU_DESC cd,
     {
       long minval = - (1L << (length - 1));
       unsigned long maxval = mask;
-      
+
       if ((value > 0 && (unsigned long) value > maxval)
 	  || value < minval)
 	{
@@ -192,7 +192,7 @@ insert_normal (CGEN_CPU_DESC cd,
 	{
 	  long minval = - (1L << (length - 1));
 	  long maxval =   (1L << (length - 1)) - 1;
-	  
+
 	  if (value < minval || value > maxval)
 	    {
 	      sprintf
@@ -970,12 +970,12 @@ mt_cgen_extract_operand (CGEN_CPU_DESC cd,
   return length;
 }
 
-cgen_insert_fn * const mt_cgen_insert_handlers[] = 
+cgen_insert_fn * const mt_cgen_insert_handlers[] =
 {
   insert_insn_normal,
 };
 
-cgen_extract_fn * const mt_cgen_extract_handlers[] = 
+cgen_extract_fn * const mt_cgen_extract_handlers[] =
 {
   extract_insn_normal,
 };
--- a/opcodes/mt-opc.c
+++ b/opcodes/mt-opc.c
@@ -43,7 +43,7 @@ mt_cgen_insn_supported (CGEN_CPU_DESC cd, const CGEN_INSN *insn)
   /* No mach attribute?  Assume it's supported for all machs.  */
   if (machs == 0)
     return 1;
-  
+
   return ((machs & cd->machs) != 0);
 }
 
#--- a/opcodes/nios2-dis.c
#+++ b/opcodes/nios2-dis.c
#@@ -96,7 +96,7 @@ nios2_r2_disassembler_state = {
#   NULL,
#   0
# };
#-  
#+
# /* Function to initialize the opcode hash table.  */
# static void
# nios2_init_opcode_hash (nios2_disassembler_state *state)
#@@ -218,7 +218,7 @@ static struct nios2_reg *
# nios2_coprocessor_regs (void)
# {
#   static struct nios2_reg *cached = NULL;
#-  
#+
#   if (!cached)
#     {
#       int i;
#@@ -238,7 +238,7 @@ static struct nios2_reg *
# nios2_control_regs (void)
# {
#   static struct nios2_reg *cached = NULL;
#-  
#+
#   if (!cached)
#     {
#       int i;
#@@ -859,7 +859,7 @@ nios2_print_insn_arg (const char *argptr,
# 	      reglist = i << 2;
# 	    dir = GET_IW_F1X4L17_REGMASK (opcode) ? 1 : -1;
# 	    break;
#-	    
#+
# 	  case iw_L5I4X1_type:
# 	    /* Encoding for push.n/pop.n.  */
# 	    reglist |= (1 << 31);
#@@ -903,7 +903,7 @@ nios2_print_insn_arg (const char *argptr,
# 	    (*info->fprintf_func) (info->stream, "--");
# 
# 	  i = GET_IW_F1X4I12_A (opcode);
#-	  (*info->fprintf_func) (info->stream, "(%s)", 
#+	  (*info->fprintf_func) (info->stream, "(%s)",
# 				 nios2_builtin_regs[i].name);
# 
# 	  if (GET_IW_F1X4L17_ID (opcode))
--- a/opcodes/ns32k-dis.c
+++ b/opcodes/ns32k-dis.c
@@ -413,7 +413,7 @@ invalid_float (bfd_byte *p, int len)
 #else
 /* Assumes the bytes have been swapped to local order.  */
 typedef union
-{ 
+{
   double d;
   float f;
   struct { unsigned m:23, e:8, :1;} sf;
@@ -618,7 +618,7 @@ print_insn_arg (int d,
 	    int bit_index;
 	    static const char *ind = "bwdq";
 	    char *off;
-	    
+
 	    /* Scaled index basemode[R0 -- R7:B,W,D,Q].  */
 	    bit_index = bit_extract (buffer, index_offset - 8, 3);
 	    print_insn_arg (d, index_offset, aoffsetp, buffer, addr,
@@ -794,7 +794,7 @@ print_insn_ns32k (bfd_vma memaddr, disassemble_info *info)
 
       /* 0 for operand A, 1 for operand B, greater for other args.  */
       int whicharg = 0;
-      
+
       (*dis_info->fprintf_func)(dis_info->stream, "\t");
 
       maxarg = 0;
--- a/opcodes/opintl.h
+++ b/opcodes/opintl.h
@@ -23,7 +23,7 @@
 #ifdef ENABLE_NLS
 # include <libintl.h>
 /* Note the use of dgetext() and PACKAGE here, rather than gettext().
-   
+
    This is because the code in this directory is used to build a library which
    will be linked with code in other directories to form programs.  We want to
    maintain a seperate translation file for this directory however, rather
#--- a/opcodes/or1k-asm.c
#+++ b/opcodes/or1k-asm.c
#@@ -506,7 +506,7 @@ or1k_cgen_parse_operand (CGEN_CPU_DESC cd,
#   return errmsg;
# }
# 
#-cgen_parse_fn * const or1k_cgen_parse_handlers[] = 
#+cgen_parse_fn * const or1k_cgen_parse_handlers[] =
# {
#   parse_insn_normal,
# };
#@@ -536,9 +536,9 @@ CGEN_ASM_INIT_HOOK
# 
#    Returns NULL for success, an error message for failure.  */
# 
#-char * 
#+char *
# or1k_cgen_build_insn_regex (CGEN_INSN *insn)
#-{  
#+{
#   CGEN_OPCODE *opc = (CGEN_OPCODE *) CGEN_INSN_OPCODE (insn);
#   const char *mnem = CGEN_INSN_MNEMONIC (insn);
#   char rxbuf[CGEN_MAX_RX_ELEMENTS];
#@@ -577,18 +577,18 @@ or1k_cgen_build_insn_regex (CGEN_INSN *insn)
#   /* Copy any remaining literals from the syntax string into the rx.  */
#   for(; * syn != 0 && rx <= rxbuf + (CGEN_MAX_RX_ELEMENTS - 7 - 4); ++syn)
#     {
#-      if (CGEN_SYNTAX_CHAR_P (* syn)) 
#+      if (CGEN_SYNTAX_CHAR_P (* syn))
# 	{
# 	  char c = CGEN_SYNTAX_CHAR (* syn);
# 
#-	  switch (c) 
#+	  switch (c)
# 	    {
# 	      /* Escape any regex metacharacters in the syntax.  */
#-	    case '.': case '[': case '\\': 
#-	    case '*': case '^': case '$': 
#+	    case '.': case '[': case '\\':
#+	    case '*': case '^': case '$':
# 
# #ifdef CGEN_ESCAPE_EXTENDED_REGEX
#-	    case '?': case '{': case '}': 
#+	    case '?': case '{': case '}':
# 	    case '(': case ')': case '*':
# 	    case '|': case '+': case ']':
# #endif
#@@ -618,20 +618,20 @@ or1k_cgen_build_insn_regex (CGEN_INSN *insn)
#     }
# 
#   /* Trailing whitespace ok.  */
#-  * rx++ = '['; 
#-  * rx++ = ' '; 
#-  * rx++ = '\t'; 
#-  * rx++ = ']'; 
#-  * rx++ = '*'; 
#+  * rx++ = '[';
#+  * rx++ = ' ';
#+  * rx++ = '\t';
#+  * rx++ = ']';
#+  * rx++ = '*';
# 
#   /* But anchor it after that.  */
#-  * rx++ = '$'; 
#+  * rx++ = '$';
#   * rx = '\0';
# 
#   CGEN_INSN_RX (insn) = xmalloc (sizeof (regex_t));
#   reg_err = regcomp ((regex_t *) CGEN_INSN_RX (insn), rxbuf, REG_NOSUB);
# 
#-  if (reg_err == 0) 
#+  if (reg_err == 0)
#     return NULL;
#   else
#     {
#@@ -830,7 +830,7 @@ or1k_cgen_assemble_insn (CGEN_CPU_DESC cd,
#       const CGEN_INSN *insn = ilist->insn;
#       recognized_mnemonic = 1;
# 
#-#ifdef CGEN_VALIDATE_INSN_SUPPORTED 
#+#ifdef CGEN_VALIDATE_INSN_SUPPORTED
#       /* Not usually needed as unsupported opcodes
# 	 shouldn't be in the hash lists.  */
#       /* Is this insn supported by the selected cpu?  */
#@@ -890,7 +890,7 @@ or1k_cgen_assemble_insn (CGEN_CPU_DESC cd,
# 	if (strlen (start) > 50)
# 	  /* xgettext:c-format */
# 	  sprintf (errbuf, "%s `%.50s...'", tmp_errmsg, start);
#-	else 
#+	else
# 	  /* xgettext:c-format */
# 	  sprintf (errbuf, "%s `%.50s'", tmp_errmsg, start);
#       }
#@@ -899,11 +899,11 @@ or1k_cgen_assemble_insn (CGEN_CPU_DESC cd,
# 	if (strlen (start) > 50)
# 	  /* xgettext:c-format */
# 	  sprintf (errbuf, _("bad instruction `%.50s...'"), start);
#-	else 
#+	else
# 	  /* xgettext:c-format */
# 	  sprintf (errbuf, _("bad instruction `%.50s'"), start);
#       }
#-      
#+
#     *errmsg = errbuf;
#     return NULL;
#   }
#--- a/opcodes/or1k-desc.c
#+++ b/opcodes/or1k-desc.c
#@@ -1008,127 +1008,127 @@ const CGEN_OPERAND or1k_cgen_operand_table[] =
# {
# /* pc: program counter */
#   { "pc", OR1K_OPERAND_PC, HW_H_PC, 0, 0,
#-    { 0, { (const PTR) &or1k_cgen_ifld_table[OR1K_F_NIL] } }, 
#+    { 0, { (const PTR) &or1k_cgen_ifld_table[OR1K_F_NIL] } },
#     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
# /* sys-sr: supervision register */
#   { "sys-sr", OR1K_OPERAND_SYS_SR, HW_H_SYS_SR, 0, 0,
#-    { 0, { (const PTR) 0 } }, 
#+    { 0, { (const PTR) 0 } },
#     { 0|A(SEM_ONLY), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
# /* sys-esr0: exception supervision register 0 */
#   { "sys-esr0", OR1K_OPERAND_SYS_ESR0, HW_H_SYS_ESR0, 0, 0,
#-    { 0, { (const PTR) 0 } }, 
#+    { 0, { (const PTR) 0 } },
#     { 0|A(SEM_ONLY), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
# /* sys-epcr0: exception PC register 0 */
#   { "sys-epcr0", OR1K_OPERAND_SYS_EPCR0, HW_H_SYS_EPCR0, 0, 0,
#-    { 0, { (const PTR) 0 } }, 
#+    { 0, { (const PTR) 0 } },
#     { 0|A(SEM_ONLY), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
# /* sys-sr-lee: SR little endian enable bit */
#   { "sys-sr-lee", OR1K_OPERAND_SYS_SR_LEE, HW_H_SYS_SR_LEE, 0, 0,
#-    { 0, { (const PTR) 0 } }, 
#+    { 0, { (const PTR) 0 } },
#     { 0|A(SEM_ONLY), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
# /* sys-sr-f: SR flag bit */
#   { "sys-sr-f", OR1K_OPERAND_SYS_SR_F, HW_H_SYS_SR_F, 0, 0,
#-    { 0, { (const PTR) 0 } }, 
#+    { 0, { (const PTR) 0 } },
#     { 0|A(SEM_ONLY), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
# /* sys-sr-cy: SR carry bit */
#   { "sys-sr-cy", OR1K_OPERAND_SYS_SR_CY, HW_H_SYS_SR_CY, 0, 0,
#-    { 0, { (const PTR) 0 } }, 
#+    { 0, { (const PTR) 0 } },
#     { 0|A(SEM_ONLY), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
# /* sys-sr-ov: SR overflow bit */
#   { "sys-sr-ov", OR1K_OPERAND_SYS_SR_OV, HW_H_SYS_SR_OV, 0, 0,
#-    { 0, { (const PTR) 0 } }, 
#+    { 0, { (const PTR) 0 } },
#     { 0|A(SEM_ONLY), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
# /* sys-sr-ove: SR overflow exception enable bit */
#   { "sys-sr-ove", OR1K_OPERAND_SYS_SR_OVE, HW_H_SYS_SR_OVE, 0, 0,
#-    { 0, { (const PTR) 0 } }, 
#+    { 0, { (const PTR) 0 } },
#     { 0|A(SEM_ONLY), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
# /* sys-cpucfgr-ob64s: CPUCFGR ORBIS64 supported bit */
#   { "sys-cpucfgr-ob64s", OR1K_OPERAND_SYS_CPUCFGR_OB64S, HW_H_SYS_CPUCFGR_OB64S, 0, 0,
#-    { 0, { (const PTR) 0 } }, 
#+    { 0, { (const PTR) 0 } },
#     { 0|A(SEM_ONLY), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
# /* sys-cpucfgr-nd: CPUCFGR no delay bit */
#   { "sys-cpucfgr-nd", OR1K_OPERAND_SYS_CPUCFGR_ND, HW_H_SYS_CPUCFGR_ND, 0, 0,
#-    { 0, { (const PTR) 0 } }, 
#+    { 0, { (const PTR) 0 } },
#     { 0|A(SEM_ONLY), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
# /* sys-fpcsr-rm: floating point round mode */
#   { "sys-fpcsr-rm", OR1K_OPERAND_SYS_FPCSR_RM, HW_H_SYS_FPCSR_RM, 0, 0,
#-    { 0, { (const PTR) 0 } }, 
#+    { 0, { (const PTR) 0 } },
#     { 0|A(SEM_ONLY), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
# /* mac-machi: MAC HI result register */
#   { "mac-machi", OR1K_OPERAND_MAC_MACHI, HW_H_MAC_MACHI, 0, 0,
#-    { 0, { (const PTR) 0 } }, 
#+    { 0, { (const PTR) 0 } },
#     { 0|A(SEM_ONLY), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
# /* mac-maclo: MAC LO result register */
#   { "mac-maclo", OR1K_OPERAND_MAC_MACLO, HW_H_MAC_MACLO, 0, 0,
#-    { 0, { (const PTR) 0 } }, 
#+    { 0, { (const PTR) 0 } },
#     { 0|A(SEM_ONLY), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
# /* atomic-reserve: atomic reserve flag */
#   { "atomic-reserve", OR1K_OPERAND_ATOMIC_RESERVE, HW_H_ATOMIC_RESERVE, 0, 0,
#-    { 0, { (const PTR) 0 } }, 
#+    { 0, { (const PTR) 0 } },
#     { 0|A(SEM_ONLY), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
# /* atomic-address: atomic address */
#   { "atomic-address", OR1K_OPERAND_ATOMIC_ADDRESS, HW_H_ATOMIC_ADDRESS, 0, 0,
#-    { 0, { (const PTR) 0 } }, 
#+    { 0, { (const PTR) 0 } },
#     { 0|A(SEM_ONLY), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
# /* uimm6: uimm6 */
#   { "uimm6", OR1K_OPERAND_UIMM6, HW_H_UIMM6, 5, 6,
#-    { 0, { (const PTR) &or1k_cgen_ifld_table[OR1K_F_UIMM6] } }, 
#+    { 0, { (const PTR) &or1k_cgen_ifld_table[OR1K_F_UIMM6] } },
#     { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
# /* rD: destination register */
#   { "rD", OR1K_OPERAND_RD, HW_H_GPR, 25, 5,
#-    { 0, { (const PTR) &or1k_cgen_ifld_table[OR1K_F_R1] } }, 
#+    { 0, { (const PTR) &or1k_cgen_ifld_table[OR1K_F_R1] } },
#     { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
# /* rA: source register A */
#   { "rA", OR1K_OPERAND_RA, HW_H_GPR, 20, 5,
#-    { 0, { (const PTR) &or1k_cgen_ifld_table[OR1K_F_R2] } }, 
#+    { 0, { (const PTR) &or1k_cgen_ifld_table[OR1K_F_R2] } },
#     { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
# /* rB: source register B */
#   { "rB", OR1K_OPERAND_RB, HW_H_GPR, 15, 5,
#-    { 0, { (const PTR) &or1k_cgen_ifld_table[OR1K_F_R3] } }, 
#+    { 0, { (const PTR) &or1k_cgen_ifld_table[OR1K_F_R3] } },
#     { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
# /* disp26: pc-rel 26 bit */
#   { "disp26", OR1K_OPERAND_DISP26, HW_H_IADDR, 25, 26,
#-    { 0, { (const PTR) &or1k_cgen_ifld_table[OR1K_F_DISP26] } }, 
#+    { 0, { (const PTR) &or1k_cgen_ifld_table[OR1K_F_DISP26] } },
#     { 0|A(PCREL_ADDR), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
# /* simm16: 16-bit signed immediate */
#   { "simm16", OR1K_OPERAND_SIMM16, HW_H_SIMM16, 15, 16,
#-    { 0, { (const PTR) &or1k_cgen_ifld_table[OR1K_F_SIMM16] } }, 
#+    { 0, { (const PTR) &or1k_cgen_ifld_table[OR1K_F_SIMM16] } },
#     { 0|A(SIGN_OPT), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
# /* uimm16: 16-bit unsigned immediate */
#   { "uimm16", OR1K_OPERAND_UIMM16, HW_H_UIMM16, 15, 16,
#-    { 0, { (const PTR) &or1k_cgen_ifld_table[OR1K_F_UIMM16] } }, 
#+    { 0, { (const PTR) &or1k_cgen_ifld_table[OR1K_F_UIMM16] } },
#     { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
# /* simm16-split: split 16-bit signed immediate */
#   { "simm16-split", OR1K_OPERAND_SIMM16_SPLIT, HW_H_SIMM16, 10, 16,
#-    { 2, { (const PTR) &OR1K_F_SIMM16_SPLIT_MULTI_IFIELD[0] } }, 
#+    { 2, { (const PTR) &OR1K_F_SIMM16_SPLIT_MULTI_IFIELD[0] } },
#     { 0|A(SIGN_OPT)|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
# /* uimm16-split: split 16-bit unsigned immediate */
#   { "uimm16-split", OR1K_OPERAND_UIMM16_SPLIT, HW_H_UIMM16, 10, 16,
#-    { 2, { (const PTR) &OR1K_F_UIMM16_SPLIT_MULTI_IFIELD[0] } }, 
#+    { 2, { (const PTR) &OR1K_F_UIMM16_SPLIT_MULTI_IFIELD[0] } },
#     { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
# /* rDSF: destination register (single floating point mode) */
#   { "rDSF", OR1K_OPERAND_RDSF, HW_H_FSR, 25, 5,
#-    { 0, { (const PTR) &or1k_cgen_ifld_table[OR1K_F_R1] } }, 
#+    { 0, { (const PTR) &or1k_cgen_ifld_table[OR1K_F_R1] } },
#     { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
# /* rASF: source register A (single floating point mode) */
#   { "rASF", OR1K_OPERAND_RASF, HW_H_FSR, 20, 5,
#-    { 0, { (const PTR) &or1k_cgen_ifld_table[OR1K_F_R2] } }, 
#+    { 0, { (const PTR) &or1k_cgen_ifld_table[OR1K_F_R2] } },
#     { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
# /* rBSF: source register B (single floating point mode) */
#   { "rBSF", OR1K_OPERAND_RBSF, HW_H_FSR, 15, 5,
#-    { 0, { (const PTR) &or1k_cgen_ifld_table[OR1K_F_R3] } }, 
#+    { 0, { (const PTR) &or1k_cgen_ifld_table[OR1K_F_R3] } },
#     { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
# /* rDDF: destination register (double floating point mode) */
#   { "rDDF", OR1K_OPERAND_RDDF, HW_H_FDR, 25, 5,
#-    { 0, { (const PTR) &or1k_cgen_ifld_table[OR1K_F_R1] } }, 
#+    { 0, { (const PTR) &or1k_cgen_ifld_table[OR1K_F_R1] } },
#     { 0, { { { (1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
# /* rADF: source register A (double floating point mode) */
#   { "rADF", OR1K_OPERAND_RADF, HW_H_FDR, 25, 5,
#-    { 0, { (const PTR) &or1k_cgen_ifld_table[OR1K_F_R1] } }, 
#+    { 0, { (const PTR) &or1k_cgen_ifld_table[OR1K_F_R1] } },
#     { 0, { { { (1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
# /* rBDF: source register B (double floating point mode) */
#   { "rBDF", OR1K_OPERAND_RBDF, HW_H_FDR, 25, 5,
#-    { 0, { (const PTR) &or1k_cgen_ifld_table[OR1K_F_R1] } }, 
#+    { 0, { (const PTR) &or1k_cgen_ifld_table[OR1K_F_R1] } },
#     { 0, { { { (1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
# /* sentinel */
#   { 0, 0, 0, 0, 0,
#@@ -2051,7 +2051,7 @@ or1k_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)
# 
#   /* Default to not allowing signed overflow.  */
#   cd->signed_overflow_ok_p = 0;
#-  
#+
#   return (CGEN_CPU_DESC) cd;
# }
# 
#@@ -2091,7 +2091,7 @@ or1k_cgen_cpu_close (CGEN_CPU_DESC cd)
#       for (i = 0; i < cd->insn_table.num_init_entries; ++i, ++insns)
# 	if (CGEN_INSN_RX (insns))
# 	  regfree (CGEN_INSN_RX (insns));
#-    }  
#+    }
# 
#   if (cd->macro_insn_table.init_entries)
#     free ((CGEN_INSN *) cd->macro_insn_table.init_entries);
#--- a/opcodes/or1k-dis.c
#+++ b/opcodes/or1k-dis.c
#@@ -143,7 +143,7 @@ or1k_cgen_print_operand (CGEN_CPU_DESC cd,
#   }
# }
# 
#-cgen_print_fn * const or1k_cgen_print_handlers[] = 
#+cgen_print_fn * const or1k_cgen_print_handlers[] =
# {
#   print_insn_normal,
# };
#@@ -333,7 +333,7 @@ print_insn (CGEN_CPU_DESC cd,
#       int length;
#       unsigned long insn_value_cropped;
# 
#-#ifdef CGEN_VALIDATE_INSN_SUPPORTED 
#+#ifdef CGEN_VALIDATE_INSN_SUPPORTED
#       /* Not needed as insn shouldn't be in hash lists if not supported.  */
#       /* Supported by this cpu?  */
#       if (! or1k_cgen_insn_supported (cd, insn))
#@@ -351,7 +351,7 @@ print_insn (CGEN_CPU_DESC cd,
#          relevant part from the buffer. */
#       if ((unsigned) (CGEN_INSN_BITSIZE (insn) / 8) < buflen &&
# 	  (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
#-	insn_value_cropped = bfd_get_bits (buf, CGEN_INSN_BITSIZE (insn), 
#+	insn_value_cropped = bfd_get_bits (buf, CGEN_INSN_BITSIZE (insn),
# 					   info->endian == BFD_ENDIAN_BIG);
#       else
# 	insn_value_cropped = insn_value;
#@@ -470,7 +470,7 @@ print_insn_or1k (bfd_vma pc, disassemble_info *info)
#   arch = info->arch;
#   if (arch == bfd_arch_unknown)
#     arch = CGEN_BFD_ARCH;
#-   
#+
#   /* There's no standard way to compute the machine or isa number
#      so we leave it to the target.  */
# #ifdef CGEN_COMPUTE_MACH
#@@ -511,7 +511,7 @@ print_insn_or1k (bfd_vma pc, disassemble_info *info)
# 	      break;
# 	    }
# 	}
#-    } 
#+    }
# 
#   /* If we haven't initialized yet, initialize the opcode table.  */
#   if (! cd)
#--- a/opcodes/or1k-ibld.c
#+++ b/opcodes/or1k-ibld.c
#@@ -154,7 +154,7 @@ insert_normal (CGEN_CPU_DESC cd,
#     {
#       long minval = - (1L << (length - 1));
#       unsigned long maxval = mask;
#-      
#+
#       if ((value > 0 && (unsigned long) value > maxval)
# 	  || value < minval)
# 	{
#@@ -192,7 +192,7 @@ insert_normal (CGEN_CPU_DESC cd,
# 	{
# 	  long minval = - (1L << (length - 1));
# 	  long maxval =   (1L << (length - 1)) - 1;
#-	  
#+
# 	  if (value < minval || value > maxval)
# 	    {
# 	      sprintf
#@@ -752,12 +752,12 @@ or1k_cgen_extract_operand (CGEN_CPU_DESC cd,
#   return length;
# }
# 
#-cgen_insert_fn * const or1k_cgen_insert_handlers[] = 
#+cgen_insert_fn * const or1k_cgen_insert_handlers[] =
# {
#   insert_insn_normal,
# };
# 
#-cgen_extract_fn * const or1k_cgen_extract_handlers[] = 
#+cgen_extract_fn * const or1k_cgen_extract_handlers[] =
# {
#   extract_insn_normal,
# };
--- a/opcodes/ppc-dis.c
+++ b/opcodes/ppc-dis.c
@@ -687,7 +687,7 @@ print_insn_powerpc (bfd_vma memaddr,
 	    (*info->print_address_func) (memaddr + value, info);
 	  else if ((operand->flags & PPC_OPERAND_ABSOLUTE) != 0)
 	    (*info->print_address_func) ((bfd_vma) value & 0xffffffff, info);
-	  else if ((operand->flags & PPC_OPERAND_FSL) != 0) 
+	  else if ((operand->flags & PPC_OPERAND_FSL) != 0)
 	    (*info->fprintf_func) (info->stream, "fsl%ld", value);
 	  else if ((operand->flags & PPC_OPERAND_FCR) != 0)
 	    (*info->fprintf_func) (info->stream, "fcr%ld", value);
--- a/opcodes/ppc-opc.c
+++ b/opcodes/ppc-opc.c
@@ -797,12 +797,12 @@ const struct powerpc_operand powerpc_operands[] =
 #define FCRT_MASK (0x1f << 21)
   { 0x1f, 21, 0, 0, PPC_OPERAND_FCR },
 
-  /* Xilinx FSL related masks and macros */  
+  /* Xilinx FSL related masks and macros */
 #define FSL FCRT + 1
 #define FSL_MASK (0x1f << 11)
-  { 0x1f, 11, 0, 0, PPC_OPERAND_FSL },  
+  { 0x1f, 11, 0, 0, PPC_OPERAND_FSL },
 
-  /* Xilinx UDI related masks and macros */  
+  /* Xilinx UDI related masks and macros */
 #define URT FSL + 1
   { 0x1f, 21, 0, 0, PPC_OPERAND_UDI },
 
@@ -904,7 +904,7 @@ static long
 extract_arx (unsigned long insn,
 	     ppc_cpu_t dialect ATTRIBUTE_UNUSED,
 	     int *invalid ATTRIBUTE_UNUSED)
-{ 
+{
   return (insn & 0xf) + 8;
 }
 
@@ -1149,11 +1149,11 @@ valid_bo_pre_v2 (long value)
 {
   /* Certain encodings have bits that are required to be zero.
      These are (z must be zero, y may be anything):
-	 0000y 
-	 0001y 
+	 0000y
+	 0001y
 	 001zy
-	 0100y 
-	 0101y 
+	 0100y
+	 0101y
 	 011zy
 	 1z00y
 	 1z01y
@@ -2329,7 +2329,7 @@ extract_vleil (unsigned long insn,
 #define SCI8BF_MASK SCI8BF(0x3f, 7, 0x1f)
 
 /* An SD4 form instruction.  This is a 16-bit instruction.  */
-#define SD4(op) ((((unsigned long)(op)) & 0xf) << 12) 
+#define SD4(op) ((((unsigned long)(op)) & 0xf) << 12)
 #define SD4_MASK SD4(0xf)
 
 /* An SE_IM5 form instruction.  This is a 16-bit instruction.  */
@@ -2777,7 +2777,7 @@ extract_vleil (unsigned long insn,
 #define PPCRFMCI	PPC_OPCODE_RFMCI
 #define E500MC  PPC_OPCODE_E500MC
 #define PPCA2	PPC_OPCODE_A2
-#define TITAN   PPC_OPCODE_TITAN  
+#define TITAN   PPC_OPCODE_TITAN
 #define MULHW   PPC_OPCODE_405 | PPC_OPCODE_440 | TITAN | PPC_OPCODE_VLE
 #define E500	PPC_OPCODE_E500
 #define E6500	PPC_OPCODE_E6500
@@ -3301,7 +3301,7 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 {"vandc",	VX (4,1092),	VX_MASK,     PPCVEC|PPCVLE, PPCNONE,	{VD, VA, VB}},
 {"vcmpequh.",	VXR(4,	70,1),	VXR_MASK,    PPCVEC|PPCVLE, PPCNONE,	{VD, VA, VB}},
 {"udi1fcm.",	APU(4, 547,0), APU_MASK, PPC405|PPC440, PPC476,		{URT, URA, URB}},
-{"udi1fcm",	APU(4, 547,1), APU_MASK, PPC405|PPC440, PPC476,		{URT, URA, URB}},   
+{"udi1fcm",	APU(4, 547,1), APU_MASK, PPC405|PPC440, PPC476,		{URT, URA, URB}},
 {"evmwhssf",	VX (4,1095),	VX_MASK,     PPCSPE|PPCVLE, PPCNONE,	{RS, RA, RB}},
 {"vpmsumh",	VX (4,1096),	VX_MASK,     PPCVEC2,	    PPCNONE,	{VD, VA, VB}},
 {"evmwlumi",	VX (4,1096),	VX_MASK,     PPCSPE|PPCVLE, PPCNONE,	{RS, RA, RB}},
@@ -3338,7 +3338,7 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 {"vpmsumw",	VX (4,1160),	VX_MASK,     PPCVEC2,	    PPCNONE,	{VD, VA, VB}},
 {"vcmpequw.",	VXR(4, 134,1),	VXR_MASK,    PPCVEC|PPCVLE, PPCNONE,	{VD, VA, VB}},
 {"udi2fcm.",	APU(4, 579,0), APU_MASK, PPC405|PPC440, PPC476,		{URT, URA, URB}},
-{"udi2fcm",	APU(4, 579,1), APU_MASK, PPC405|PPC440, PPC476,		{URT, URA, URB}},   
+{"udi2fcm",	APU(4, 579,1), APU_MASK, PPC405|PPC440, PPC476,		{URT, URA, URB}},
 {"machhwsuo",	XO (4,	76,1,0),XO_MASK,     MULHW|PPCVLE, PPCNONE,	{RT, RA, RB}},
 {"machhwsuo.",	XO (4,	76,1,1),XO_MASK,     MULHW|PPCVLE, PPCNONE,	{RT, RA, RB}},
 {"ps_merge10",	XOPS(4,592,0),	XOPS_MASK,   PPCPS,	PPCNONE,	{FRT, FRA, FRB}},
@@ -3354,7 +3354,7 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 {"vcmpeqfp.",	VXR(4, 198,1),	VXR_MASK,    PPCVEC|PPCVLE, PPCNONE,	{VD, VA, VB}},
 {"udi3fcm.",	APU(4, 611,0), APU_MASK, PPC405|PPC440, PPC476,		{URT, URA, URB}},
 {"vcmpequd.",	VXR(4, 199,1),	VXR_MASK,    PPCVEC2,	PPCNONE,	{VD, VA, VB}},
-{"udi3fcm",	APU(4, 611,1), APU_MASK, PPC405|PPC440, PPC476,		{URT, URA, URB}},   
+{"udi3fcm",	APU(4, 611,1), APU_MASK, PPC405|PPC440, PPC476,		{URT, URA, URB}},
 {"evdivwu",	VX (4,1223),	VX_MASK,     PPCSPE|PPCVLE, PPCNONE,	{RS, RA, RB}},
 {"vpmsumd",	VX (4,1224),	VX_MASK,     PPCVEC2,	    PPCNONE,	{VD, VA, VB}},
 {"evaddumiaaw",	VX (4,1224),	VX_MASK,     PPCSPE|PPCVLE, PPCNONE,	{RS, RA}},
@@ -4404,10 +4404,10 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 {"subfc.",	XO(31,8,0,1),	XO_MASK,     PPCCOM|PPCVLE, PPCNONE,	{RT, RA, RB}},
 {"sf.",		XO(31,8,0,1),	XO_MASK,     PWRCOM,	PPCNONE,	{RT, RA, RB}},
 {"subc.",	XO(31,8,0,1),	XO_MASK,     PPCCOM|PPCVLE, PPCNONE,	{RT, RB, RA}},
- 
+
 {"mulhdu",	XO(31,9,0,0),	XO_MASK,     PPC64|PPCVLE, PPCNONE,	{RT, RA, RB}},
 {"mulhdu.",	XO(31,9,0,1),	XO_MASK,     PPC64|PPCVLE, PPCNONE,	{RT, RA, RB}},
- 
+
 {"addc",	XO(31,10,0,0),	XO_MASK,     PPCCOM|PPCVLE, PPCNONE,	{RT, RA, RB}},
 {"a",		XO(31,10,0,0),	XO_MASK,     PWRCOM,	PPCNONE,	{RT, RA, RB}},
 {"addc.",	XO(31,10,0,1),	XO_MASK,     PPCCOM|PPCVLE, PPCNONE,	{RT, RA, RB}},
@@ -4430,11 +4430,11 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 {"mfocrf",	XFXM(31,19,0,1), XFXFXM_MASK, COM|PPCVLE, PPCNONE,	{RT, FXM}},
 
 {"lwarx",	X(31,20),	XEH_MASK,    PPC|PPCVLE, PPCNONE,	{RT, RA0, RB, EH}},
- 
+
 {"ldx",		X(31,21),	X_MASK,	     PPC64|PPCVLE, PPCNONE,	{RT, RA0, RB}},
- 
+
 {"icbt",	X(31,22),	X_MASK,	     BOOKE|PPCE300|PPCA2|PPC476|PPCVLE, PPCNONE, {CT, RA0, RB}},
- 
+
 {"lwzx",	X(31,23),	X_MASK,	     PPCCOM|PPCVLE, PPCNONE,	{RT, RA0, RB}},
 {"lx",		X(31,23),	X_MASK,      PWRCOM,	PPCNONE,	{RT, RA, RB}},
 
@@ -4499,9 +4499,9 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 {"lbarx",	X(31,52),	XEH_MASK,    POWER8|PPCVLE, PPCNONE,	{RT, RA0, RB, EH}},
 
 {"ldux",	X(31,53),	X_MASK,      PPC64|PPCVLE, PPCNONE,	{RT, RAL, RB}},
- 
+
 {"dcbst",	X(31,54),	XRT_MASK,    PPC|PPCVLE, PPCNONE,	{RA0, RB}},
- 
+
 {"lwzux",	X(31,55),	X_MASK,	     PPCCOM|PPCVLE, PPCNONE,	{RT, RAL, RB}},
 {"lux",		X(31,55),	X_MASK,      PWRCOM,	PPCNONE,	{RT, RA, RB}},
 
@@ -4514,7 +4514,7 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 {"waitrsv",	X(31,62)|(1<<21), 0xffffffff, E500MC|PPCA2, PPCNONE,	{0}},
 {"waitimpl",	X(31,62)|(2<<21), 0xffffffff, E500MC|PPCA2, PPCNONE,	{0}},
 {"wait",	X(31,62),	XWC_MASK,    E500MC|PPCA2|PPCVLE, PPCNONE, {WC}},
- 
+
 {"dcbstep",	XRT(31,63,0),	XRT_MASK,    E500MC|PPCA2|PPCVLE, PPCNONE, {RA0, RB}},
 
 {"tdlgt",	XTO(31,68,TOLGT), XTO_MASK,  PPC64,	PPCNONE,	{RA, RB}},
@@ -4537,7 +4537,7 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 {"lwfcmx",	APU(31,71,0), 	APU_MASK,    PPC405,	PPCNONE,	{FCRT, RA, RB}},
 {"mulhd",	XO(31,73,0,0),	XO_MASK,     PPC64|PPCVLE, PPCNONE,	{RT, RA, RB}},
 {"mulhd.",	XO(31,73,0,1),	XO_MASK,     PPC64|PPCVLE, PPCNONE,	{RT, RA, RB}},
- 
+
 {"mulhw",	XO(31,75,0,0),	XO_MASK,     PPC|PPCVLE, PPCNONE,	{RT, RA, RB}},
 {"mulhw.",	XO(31,75,0,1),	XO_MASK,     PPC|PPCVLE, PPCNONE,	{RT, RA, RB}},
 
@@ -4547,14 +4547,14 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 {"mtsrd",	X(31,82),  XRB_MASK|(1<<20), PPC64,	PPCNONE,	{SR, RS}},
 
 {"mfmsr",	X(31,83),	XRARB_MASK,  COM|PPCVLE, PPCNONE,	{RT}},
- 
+
 {"ldarx",	X(31,84),	XEH_MASK,    PPC64|PPCVLE, PPCNONE,	{RT, RA0, RB, EH}},
 
 {"dcbfl",	XOPL(31,86,1),	XRT_MASK,    POWER5,	PPC476,		{RA0, RB}},
 {"dcbf",	X(31,86),	XLRT_MASK,   PPC|PPCVLE, PPCNONE,	{RA0, RB, L}},
 
 {"lbzx",	X(31,87),	X_MASK,	     COM|PPCVLE, PPCNONE,	{RT, RA0, RB}},
- 
+
 {"lbepx",	X(31,95),	X_MASK,	     E500MC|PPCA2|PPCVLE, PPCNONE, {RT, RA0, RB}},
 
 {"dni",		XRC(31,97,1),	XRB_MASK,    E6500,	PPCNONE,	{DUI, DCTL}},
@@ -4581,7 +4581,7 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 {"clf",		X(31,118),	XTO_MASK,    POWER,	PPCNONE,	{RA, RB}},
 
 {"lbzux",	X(31,119),	X_MASK,	     COM|PPCVLE, PPCNONE,	{RT, RAL, RB}},
- 
+
 {"popcntb",	X(31,122),	XRB_MASK,    POWER5|PPCVLE, PPCNONE,	{RA, RS}},
 
 {"not",		XRC(31,124,0),	X_MASK,      COM,	PPCNONE,	{RA, RS, RBS}},
@@ -4590,9 +4590,9 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 {"nor.",	XRC(31,124,1),	X_MASK,      COM|PPCVLE, PPCNONE,	{RA, RS, RB}},
 
 {"dcbfep",	XRT(31,127,0),	XRT_MASK,    E500MC|PPCA2|PPCVLE, PPCNONE, {RA0, RB}},
- 
+
 {"wrtee",	X(31,131),	XRARB_MASK,  PPC403|BOOKE|PPCA2|PPC476|PPCVLE, PPCNONE, {RS}},
- 
+
 {"dcbtstls",	X(31,134),	X_MASK,	     PPCCHLK|PPC476|TITAN|PPCVLE, PPCNONE, {CT, RA0, RB}},
 
 {"stvebx",	X(31,135),	X_MASK,      PPCVEC,	PPCNONE,	{VS, RA0, RB}},
@@ -4625,9 +4625,9 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 {"eratsx.",	XRC(31,147,1),	X_MASK,	     PPCA2,	PPCNONE,	{RT, RA0, RB}},
 
 {"stdx",	X(31,149),	X_MASK,      PPC64|PPCVLE, PPCNONE,	{RS, RA0, RB}},
- 
+
 {"stwcx.",	XRC(31,150,1),	X_MASK,	     PPC|PPCVLE, PPCNONE,	{RS, RA0, RB}},
- 
+
 {"stwx",	X(31,151),	X_MASK,      PPCCOM|PPCVLE, PPCNONE,	{RS, RA0, RB}},
 {"stx",		X(31,151),	X_MASK,      PWRCOM,	PPCNONE,	{RS, RA, RB}},
 
@@ -4640,11 +4640,11 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 {"prtyw",	X(31,154),	XRB_MASK, POWER6|PPCA2|PPC476, PPCNONE,	{RA, RS}},
 
 {"stdepx",	X(31,157),	X_MASK,	     E500MC|PPCA2|PPCVLE, PPCNONE, {RS, RA0, RB}},
- 
+
 {"stwepx",	X(31,159),	X_MASK,	     E500MC|PPCA2|PPCVLE, PPCNONE, {RS, RA0, RB}},
- 
+
 {"wrteei",	X(31,163),	XE_MASK,     PPC403|BOOKE|PPCA2|PPC476|PPCVLE, PPCNONE, {E}},
- 
+
 {"dcbtls",	X(31,166),	X_MASK,	     PPCCHLK|PPC476|TITAN|PPCVLE, PPCNONE, {CT, RA0, RB}},
 
 {"stvehx",	X(31,167),	X_MASK,      PPCVEC,	PPCNONE,	{VS, RA0, RB}},
@@ -4700,7 +4700,7 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 {"ldawx.",	XRC(31,212,1),	X_MASK,	     PPCA2,	PPCNONE,	{RT, RA0, RB}},
 
 {"stdcx.",	XRC(31,214,1),	X_MASK,      PPC64|PPCVLE, PPCNONE,	{RS, RA0, RB}},
- 
+
 {"stbx",	X(31,215),	X_MASK,	     COM|PPCVLE, PPCNONE,	{RS, RA0, RB}},
 
 {"sllq",	XRC(31,216,0),	X_MASK,      M601,	PPCNONE,	{RA, RS, RB}},
@@ -4710,7 +4710,7 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 {"sleq.",	XRC(31,217,1),	X_MASK,      M601,	PPCNONE,	{RA, RS, RB}},
 
 {"stbepx",	X(31,223),	X_MASK,      E500MC|PPCA2|PPCVLE, PPCNONE, {RS, RA0, RB}},
- 
+
 {"icblc",	X(31,230),	X_MASK,	PPCCHLK|PPC476|TITAN|PPCVLE, PPCNONE, {CT, RA0, RB}},
 
 {"stvx",	X(31,231),	X_MASK,      PPCVEC|PPCVLE, PPCNONE,	{VS, RA0, RB}},
@@ -4723,7 +4723,7 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 
 {"mulld",	XO(31,233,0,0),	XO_MASK,     PPC64|PPCVLE, PPCNONE,	{RT, RA, RB}},
 {"mulld.",	XO(31,233,0,1),	XO_MASK,     PPC64|PPCVLE, PPCNONE,	{RT, RA, RB}},
- 
+
 {"addme",	XO(31,234,0,0),	XORB_MASK,   PPCCOM|PPCVLE, PPCNONE,	{RT, RA}},
 {"ame",		XO(31,234,0,0),	XORB_MASK,   PWRCOM,	PPCNONE,	{RT, RA}},
 {"addme.",	XO(31,234,0,1),	XORB_MASK,   PPCCOM|PPCVLE, PPCNONE,	{RT, RA}},
@@ -5070,7 +5070,7 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 {"mfthrm3",	XSPR(31,339,1022), XSPR_MASK, PPC750,	PPCNONE,	{RT}},
 {"mfpbu2",	XSPR(31,339,1023), XSPR_MASK, PPC403,	PPCNONE,	{RT}},
 {"mfspr",	X(31,339),	X_MASK,      COM|PPCVLE, PPCNONE,	{RT, SPR}},
- 
+
 {"lwax",	X(31,341),	X_MASK,      PPC64|PPCVLE, PPCNONE,	{RT, RA0, RB}},
 
 {"dst",		XDSS(31,342,0),	XDSS_MASK,   PPCVEC,	PPCNONE,	{RA, RB, STRM}},
@@ -5202,7 +5202,7 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 
 {"dccci",	X(31,454), XRT_MASK, PPC403|PPC440|TITAN|PPCA2, PPCNONE, {RAOPT, RBOPT}},
 {"dci",		X(31,454),	XRARB_MASK, PPCA2|PPC476|PPCVLE, PPCNONE, {CT}},
- 
+
 {"divdu",	XO(31,457,0,0),	XO_MASK,  PPC64|PPCVLE, PPCNONE,	{RT, RA, RB}},
 {"divdu.",	XO(31,457,0,1),	XO_MASK,  PPC64|PPCVLE, PPCNONE,	{RT, RA, RB}},
 
@@ -5375,7 +5375,7 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 {"mtthrm3",	XSPR(31,467,1022), XSPR_MASK, PPC750,	PPCNONE,	{RS}},
 {"mtpbu2",	XSPR(31,467,1023), XSPR_MASK, PPC403,	PPCNONE,	{RS}},
 {"mtspr",	X(31,467),	X_MASK,      COM|PPCVLE, PPCNONE,	{SPR, RS}},
- 
+
 {"dcbi",	X(31,470),	XRT_MASK,    PPC|PPCVLE, PPCNONE,	{RA0, RB}},
 
 {"nand",	XRC(31,476,0),	X_MASK,      COM|PPCVLE, PPCNONE,	{RA, RS, RB}},
@@ -5424,7 +5424,7 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 {"subfco.",	XO(31,8,1,1),	XO_MASK,     PPCCOM|PPCVLE, PPCNONE,	{RT, RA, RB}},
 {"sfo.",	XO(31,8,1,1),	XO_MASK,     PWRCOM,	PPCNONE,	{RT, RA, RB}},
 {"subco.",	XO(31,8,1,1),	XO_MASK,     PPCCOM|PPCVLE, PPCNONE,	{RT, RB, RA}},
- 
+
 {"addco",	XO(31,10,1,0),	XO_MASK,     PPCCOM|PPCVLE, PPCNONE,	{RT, RA, RB}},
 {"ao",		XO(31,10,1,0),	XO_MASK,     PWRCOM,	PPCNONE,	{RT, RA, RB}},
 {"addco.",	XO(31,10,1,1),	XO_MASK,     PPCCOM|PPCVLE, PPCNONE,	{RT, RA, RB}},
@@ -5818,10 +5818,10 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 
 {"iccci",	X(31,966), XRT_MASK, PPC403|PPC440|TITAN|PPCA2, PPCNONE, {RAOPT, RBOPT}},
 {"ici",		X(31,966),	XRARB_MASK,  PPCA2|PPC476|PPCVLE, PPCNONE, {CT}},
- 
+
 {"divduo",	XO(31,457,1,0),	XO_MASK,     PPC64|PPCVLE, PPCNONE,	{RT, RA, RB}},
 {"divduo.",	XO(31,457,1,1),	XO_MASK,     PPC64|PPCVLE, PPCNONE,	{RT, RA, RB}},
- 
+
 {"divwuo",	XO(31,459,1,0),	XO_MASK,     PPC|PPCVLE, PPCNONE,	{RT, RA, RB}},
 {"divwuo.",	XO(31,459,1,1),	XO_MASK,     PPC|PPCVLE, PPCNONE,	{RT, RA, RB}},
 
@@ -5855,7 +5855,7 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 
 {"divdo",	XO(31,489,1,0),	XO_MASK,  PPC64|PPCVLE, PPCNONE,	{RT, RA, RB}},
 {"divdo.",	XO(31,489,1,1),	XO_MASK,  PPC64|PPCVLE, PPCNONE,	{RT, RA, RB}},
- 
+
 {"divwo",	XO(31,491,1,0),	XO_MASK,   PPC|PPCVLE,	PPCNONE,	{RT, RA, RB}},
 {"divwo.",	XO(31,491,1,1),	XO_MASK,   PPC|PPCVLE,	PPCNONE,	{RT, RA, RB}},
 
@@ -6027,8 +6027,8 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 {"dctfix",	XRC(59,290,0),	X_MASK,      POWER6,	PPCNONE,	{FRT, FRB}},
 {"dctfix.",	XRC(59,290,1),	X_MASK,      POWER6,	PPCNONE,	{FRT, FRB}},
 
-{"ddedpd",	XRC(59,322,0),	X_MASK,      POWER6,	PPCNONE,	{SP, FRT, FRB}}, 
-{"ddedpd.",	XRC(59,322,1),	X_MASK,      POWER6,	PPCNONE,	{SP, FRT, FRB}}, 
+{"ddedpd",	XRC(59,322,0),	X_MASK,      POWER6,	PPCNONE,	{SP, FRT, FRB}},
+{"ddedpd.",	XRC(59,322,1),	X_MASK,      POWER6,	PPCNONE,	{SP, FRT, FRB}},
 
 {"dxex",	XRC(59,354,0),	X_MASK,      POWER6,	PPCNONE,	{FRT, FRB}},
 {"dxex.",	XRC(59,354,1),	X_MASK,      POWER6,	PPCNONE,	{FRT, FRB}},
@@ -6501,7 +6501,7 @@ const struct powerpc_opcode vle_opcodes[] = {
 {"se_cmpl",	SE_RR(3,1),	SE_RR_MASK,	PPCVLE,	PPCNONE,	{RX, RY}},
 {"se_cmph",	SE_RR(3,2),	SE_RR_MASK,	PPCVLE,	PPCNONE,	{RX, RY}},
 {"se_cmphl",	SE_RR(3,3),	SE_RR_MASK,	PPCVLE,	PPCNONE,	{RX, RY}},
- 
+
 {"e_cmpi",	SCI8BF(6,0,21),	SCI8BF_MASK,	PPCVLE,	PPCNONE,	{CRD32, RA, SCLSCI8}},
 {"e_cmpli",	SCI8BF(6,1,21),	SCI8BF_MASK,	PPCVLE,	PPCNONE,	{CRD32, RA, SCLSCI8}},
 {"e_addi",	SCI8(6,16),	SCI8_MASK,	PPCVLE,	PPCNONE,	{RT, RA, SCLSCI8}},
@@ -6541,7 +6541,7 @@ const struct powerpc_opcode vle_opcodes[] = {
 {"se_cmpi",	SE_IM5(10,1),	SE_IM5_MASK,	PPCVLE,	PPCNONE,	{RX, UI5}},
 {"se_bmaski",	SE_IM5(11,0),	SE_IM5_MASK,	PPCVLE,	PPCNONE,	{RX, UI5}},
 {"se_andi",	SE_IM5(11,1),	SE_IM5_MASK,	PPCVLE,	PPCNONE,	{RX, UI5}},
- 
+
 {"e_lbz",	OP(12),		OP_MASK,	PPCVLE,	PPCNONE,	{RT, D, RA0}},
 {"e_stb",	OP(13),		OP_MASK,	PPCVLE,	PPCNONE,	{RT, D, RA0}},
 {"e_lha",	OP(14),		OP_MASK,	PPCVLE,	PPCNONE,	{RT, D, RA0}},
@@ -6555,7 +6555,7 @@ const struct powerpc_opcode vle_opcodes[] = {
 {"se_and",	SE_RR(17,2),	SE_RR_MASK,	PPCVLE,	PPCNONE,	{RX, RY}},
 {"se_and.",	SE_RR(17,3),	SE_RR_MASK,	PPCVLE,	PPCNONE,	{RX, RY}},
 {"se_li",	IM7(9),		IM7_MASK,	PPCVLE,	PPCNONE,	{RX, UI7}},
- 
+
 {"e_lwz",	OP(20),		OP_MASK,	PPCVLE,	PPCNONE,	{RT, D, RA0}},
 {"e_stw",	OP(21),		OP_MASK,	PPCVLE,	PPCNONE,	{RT, D, RA0}},
 {"e_lhz",	OP(22),		OP_MASK,	PPCVLE,	PPCNONE,	{RT, D, RA0}},
@@ -6625,7 +6625,7 @@ const struct powerpc_opcode vle_opcodes[] = {
 {"e_bfl",	EBD15(30,8,BO32F,1), EBD15_MASK, PPCVLE, PPCNONE,	{BI32,B15}},
 {"e_bt",	EBD15(30,8,BO32T,0), EBD15_MASK, PPCVLE, PPCNONE,	{BI32,B15}},
 {"e_btl",	EBD15(30,8,BO32T,1), EBD15_MASK, PPCVLE, PPCNONE,	{BI32,B15}},
- 
+
 {"e_cmph",	X(31,14),	X_MASK,		PPCVLE,	PPCNONE,	{CRD, RA, RB}},
 {"e_cmphl",	X(31,46),	X_MASK,		PPCVLE,	PPCNONE,	{CRD, RA, RB}},
 {"e_crandc",	XL(31,129),	XL_MASK,	PPCVLE,	PPCNONE,	{BT, BA, BB}},
@@ -6637,18 +6637,18 @@ const struct powerpc_opcode vle_opcodes[] = {
 {"e_mcrf",	XL(31,16),	XL_MASK,	PPCVLE,	PPCNONE,	{CRD, CR}},
 {"e_slwi",	EX(31,112),	EX_MASK,	PPCVLE,	PPCNONE,	{RA, RS, SH}},
 {"e_slwi.",	EX(31,113),	EX_MASK,	PPCVLE,	PPCNONE,	{RA, RS, SH}},
- 
+
 {"e_crand",	XL(31,257),	XL_MASK,	PPCVLE,	PPCNONE,	{BT, BA, BB}},
- 
+
 {"e_rlw",	EX(31,560),	EX_MASK,	PPCVLE,	PPCNONE,	{RA, RS, RB}},
 {"e_rlw.",	EX(31,561),	EX_MASK,	PPCVLE,	PPCNONE,	{RA, RS, RB}},
- 
+
 {"e_crset",	XL(31,289),	XL_MASK,	PPCVLE,	PPCNONE,	{BT, BAT, BBA}},
 {"e_creqv",	XL(31,289),	XL_MASK,	PPCVLE,	PPCNONE,	{BT, BA, BB}},
- 
+
 {"e_rlwi",	EX(31,624),	EX_MASK,	PPCVLE,	PPCNONE,	{RA, RS, SH}},
 {"e_rlwi.",	EX(31,625),	EX_MASK,	PPCVLE,	PPCNONE,	{RA, RS, SH}},
- 
+
 {"e_crorc",	XL(31,417),	XL_MASK,	PPCVLE,	PPCNONE,	{BT, BA, BB}},
 
 {"e_crmove",	XL(31,449),	XL_MASK,	PPCVLE,	PPCNONE,	{BT, BA, BBA}},
@@ -6658,19 +6658,19 @@ const struct powerpc_opcode vle_opcodes[] = {
 
 {"e_srwi",	EX(31,1136),	EX_MASK,	PPCVLE,	PPCNONE,	{RA, RS, SH}},
 {"e_srwi.",	EX(31,1137),	EX_MASK,	PPCVLE,	PPCNONE,	{RA, RS, SH}},
- 
+
 {"se_lbz",	SD4(8),		SD4_MASK,	PPCVLE,	PPCNONE,	{RZ, SE_SD, RX}},
- 
+
 {"se_stb",	SD4(9),		SD4_MASK,	PPCVLE,	PPCNONE,	{RZ, SE_SD, RX}},
- 
+
 {"se_lhz",	SD4(10),	SD4_MASK,	PPCVLE,	PPCNONE,	{RZ, SE_SDH, RX}},
- 
+
 {"se_sth",	SD4(11),	SD4_MASK,	PPCVLE,	PPCNONE,	{RZ, SE_SDH, RX}},
- 
+
 {"se_lwz",	SD4(12),	SD4_MASK,	PPCVLE,	PPCNONE,	{RZ, SE_SDW, RX}},
- 
+
 {"se_stw",	SD4(13),	SD4_MASK,	PPCVLE,	PPCNONE,	{RZ, SE_SDW, RX}},
- 
+
 {"se_bge",	EBD8IO(28,0,0),	EBD8IO3_MASK,	PPCVLE,	PPCNONE,	{B8}},
 {"se_bnl",	EBD8IO(28,0,0),	EBD8IO3_MASK,	PPCVLE,	PPCNONE,	{B8}},
 {"se_ble",	EBD8IO(28,0,1),	EBD8IO3_MASK,	PPCVLE,	PPCNONE,	{B8}},
#--- a/opcodes/rl78-decode.c
#+++ b/opcodes/rl78-decode.c
#@@ -203,9 +203,9 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("nop");
# #line 912 "rl78-decode.opc"
#           ID(nop);
#-        
#+
#         /*----------------------------------------------------------------------*/
#-        
#+
#         }
#       break;
#     case 0x01:
#@@ -226,7 +226,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("addw	%0, %1");
# #line 274 "rl78-decode.opc"
#           ID(add); W(); DR(AX); SRW(rw); Fzac;
#-        
#+
#         }
#       break;
#     case 0x02:
#@@ -241,7 +241,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("addw	%0, %e!1");
# #line 265 "rl78-decode.opc"
#           ID(add); W(); DR(AX); SM(None, IMMU(2)); Fzac;
#-        
#+
#         }
#       break;
#     case 0x04:
#@@ -256,7 +256,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("addw	%0, #%1");
# #line 271 "rl78-decode.opc"
#           ID(add); W(); DR(AX); SC(IMMU(2)); Fzac;
#-        
#+
#         }
#       break;
#     case 0x06:
#@@ -271,7 +271,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("addw	%0, %1");
# #line 277 "rl78-decode.opc"
#           ID(add); W(); DR(AX); SM(None, SADDR); Fzac;
#-        
#+
#         }
#       break;
#     case 0x08:
#@@ -286,9 +286,9 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("xch	a, x");
# #line 1235 "rl78-decode.opc"
#           ID(xch); DR(A); SR(X);
#-        
#+
#         /*----------------------------------------------------------------------*/
#-        
#+
#         }
#       break;
#     case 0x09:
#@@ -303,7 +303,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("mov	%0, %e1");
# #line 678 "rl78-decode.opc"
#           ID(mov); DR(A); SM(B, IMMU(2));
#-        
#+
#         }
#       break;
#     case 0x0a:
#@@ -318,9 +318,9 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("add	%0, #%1");
# #line 228 "rl78-decode.opc"
#           ID(add); DM(None, SADDR); SC(IMMU(1)); Fzac;
#-        
#+
#         /*----------------------------------------------------------------------*/
#-        
#+
#         }
#       break;
#     case 0x0b:
#@@ -335,7 +335,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("add	%0, %1");
# #line 222 "rl78-decode.opc"
#           ID(add); DR(A); SM(None, SADDR); Fzac;
#-        
#+
#         }
#       break;
#     case 0x0c:
#@@ -350,7 +350,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("add	%0, #%1");
# #line 216 "rl78-decode.opc"
#           ID(add); DR(A); SC(IMMU(1)); Fzac;
#-        
#+
#         }
#       break;
#     case 0x0d:
#@@ -365,7 +365,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("add	%0, %e1");
# #line 204 "rl78-decode.opc"
#           ID(add); DR(A); SM(HL, 0); Fzac;
#-        
#+
#         }
#       break;
#     case 0x0e:
#@@ -380,7 +380,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("add	%0, %ea1");
# #line 210 "rl78-decode.opc"
#           ID(add); DR(A); SM(HL, IMMU(1)); Fzac;
#-          
#+
#         }
#       break;
#     case 0x0f:
#@@ -395,7 +395,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("add	%0, %e!1");
# #line 201 "rl78-decode.opc"
#           ID(add); DR(A); SM(None, IMMU(2)); Fzac;
#-        
#+
#         }
#       break;
#     case 0x10:
#@@ -410,9 +410,9 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("addw	%0, #%1");
# #line 280 "rl78-decode.opc"
#           ID(add); W(); DR(SP); SC(IMMU(1)); Fzac;
#-        
#+
#         /*----------------------------------------------------------------------*/
#-        
#+
#         }
#       break;
#     case 0x11:
#@@ -430,9 +430,9 @@ rl78_decode_opcode (unsigned long pc AU,
#           op ++;
#           pc ++;
#           goto start_again;
#-        
#+
#         /*----------------------------------------------------------------------*/
#-        
#+
#         }
#       break;
#     case 0x12:
#@@ -452,7 +452,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("movw	%0, %1");
# #line 859 "rl78-decode.opc"
#           ID(mov); W(); DRW(ra); SR(AX);
#-        
#+
#         }
#       break;
#     case 0x13:
#@@ -472,7 +472,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("movw	%0, %1");
# #line 856 "rl78-decode.opc"
#           ID(mov); W(); DR(AX); SRW(ra);
#-        
#+
#         }
#       break;
#     case 0x18:
#@@ -486,8 +486,8 @@ rl78_decode_opcode (unsigned long pc AU,
#             }
#           SYNTAX("mov	%e0, %1");
# #line 729 "rl78-decode.opc"
#-          ID(mov); DM(B, IMMU(2)); SR(A);	
#-        
#+          ID(mov); DM(B, IMMU(2)); SR(A);
#+
#         }
#       break;
#     case 0x19:
#@@ -501,8 +501,8 @@ rl78_decode_opcode (unsigned long pc AU,
#             }
#           SYNTAX("mov	%e0, #%1");
# #line 726 "rl78-decode.opc"
#-          ID(mov); DM(B, IMMU(2)); SC(IMMU(1));	
#-        
#+          ID(mov); DM(B, IMMU(2)); SC(IMMU(1));
#+
#         }
#       break;
#     case 0x1a:
#@@ -517,9 +517,9 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("addc	%0, #%1");
# #line 260 "rl78-decode.opc"
#           ID(addc); DM(None, SADDR); SC(IMMU(1)); Fzac;
#-        
#+
#         /*----------------------------------------------------------------------*/
#-        
#+
#         }
#       break;
#     case 0x1b:
#@@ -534,7 +534,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("addc	%0, %1");
# #line 257 "rl78-decode.opc"
#           ID(addc); DR(A); SM(None, SADDR); Fzac;
#-        
#+
#         }
#       break;
#     case 0x1c:
#@@ -549,7 +549,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("addc	%0, #%1");
# #line 248 "rl78-decode.opc"
#           ID(addc); DR(A); SC(IMMU(1)); Fzac;
#-        
#+
#         }
#       break;
#     case 0x1d:
#@@ -564,7 +564,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("addc	%0, %e1");
# #line 236 "rl78-decode.opc"
#           ID(addc); DR(A); SM(HL, 0); Fzac;
#-        
#+
#         }
#       break;
#     case 0x1e:
#@@ -579,7 +579,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("addc	%0, %ea1");
# #line 245 "rl78-decode.opc"
#           ID(addc); DR(A); SM(HL, IMMU(1)); Fzac;
#-        
#+
#         }
#       break;
#     case 0x1f:
#@@ -594,7 +594,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("addc	%0, %e!1");
# #line 233 "rl78-decode.opc"
#           ID(addc); DR(A); SM(None, IMMU(2)); Fzac;
#-        
#+
#         }
#       break;
#     case 0x20:
#@@ -609,9 +609,9 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("subw	%0, #%1");
# #line 1199 "rl78-decode.opc"
#           ID(sub); W(); DR(SP); SC(IMMU(1)); Fzac;
#-        
#+
#         /*----------------------------------------------------------------------*/
#-        
#+
#         }
#       break;
#     case 0x21:
#@@ -632,7 +632,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("subw	%0, %1");
# #line 1193 "rl78-decode.opc"
#           ID(sub); W(); DR(AX); SRW(rw); Fzac;
#-        
#+
#         }
#       break;
#     case 0x22:
#@@ -647,7 +647,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("subw	%0, %e!1");
# #line 1184 "rl78-decode.opc"
#           ID(sub); W(); DR(AX); SM(None, IMMU(2)); Fzac;
#-        
#+
#         }
#       break;
#     case 0x24:
#@@ -662,7 +662,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("subw	%0, #%1");
# #line 1190 "rl78-decode.opc"
#           ID(sub); W(); DR(AX); SC(IMMU(2)); Fzac;
#-        
#+
#         }
#       break;
#     case 0x26:
#@@ -677,7 +677,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("subw	%0, %1");
# #line 1196 "rl78-decode.opc"
#           ID(sub); W(); DR(AX); SM(None, SADDR); Fzac;
#-        
#+
#         }
#       break;
#     case 0x28:
#@@ -692,7 +692,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("mov	%e0, %1");
# #line 741 "rl78-decode.opc"
#           ID(mov); DM(C, IMMU(2)); SR(A);
#-        
#+
#         }
#       break;
#     case 0x29:
#@@ -707,7 +707,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("mov	%0, %e1");
# #line 684 "rl78-decode.opc"
#           ID(mov); DR(A); SM(C, IMMU(2));
#-        
#+
#         }
#       break;
#     case 0x2a:
#@@ -722,9 +722,9 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("sub	%0, #%1");
# #line 1147 "rl78-decode.opc"
#           ID(sub); DM(None, SADDR); SC(IMMU(1)); Fzac;
#-        
#+
#         /*----------------------------------------------------------------------*/
#-        
#+
#         }
#       break;
#     case 0x2b:
#@@ -739,7 +739,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("sub	%0, %1");
# #line 1141 "rl78-decode.opc"
#           ID(sub); DR(A); SM(None, SADDR); Fzac;
#-        
#+
#         }
#       break;
#     case 0x2c:
#@@ -754,7 +754,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("sub	%0, #%1");
# #line 1135 "rl78-decode.opc"
#           ID(sub); DR(A); SC(IMMU(1)); Fzac;
#-        
#+
#         }
#       break;
#     case 0x2d:
#@@ -769,7 +769,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("sub	%0, %e1");
# #line 1123 "rl78-decode.opc"
#           ID(sub); DR(A); SM(HL, 0); Fzac;
#-        
#+
#         }
#       break;
#     case 0x2e:
#@@ -784,7 +784,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("sub	%0, %ea1");
# #line 1129 "rl78-decode.opc"
#           ID(sub); DR(A); SM(HL, IMMU(1)); Fzac;
#-        
#+
#         }
#       break;
#     case 0x2f:
#@@ -799,7 +799,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("sub	%0, %e!1");
# #line 1120 "rl78-decode.opc"
#           ID(sub); DR(A); SM(None, IMMU(2)); Fzac;
#-        
#+
#         }
#       break;
#     case 0x30:
#@@ -820,7 +820,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("movw	%0, #%1");
# #line 853 "rl78-decode.opc"
#           ID(mov); W(); DRW(rg); SC(IMMU(2));
#-        
#+
#         }
#       break;
#     case 0x31:
#@@ -842,9 +842,9 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("btclr	%s1, $%a0");
# #line 416 "rl78-decode.opc"
#                 ID(branch_cond_clear); SM(None, SADDR); SB(bit); DC(pc+IMMS(1)+4); COND(T);
#-              
#+
#               /*----------------------------------------------------------------------*/
#-              
#+
#               }
#             break;
#           case 0x01:
#@@ -862,7 +862,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("btclr	%1, $%a0");
# #line 410 "rl78-decode.opc"
#                 ID(branch_cond_clear); DC(pc+IMMS(1)+3); SR(A); SB(bit); COND(T);
#-              
#+
#               }
#             break;
#           case 0x02:
#@@ -880,9 +880,9 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("bt	%s1, $%a0");
# #line 402 "rl78-decode.opc"
#                 ID(branch_cond); SM(None, SADDR); SB(bit); DC(pc+IMMS(1)+4); COND(T);
#-              
#+
#               /*----------------------------------------------------------------------*/
#-              
#+
#               }
#             break;
#           case 0x03:
#@@ -900,7 +900,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("bt	%1, $%a0");
# #line 396 "rl78-decode.opc"
#                 ID(branch_cond); DC(pc+IMMS(1)+3); SR(A); SB(bit); COND(T);
#-              
#+
#               }
#             break;
#           case 0x04:
#@@ -918,9 +918,9 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("bf	%s1, $%a0");
# #line 363 "rl78-decode.opc"
#                 ID(branch_cond); SM(None, SADDR); SB(bit); DC(pc+IMMS(1)+4); COND(F);
#-              
#+
#               /*----------------------------------------------------------------------*/
#-              
#+
#               }
#             break;
#           case 0x05:
#@@ -938,7 +938,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("bf	%1, $%a0");
# #line 357 "rl78-decode.opc"
#                 ID(branch_cond); DC(pc+IMMS(1)+3); SR(A); SB(bit); COND(F);
#-              
#+
#               }
#             break;
#           case 0x07:
#@@ -956,7 +956,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("shl	%0, %1");
# #line 1076 "rl78-decode.opc"
#                 ID(shl); DR(C); SC(cnt);
#-              
#+
#               }
#             break;
#           case 0x08:
#@@ -974,7 +974,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("shl	%0, %1");
# #line 1073 "rl78-decode.opc"
#                 ID(shl); DR(B); SC(cnt);
#-              
#+
#               }
#             break;
#           case 0x09:
#@@ -992,7 +992,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("shl	%0, %1");
# #line 1070 "rl78-decode.opc"
#                 ID(shl); DR(A); SC(cnt);
#-              
#+
#               }
#             break;
#           case 0x0a:
#@@ -1010,7 +1010,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("shr	%0, %1");
# #line 1087 "rl78-decode.opc"
#                 ID(shr); DR(A); SC(cnt);
#-              
#+
#               }
#             break;
#           case 0x0b:
#@@ -1028,7 +1028,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("sar	%0, %1");
# #line 1034 "rl78-decode.opc"
#                 ID(sar); DR(A); SC(cnt);
#-              
#+
#               }
#             break;
#           case 0x0c:
#@@ -1047,9 +1047,9 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("shlw	%0, %1");
# #line 1082 "rl78-decode.opc"
#                 ID(shl); W(); DR(BC); SC(wcnt);
#-              
#+
#               /*----------------------------------------------------------------------*/
#-              
#+
#               }
#             break;
#           case 0x0d:
#@@ -1068,7 +1068,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("shlw	%0, %1");
# #line 1079 "rl78-decode.opc"
#                 ID(shl); W(); DR(AX); SC(wcnt);
#-              
#+
#               }
#             break;
#           case 0x0e:
#@@ -1087,9 +1087,9 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("shrw	%0, %1");
# #line 1090 "rl78-decode.opc"
#                 ID(shr); W(); DR(AX); SC(wcnt);
#-              
#+
#               /*----------------------------------------------------------------------*/
#-              
#+
#               }
#             break;
#           case 0x0f:
#@@ -1108,9 +1108,9 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("sarw	%0, %1");
# #line 1037 "rl78-decode.opc"
#                 ID(sar); W(); DR(AX); SC(wcnt);
#-              
#+
#               /*----------------------------------------------------------------------*/
#-              
#+
#               }
#             break;
#           case 0x80:
#@@ -1128,7 +1128,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("btclr	%s1, $%a0");
# #line 413 "rl78-decode.opc"
#                 ID(branch_cond_clear); SM(None, SFR); SB(bit); DC(pc+IMMS(1)+4); COND(T);
#-              
#+
#               }
#             break;
#           case 0x81:
#@@ -1146,7 +1146,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("btclr	%e1, $%a0");
# #line 407 "rl78-decode.opc"
#                 ID(branch_cond_clear); DC(pc+IMMS(1)+3); SM(HL,0); SB(bit); COND(T);
#-              
#+
#               }
#             break;
#           case 0x82:
#@@ -1164,7 +1164,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("bt	%s1, $%a0");
# #line 399 "rl78-decode.opc"
#                 ID(branch_cond); SM(None, SFR); SB(bit); DC(pc+IMMS(1)+4); COND(T);
#-              
#+
#               }
#             break;
#           case 0x83:
#@@ -1182,7 +1182,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("bt	%e1, $%a0");
# #line 393 "rl78-decode.opc"
#                 ID(branch_cond); DC(pc+IMMS(1)+3); SM(HL,0); SB(bit); COND(T);
#-              
#+
#               }
#             break;
#           case 0x84:
#@@ -1200,7 +1200,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("bf	%s1, $%a0");
# #line 360 "rl78-decode.opc"
#                 ID(branch_cond); SM(None, SFR); SB(bit); DC(pc+IMMS(1)+4); COND(F);
#-              
#+
#               }
#             break;
#           case 0x85:
#@@ -1218,7 +1218,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("bf	%e1, $%a0");
# #line 354 "rl78-decode.opc"
#                 ID(branch_cond); DC(pc+IMMS(1)+3); SM(HL,0); SB(bit); COND(F);
#-              
#+
#               }
#             break;
#           default: UNSUPPORTED(); break;
#@@ -1241,9 +1241,9 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("xchw	%0, %1");
# #line 1240 "rl78-decode.opc"
#           ID(xch); W(); DR(AX); SRW(ra);
#-        
#+
#         /*----------------------------------------------------------------------*/
#-        
#+
#         }
#       break;
#     case 0x38:
#@@ -1257,8 +1257,8 @@ rl78_decode_opcode (unsigned long pc AU,
#             }
#           SYNTAX("mov	%e0, #%1");
# #line 738 "rl78-decode.opc"
#-          ID(mov); DM(C, IMMU(2)); SC(IMMU(1));	
#-        
#+          ID(mov); DM(C, IMMU(2)); SC(IMMU(1));
#+
#         }
#       break;
#     case 0x39:
#@@ -1272,8 +1272,8 @@ rl78_decode_opcode (unsigned long pc AU,
#             }
#           SYNTAX("mov	%e0, #%1");
# #line 732 "rl78-decode.opc"
#-          ID(mov); DM(BC, IMMU(2)); SC(IMMU(1));	
#-        
#+          ID(mov); DM(BC, IMMU(2)); SC(IMMU(1));
#+
#         }
#       break;
#     case 0x3a:
#@@ -1288,9 +1288,9 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("subc	%0, #%1");
# #line 1179 "rl78-decode.opc"
#           ID(subc); DM(None, SADDR); SC(IMMU(1)); Fzac;
#-        
#+
#         /*----------------------------------------------------------------------*/
#-        
#+
#         }
#       break;
#     case 0x3b:
#@@ -1305,7 +1305,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("subc	%0, %1");
# #line 1176 "rl78-decode.opc"
#           ID(subc); DR(A); SM(None, SADDR); Fzac;
#-        
#+
#         }
#       break;
#     case 0x3c:
#@@ -1320,7 +1320,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("subc	%0, #%1");
# #line 1167 "rl78-decode.opc"
#           ID(subc); DR(A); SC(IMMU(1)); Fzac;
#-        
#+
#         }
#       break;
#     case 0x3d:
#@@ -1335,7 +1335,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("subc	%0, %e1");
# #line 1155 "rl78-decode.opc"
#           ID(subc); DR(A); SM(HL, 0); Fzac;
#-        
#+
#         }
#       break;
#     case 0x3e:
#@@ -1350,7 +1350,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("subc	%0, %ea1");
# #line 1164 "rl78-decode.opc"
#           ID(subc); DR(A); SM(HL, IMMU(1)); Fzac;
#-        
#+
#         }
#       break;
#     case 0x3f:
#@@ -1365,7 +1365,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("subc	%0, %e!1");
# #line 1152 "rl78-decode.opc"
#           ID(subc); DR(A); SM(None, IMMU(2)); Fzac;
#-        
#+
#         }
#       break;
#     case 0x40:
#@@ -1380,7 +1380,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("cmp	%e!0, #%1");
# #line 480 "rl78-decode.opc"
#           ID(cmp); DM(None, IMMU(2)); SC(IMMU(1)); Fzac;
#-        
#+
#         }
#       break;
#     case 0x41:
#@@ -1394,8 +1394,8 @@ rl78_decode_opcode (unsigned long pc AU,
#             }
#           SYNTAX("mov	%0, #%1");
# #line 717 "rl78-decode.opc"
#-          ID(mov); DR(ES); SC(IMMU(1));	
#-        
#+          ID(mov); DR(ES); SC(IMMU(1));
#+
#         }
#       break;
#     case 0x42:
#@@ -1410,7 +1410,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("cmpw	%0, %e!1");
# #line 531 "rl78-decode.opc"
#           ID(cmp); W(); DR(AX); SM(None, IMMU(2)); Fzac;
#-        
#+
#         }
#       break;
#     case 0x43:
#@@ -1430,7 +1430,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("cmpw	%0, %1");
# #line 540 "rl78-decode.opc"
#           ID(cmp); W(); DR(AX); SRW(ra); Fzac;
#-        
#+
#         }
#       break;
#     case 0x44:
#@@ -1445,7 +1445,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("cmpw	%0, #%1");
# #line 537 "rl78-decode.opc"
#           ID(cmp); W(); DR(AX); SC(IMMU(2)); Fzac;
#-        
#+
#         }
#       break;
#     case 0x46:
#@@ -1460,9 +1460,9 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("cmpw	%0, %1");
# #line 543 "rl78-decode.opc"
#           ID(cmp); W(); DR(AX); SM(None, SADDR); Fzac;
#-        
#+
#         /*----------------------------------------------------------------------*/
#-        
#+
#         }
#       break;
#     case 0x48:
#@@ -1476,8 +1476,8 @@ rl78_decode_opcode (unsigned long pc AU,
#             }
#           SYNTAX("mov	%e0, %1");
# #line 735 "rl78-decode.opc"
#-          ID(mov); DM(BC, IMMU(2)); SR(A);	
#-        
#+          ID(mov); DM(BC, IMMU(2)); SR(A);
#+
#         }
#       break;
#     case 0x49:
#@@ -1492,7 +1492,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("mov	%0, %e1");
# #line 681 "rl78-decode.opc"
#           ID(mov); DR(A); SM(BC, IMMU(2));
#-        
#+
#         }
#       break;
#     case 0x4a:
#@@ -1507,7 +1507,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("cmp	%0, #%1");
# #line 483 "rl78-decode.opc"
#           ID(cmp); DM(None, SADDR); SC(IMMU(1)); Fzac;
#-        
#+
#         }
#       break;
#     case 0x4b:
#@@ -1522,9 +1522,9 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("cmp	%0, %1");
# #line 510 "rl78-decode.opc"
#           ID(cmp); DR(A); SM(None, SADDR); Fzac;
#-        
#+
#         /*----------------------------------------------------------------------*/
#-        
#+
#         }
#       break;
#     case 0x4c:
#@@ -1539,7 +1539,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("cmp	%0, #%1");
# #line 501 "rl78-decode.opc"
#           ID(cmp); DR(A); SC(IMMU(1)); Fzac;
#-        
#+
#         }
#       break;
#     case 0x4d:
#@@ -1554,7 +1554,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("cmp	%0, %e1");
# #line 489 "rl78-decode.opc"
#           ID(cmp); DR(A); SM(HL, 0); Fzac;
#-        
#+
#         }
#       break;
#     case 0x4e:
#@@ -1569,7 +1569,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("cmp	%0, %ea1");
# #line 498 "rl78-decode.opc"
#           ID(cmp); DR(A); SM(HL, IMMU(1)); Fzac;
#-        
#+
#         }
#       break;
#     case 0x4f:
#@@ -1584,7 +1584,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("cmp	%0, %e!1");
# #line 486 "rl78-decode.opc"
#           ID(cmp); DR(A); SM(None, IMMU(2)); Fzac;
#-        
#+
#         }
#       break;
#     case 0x50:
#@@ -1609,7 +1609,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("mov	%0, #%1");
# #line 669 "rl78-decode.opc"
#           ID(mov); DRB(reg); SC(IMMU(1));
#-        
#+
#         }
#       break;
#     case 0x58:
#@@ -1624,7 +1624,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("movw	%e0, %1");
# #line 871 "rl78-decode.opc"
#           ID(mov); W(); DM(B, IMMU(2)); SR(AX);
#-        
#+
#         }
#       break;
#     case 0x59:
#@@ -1639,7 +1639,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("movw	%0, %e1");
# #line 862 "rl78-decode.opc"
#           ID(mov); W(); DR(AX); SM(B, IMMU(2));
#-        
#+
#         }
#       break;
#     case 0x5a:
#@@ -1654,9 +1654,9 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("and	%0, #%1");
# #line 312 "rl78-decode.opc"
#           ID(and); DM(None, SADDR); SC(IMMU(1)); Fz;
#-        
#+
#         /*----------------------------------------------------------------------*/
#-        
#+
#         }
#       break;
#     case 0x5b:
#@@ -1671,7 +1671,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("and	%0, %1");
# #line 309 "rl78-decode.opc"
#           ID(and); DR(A); SM(None, SADDR); Fz;
#-        
#+
#         }
#       break;
#     case 0x5c:
#@@ -1686,7 +1686,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("and	%0, #%1");
# #line 300 "rl78-decode.opc"
#           ID(and); DR(A); SC(IMMU(1)); Fz;
#-        
#+
#         }
#       break;
#     case 0x5d:
#@@ -1701,7 +1701,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("and	%0, %e1");
# #line 288 "rl78-decode.opc"
#           ID(and); DR(A); SM(HL, 0); Fz;
#-        
#+
#         }
#       break;
#     case 0x5e:
#@@ -1716,7 +1716,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("and	%0, %ea1");
# #line 294 "rl78-decode.opc"
#           ID(and); DR(A); SM(HL, IMMU(1)); Fz;
#-        
#+
#         }
#       break;
#     case 0x5f:
#@@ -1731,7 +1731,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("and	%0, %e!1");
# #line 285 "rl78-decode.opc"
#           ID(and); DR(A); SM(None, IMMU(2)); Fz;
#-        
#+
#         }
#       break;
#     case 0x60:
#@@ -1755,7 +1755,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("mov	%0, %1");
# #line 672 "rl78-decode.opc"
#           ID(mov); DR(A); SRB(rba);
#-        
#+
#         }
#       break;
#     case 0x61:
#@@ -1784,7 +1784,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("add	%0, %1");
# #line 225 "rl78-decode.opc"
#                 ID(add); DRB(reg); SR(A); Fzac;
#-              
#+
#               }
#             break;
#           case 0x08:
#@@ -1808,7 +1808,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("add	%0, %1");
# #line 219 "rl78-decode.opc"
#                 ID(add); DR(A); SRB(rba); Fzac;
#-              
#+
#               }
#             break;
#           case 0x09:
#@@ -1823,7 +1823,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("addw	%0, %ea1");
# #line 268 "rl78-decode.opc"
#                 ID(add); W(); DR(AX); SM(HL, IMMU(1)); Fzac;
#-              
#+
#               }
#             break;
#           case 0x10:
#@@ -1848,7 +1848,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("addc	%0, %1");
# #line 254 "rl78-decode.opc"
#                 ID(addc); DRB(reg); SR(A); Fzac;
#-              
#+
#               }
#             break;
#           case 0x18:
#@@ -1872,7 +1872,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("addc	%0, %1");
# #line 251 "rl78-decode.opc"
#                 ID(addc); DR(A); SRB(rba); Fzac;
#-              
#+
#               }
#             break;
#           case 0x20:
#@@ -1897,7 +1897,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("sub	%0, %1");
# #line 1144 "rl78-decode.opc"
#                 ID(sub); DRB(reg); SR(A); Fzac;
#-              
#+
#               }
#             break;
#           case 0x28:
#@@ -1921,7 +1921,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("sub	%0, %1");
# #line 1138 "rl78-decode.opc"
#                 ID(sub); DR(A); SRB(rba); Fzac;
#-              
#+
#               }
#             break;
#           case 0x29:
#@@ -1936,7 +1936,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("subw	%0, %ea1");
# #line 1187 "rl78-decode.opc"
#                 ID(sub); W(); DR(AX); SM(HL, IMMU(1)); Fzac;
#-              
#+
#               }
#             break;
#           case 0x30:
#@@ -1961,7 +1961,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("subc	%0, %1");
# #line 1173 "rl78-decode.opc"
#                 ID(subc); DRB(reg); SR(A); Fzac;
#-              
#+
#               }
#             break;
#           case 0x38:
#@@ -1985,7 +1985,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("subc	%0, %1");
# #line 1170 "rl78-decode.opc"
#                 ID(subc); DR(A); SRB(rba); Fzac;
#-              
#+
#               }
#             break;
#           case 0x40:
#@@ -2010,7 +2010,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("cmp	%0, %1");
# #line 507 "rl78-decode.opc"
#                 ID(cmp); DRB(reg); SR(A); Fzac;
#-              
#+
#               }
#             break;
#           case 0x48:
#@@ -2034,7 +2034,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("cmp	%0, %1");
# #line 504 "rl78-decode.opc"
#                 ID(cmp); DR(A); SRB(rba); Fzac;
#-              
#+
#               }
#             break;
#           case 0x49:
#@@ -2049,7 +2049,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("cmpw	%0, %ea1");
# #line 534 "rl78-decode.opc"
#                 ID(cmp); W(); DR(AX); SM(HL, IMMU(1)); Fzac;
#-              
#+
#               }
#             break;
#           case 0x50:
#@@ -2074,7 +2074,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("and	%0, %1");
# #line 306 "rl78-decode.opc"
#                 ID(and); DRB(reg); SR(A); Fz;
#-              
#+
#               }
#             break;
#           case 0x58:
#@@ -2098,7 +2098,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("and	%0, %1");
# #line 303 "rl78-decode.opc"
#                 ID(and); DR(A); SRB(rba); Fz;
#-              
#+
#               }
#             break;
#           case 0x59:
#@@ -2113,7 +2113,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("inc	%ea0");
# #line 584 "rl78-decode.opc"
#                 ID(add); DM(HL, IMMU(1)); SC(1); Fza;
#-              
#+
#               }
#             break;
#           case 0x60:
#@@ -2138,7 +2138,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("or	%0, %1");
# #line 962 "rl78-decode.opc"
#                 ID(or); DRB(reg); SR(A); Fz;
#-              
#+
#               }
#             break;
#           case 0x68:
#@@ -2162,7 +2162,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("or	%0, %1");
# #line 959 "rl78-decode.opc"
#                 ID(or); DR(A); SRB(rba); Fz;
#-              
#+
#               }
#             break;
#           case 0x69:
#@@ -2177,7 +2177,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("dec	%ea0");
# #line 551 "rl78-decode.opc"
#                 ID(sub); DM(HL, IMMU(1)); SC(1); Fza;
#-              
#+
#               }
#             break;
#           case 0x70:
#@@ -2202,7 +2202,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("xor	%0, %1");
# #line 1266 "rl78-decode.opc"
#                 ID(xor); DRB(reg); SR(A); Fz;
#-              
#+
#               }
#             break;
#           case 0x78:
#@@ -2226,7 +2226,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("xor	%0, %1");
# #line 1263 "rl78-decode.opc"
#                 ID(xor); DR(A); SRB(rba); Fz;
#-              
#+
#               }
#             break;
#           case 0x79:
#@@ -2241,7 +2241,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("incw	%ea0");
# #line 598 "rl78-decode.opc"
#                 ID(add); W(); DM(HL, IMMU(1)); SC(1);
#-              
#+
#               }
#             break;
#           case 0x80:
#@@ -2257,7 +2257,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("add	%0, %e1");
# #line 207 "rl78-decode.opc"
#                 ID(add); DR(A); SM2(HL, B, 0); Fzac;
#-              
#+
#               }
#             break;
#           case 0x82:
#@@ -2272,7 +2272,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("add	%0, %e1");
# #line 213 "rl78-decode.opc"
#                 ID(add); DR(A); SM2(HL, C, 0); Fzac;
#-              
#+
#               }
#             break;
#           case 0x84:
#@@ -2324,9 +2324,9 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("callt	[%x0]");
# #line 433 "rl78-decode.opc"
#                 ID(call); DM(None, 0x80 + mm*16 + nnn*2);
#-              
#+
#               /*----------------------------------------------------------------------*/
#-              
#+
#               }
#             break;
#           case 0x88:
#@@ -2351,7 +2351,7 @@ rl78_decode_opcode (unsigned long pc AU,
# #line 1225 "rl78-decode.opc"
#                 /* Note: DECW uses reg == X, so this must follow DECW */
#                 ID(xch); DR(A); SRB(reg);
#-              
#+
#               }
#             break;
#           case 0x89:
#@@ -2366,7 +2366,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("decw	%ea0");
# #line 565 "rl78-decode.opc"
#                 ID(sub); W(); DM(HL, IMMU(1)); SC(1);
#-              
#+
#               }
#             break;
#           case 0x90:
#@@ -2381,7 +2381,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("addc	%0, %e1");
# #line 239 "rl78-decode.opc"
#                 ID(addc); DR(A); SM2(HL, B, 0); Fzac;
#-              
#+
#               }
#             break;
#           case 0x92:
#@@ -2396,7 +2396,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("addc	%0, %e1");
# #line 242 "rl78-decode.opc"
#                 ID(addc); DR(A); SM2(HL, C, 0); Fzac;
#-              
#+
#               }
#             break;
#           case 0xa0:
#@@ -2412,7 +2412,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("sub	%0, %e1");
# #line 1126 "rl78-decode.opc"
#                 ID(sub); DR(A); SM2(HL, B, 0); Fzac;
#-              
#+
#               }
#             break;
#           case 0xa2:
#@@ -2427,7 +2427,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("sub	%0, %e1");
# #line 1132 "rl78-decode.opc"
#                 ID(sub); DR(A); SM2(HL, C, 0); Fzac;
#-              
#+
#               }
#             break;
#           case 0xa8:
#@@ -2442,7 +2442,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("xch	%0, %1");
# #line 1229 "rl78-decode.opc"
#                 ID(xch); DR(A); SM(None, SADDR);
#-              
#+
#               }
#             break;
#           case 0xa9:
#@@ -2457,7 +2457,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("xch	%0, %e1");
# #line 1222 "rl78-decode.opc"
#                 ID(xch); DR(A); SM2(HL, C, 0);
#-              
#+
#               }
#             break;
#           case 0xaa:
#@@ -2472,7 +2472,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("xch	%0, %e!1");
# #line 1204 "rl78-decode.opc"
#                 ID(xch); DR(A); SM(None, IMMU(2));
#-              
#+
#               }
#             break;
#           case 0xab:
#@@ -2487,7 +2487,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("xch	%0, %1");
# #line 1232 "rl78-decode.opc"
#                 ID(xch); DR(A); SM(None, SFR);
#-              
#+
#               }
#             break;
#           case 0xac:
#@@ -2502,7 +2502,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("xch	%0, %e1");
# #line 1213 "rl78-decode.opc"
#                 ID(xch); DR(A); SM(HL, 0);
#-              
#+
#               }
#             break;
#           case 0xad:
#@@ -2517,7 +2517,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("xch	%0, %ea1");
# #line 1219 "rl78-decode.opc"
#                 ID(xch); DR(A); SM(HL, IMMU(1));
#-              
#+
#               }
#             break;
#           case 0xae:
#@@ -2532,7 +2532,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("xch	%0, %e1");
# #line 1207 "rl78-decode.opc"
#                 ID(xch); DR(A); SM(DE, 0);
#-              
#+
#               }
#             break;
#           case 0xaf:
#@@ -2547,7 +2547,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("xch	%0, %e1");
# #line 1210 "rl78-decode.opc"
#                 ID(xch); DR(A); SM(DE, IMMU(1));
#-              
#+
#               }
#             break;
#           case 0xb0:
#@@ -2562,7 +2562,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("subc	%0, %e1");
# #line 1158 "rl78-decode.opc"
#                 ID(subc); DR(A); SM2(HL, B, 0); Fzac;
#-              
#+
#               }
#             break;
#           case 0xb2:
#@@ -2577,7 +2577,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("subc	%0, %e1");
# #line 1161 "rl78-decode.opc"
#                 ID(subc); DR(A); SM2(HL, C, 0); Fzac;
#-              
#+
#               }
#             break;
#           case 0xb8:
#@@ -2591,8 +2591,8 @@ rl78_decode_opcode (unsigned long pc AU,
#                   }
#                 SYNTAX("mov	%0, %1");
# #line 723 "rl78-decode.opc"
#-                ID(mov); DR(ES); SM(None, SADDR);	
#-              
#+                ID(mov); DR(ES); SM(None, SADDR);
#+
#               }
#             break;
#           case 0xb9:
#@@ -2607,7 +2607,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("xch	%0, %e1");
# #line 1216 "rl78-decode.opc"
#                 ID(xch); DR(A); SM2(HL, B, 0);
#-              
#+
#               }
#             break;
#           case 0xc0:
#@@ -2622,7 +2622,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("cmp	%0, %e1");
# #line 492 "rl78-decode.opc"
#                 ID(cmp); DR(A); SM2(HL, B, 0); Fzac;
#-              
#+
#               }
#             break;
#           case 0xc2:
#@@ -2637,7 +2637,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("cmp	%0, %e1");
# #line 495 "rl78-decode.opc"
#                 ID(cmp); DR(A); SM2(HL, C, 0); Fzac;
#-              
#+
#               }
#             break;
#           case 0xc3:
#@@ -2652,7 +2652,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("bh	$%a0");
# #line 340 "rl78-decode.opc"
#                 ID(branch_cond); DC(pc+IMMS(1)+3); SR(None); COND(H);
#-              
#+
#               }
#             break;
#           case 0xc8:
#@@ -2667,7 +2667,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("sk%c1");
# #line 1095 "rl78-decode.opc"
#                 ID(skip); COND(C);
#-              
#+
#               }
#             break;
#           case 0xc9:
#@@ -2682,7 +2682,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("mov	%0, %e1");
# #line 660 "rl78-decode.opc"
#                 ID(mov); DR(A); SM2(HL, B, 0);
#-              
#+
#               }
#             break;
#           case 0xca:
#@@ -2703,7 +2703,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("call	%0");
# #line 430 "rl78-decode.opc"
#                 ID(call); DRW(rg);
#-              
#+
#               }
#             break;
#           case 0xcb:
#@@ -2718,9 +2718,9 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("br	ax");
# #line 380 "rl78-decode.opc"
#                 ID(branch); DR(AX);
#-              
#+
#               /*----------------------------------------------------------------------*/
#-              
#+
#               }
#             break;
#           case 0xcc:
#@@ -2735,9 +2735,9 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("brk");
# #line 388 "rl78-decode.opc"
#                 ID(break);
#-              
#+
#               /*----------------------------------------------------------------------*/
#-              
#+
#               }
#             break;
#           case 0xcd:
#@@ -2752,9 +2752,9 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("pop	%s0");
# #line 990 "rl78-decode.opc"
#                 ID(mov); W(); DR(PSW); SPOP();
#-              
#+
#               /*----------------------------------------------------------------------*/
#-              
#+
#               }
#             break;
#           case 0xce:
#@@ -2769,9 +2769,9 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("movs	%ea0, %1");
# #line 811 "rl78-decode.opc"
#                 ID(mov); DM(HL, IMMU(1)); SR(X); Fzc;
#-              
#+
#               /*----------------------------------------------------------------------*/
#-              
#+
#               }
#             break;
#           case 0xcf:
#@@ -2792,9 +2792,9 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("sel	rb%1");
# #line 1042 "rl78-decode.opc"
#                 ID(sel); SC(rb);
#-              
#+
#               /*----------------------------------------------------------------------*/
#-              
#+
#               }
#             break;
#           case 0xd0:
#@@ -2809,7 +2809,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("and	%0, %e1");
# #line 291 "rl78-decode.opc"
#                 ID(and); DR(A); SM2(HL, B, 0); Fz;
#-              
#+
#               }
#             break;
#           case 0xd2:
#@@ -2824,7 +2824,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("and	%0, %e1");
# #line 297 "rl78-decode.opc"
#                 ID(and); DR(A); SM2(HL, C, 0); Fz;
#-              
#+
#               }
#             break;
#           case 0xd3:
#@@ -2839,7 +2839,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("bnh	$%a0");
# #line 343 "rl78-decode.opc"
#                 ID(branch_cond); DC(pc+IMMS(1)+3); SR(None); COND(NH);
#-              
#+
#               }
#             break;
#           case 0xd8:
#@@ -2854,7 +2854,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("sk%c1");
# #line 1101 "rl78-decode.opc"
#                 ID(skip); COND(NC);
#-              
#+
#               }
#             break;
#           case 0xd9:
#@@ -2869,7 +2869,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("mov	%e0, %1");
# #line 627 "rl78-decode.opc"
#                 ID(mov); DM2(HL, B, 0); SR(A);
#-              
#+
#               }
#             break;
#           case 0xdb:
#@@ -2884,7 +2884,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("ror	%0, %1");
# #line 1023 "rl78-decode.opc"
#                 ID(ror); DR(A); SC(1);
#-              
#+
#               }
#             break;
#           case 0xdc:
#@@ -2899,7 +2899,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("rolc	%0, %1");
# #line 1017 "rl78-decode.opc"
#                 ID(rolc); DR(A); SC(1);
#-              
#+
#               }
#             break;
#           case 0xdd:
#@@ -2914,9 +2914,9 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("push	%s1");
# #line 998 "rl78-decode.opc"
#                 ID(mov); W(); DPUSH(); SR(PSW);
#-              
#+
#               /*----------------------------------------------------------------------*/
#-              
#+
#               }
#             break;
#           case 0xde:
#@@ -2931,9 +2931,9 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("cmps	%0, %ea1");
# #line 526 "rl78-decode.opc"
#                 ID(cmp); DR(X); SM(HL, IMMU(1)); Fzac;
#-              
#+
#               /*----------------------------------------------------------------------*/
#-              
#+
#               }
#             break;
#           case 0xe0:
#@@ -2948,7 +2948,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("or	%0, %e1");
# #line 947 "rl78-decode.opc"
#                 ID(or); DR(A); SM2(HL, B, 0); Fz;
#-              
#+
#               }
#             break;
#           case 0xe2:
#@@ -2963,7 +2963,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("or	%0, %e1");
# #line 953 "rl78-decode.opc"
#                 ID(or); DR(A); SM2(HL, C, 0); Fz;
#-              
#+
#               }
#             break;
#           case 0xe3:
#@@ -2978,7 +2978,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("sk%c1");
# #line 1098 "rl78-decode.opc"
#                 ID(skip); COND(H);
#-              
#+
#               }
#             break;
#           case 0xe8:
#@@ -2993,9 +2993,9 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("sk%c1");
# #line 1110 "rl78-decode.opc"
#                 ID(skip); COND(Z);
#-              
#+
#               /*----------------------------------------------------------------------*/
#-              
#+
#               }
#             break;
#           case 0xe9:
#@@ -3010,7 +3010,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("mov	%0, %e1");
# #line 663 "rl78-decode.opc"
#                 ID(mov); DR(A); SM2(HL, C, 0);
#-              
#+
#               }
#             break;
#           case 0xeb:
#@@ -3025,7 +3025,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("rol	%0, %1");
# #line 1014 "rl78-decode.opc"
#                 ID(rol); DR(A); SC(1);
#-              
#+
#               }
#             break;
#           case 0xec:
#@@ -3040,9 +3040,9 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("retb");
# #line 1009 "rl78-decode.opc"
#                 ID(reti);
#-              
#+
#               /*----------------------------------------------------------------------*/
#-              
#+
#               }
#             break;
#           case 0xed:
#@@ -3057,9 +3057,9 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("halt");
# #line 576 "rl78-decode.opc"
#                 ID(halt);
#-              
#+
#               /*----------------------------------------------------------------------*/
#-              
#+
#               }
#             break;
#           case 0xee:
#@@ -3078,7 +3078,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("rolwc	%0, %1");
# #line 1020 "rl78-decode.opc"
#                 ID(rolc); W(); DRW(r); SC(1);
#-              
#+
#               }
#             break;
#           case 0xf0:
#@@ -3093,7 +3093,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("xor	%0, %e1");
# #line 1251 "rl78-decode.opc"
#                 ID(xor); DR(A); SM2(HL, B, 0); Fz;
#-              
#+
#               }
#             break;
#           case 0xf2:
#@@ -3108,7 +3108,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("xor	%0, %e1");
# #line 1257 "rl78-decode.opc"
#                 ID(xor); DR(A); SM2(HL, C, 0); Fz;
#-              
#+
#               }
#             break;
#           case 0xf3:
#@@ -3123,7 +3123,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("sk%c1");
# #line 1104 "rl78-decode.opc"
#                 ID(skip); COND(NH);
#-              
#+
#               }
#             break;
#           case 0xf8:
#@@ -3138,7 +3138,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("sk%c1");
# #line 1107 "rl78-decode.opc"
#                 ID(skip); COND(NZ);
#-              
#+
#               }
#             break;
#           case 0xf9:
#@@ -3153,7 +3153,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("mov	%e0, %1");
# #line 636 "rl78-decode.opc"
#                 ID(mov); DM2(HL, C, 0); SR(A);
#-              
#+
#               }
#             break;
#           case 0xfb:
#@@ -3168,12 +3168,12 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("rorc	%0, %1");
# #line 1026 "rl78-decode.opc"
#                 ID(rorc); DR(A); SC(1);
#-              
#+
#               /*----------------------------------------------------------------------*/
#-              
#+
#               /* Note that the branch insns need to be listed before the shift
#                  ones, as "shift count of zero" means "branch insn" */
#-              
#+
#               }
#             break;
#           case 0xfc:
#@@ -3188,7 +3188,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("reti");
# #line 1006 "rl78-decode.opc"
#                 ID(reti);
#-              
#+
#               }
#             break;
#           case 0xfd:
#@@ -3203,9 +3203,9 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("stop");
# #line 1115 "rl78-decode.opc"
#                 ID(stop);
#-              
#+
#               /*----------------------------------------------------------------------*/
#-              
#+
#               }
#             break;
#           default: UNSUPPORTED(); break;
#@@ -3223,7 +3223,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("movw	%e0, %1");
# #line 874 "rl78-decode.opc"
#           ID(mov); W(); DM(C, IMMU(2)); SR(AX);
#-        
#+
#         }
#       break;
#     case 0x69:
#@@ -3238,7 +3238,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("movw	%0, %e1");
# #line 865 "rl78-decode.opc"
#           ID(mov); W(); DR(AX); SM(C, IMMU(2));
#-        
#+
#         }
#       break;
#     case 0x6a:
#@@ -3253,9 +3253,9 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("or	%0, #%1");
# #line 968 "rl78-decode.opc"
#           ID(or); DM(None, SADDR); SC(IMMU(1)); Fz;
#-        
#+
#         /*----------------------------------------------------------------------*/
#-        
#+
#         }
#       break;
#     case 0x6b:
#@@ -3270,7 +3270,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("or	%0, %1");
# #line 965 "rl78-decode.opc"
#           ID(or); DR(A); SM(None, SADDR); Fz;
#-        
#+
#         }
#       break;
#     case 0x6c:
#@@ -3285,7 +3285,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("or	%0, #%1");
# #line 956 "rl78-decode.opc"
#           ID(or); DR(A); SC(IMMU(1)); Fz;
#-        
#+
#         }
#       break;
#     case 0x6d:
#@@ -3300,7 +3300,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("or	%0, %e1");
# #line 944 "rl78-decode.opc"
#           ID(or); DR(A); SM(HL, 0); Fz;
#-        
#+
#         }
#       break;
#     case 0x6e:
#@@ -3315,7 +3315,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("or	%0, %ea1");
# #line 950 "rl78-decode.opc"
#           ID(or); DR(A); SM(HL, IMMU(1)); Fz;
#-        
#+
#         }
#       break;
#     case 0x6f:
#@@ -3330,7 +3330,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("or	%0, %e!1");
# #line 941 "rl78-decode.opc"
#           ID(or); DR(A); SM(None, IMMU(2)); Fz;
#-        
#+
#         }
#       break;
#     case 0x70:
#@@ -3354,7 +3354,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("mov	%0, %1");
# #line 696 "rl78-decode.opc"
#           ID(mov); DRB(rba); SR(A);
#-        
#+
#         }
#       break;
#     case 0x71:
#@@ -3383,7 +3383,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("set1	%e!0");
# #line 1047 "rl78-decode.opc"
#                 ID(mov); DM(None, IMMU(2)); DB(bit); SC(1);
#-              
#+
#               }
#             break;
#           case 0x01:
#@@ -3408,7 +3408,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("mov1	%0, cy");
# #line 803 "rl78-decode.opc"
#                 ID(mov); DM(None, SADDR); DB(bit); SCY();
#-              
#+
#               }
#             break;
#           case 0x02:
#@@ -3433,9 +3433,9 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("set1	%0");
# #line 1065 "rl78-decode.opc"
#                 ID(mov); DM(None, SADDR); DB(bit); SC(1);
#-              
#+
#               /*----------------------------------------------------------------------*/
#-              
#+
#               }
#             break;
#           case 0x03:
#@@ -3460,9 +3460,9 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("clr1	%0");
# #line 456 "rl78-decode.opc"
#                 ID(mov); DM(None, SADDR); DB(bit); SC(0);
#-              
#+
#               /*----------------------------------------------------------------------*/
#-              
#+
#               }
#             break;
#           case 0x04:
#@@ -3487,7 +3487,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("mov1	cy, %1");
# #line 797 "rl78-decode.opc"
#                 ID(mov); DCY(); SM(None, SADDR); SB(bit);
#-              
#+
#               }
#             break;
#           case 0x05:
#@@ -3512,12 +3512,12 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("and1	cy, %s1");
# #line 326 "rl78-decode.opc"
#                 ID(and); DCY(); SM(None, SADDR); SB(bit);
#-              
#+
#               /*----------------------------------------------------------------------*/
#-              
#+
#               /* Note that the branch insns need to be listed before the shift
#                  ones, as "shift count of zero" means "branch insn" */
#-              
#+
#               }
#             break;
#           case 0x06:
#@@ -3542,9 +3542,9 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("or1	cy, %s1");
# #line 982 "rl78-decode.opc"
#                 ID(or); DCY(); SM(None, SADDR); SB(bit);
#-              
#+
#               /*----------------------------------------------------------------------*/
#-              
#+
#               }
#             break;
#           case 0x07:
#@@ -3569,9 +3569,9 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("xor1	cy, %s1");
# #line 1286 "rl78-decode.opc"
#                 ID(xor); DCY(); SM(None, SADDR); SB(bit);
#-              
#+
#               /*----------------------------------------------------------------------*/
#-              
#+
#               }
#             break;
#           case 0x08:
#@@ -3596,7 +3596,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("clr1	%e!0");
# #line 438 "rl78-decode.opc"
#                 ID(mov); DM(None, IMMU(2)); DB(bit); SC(0);
#-              
#+
#               }
#             break;
#           case 0x09:
#@@ -3621,9 +3621,9 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("mov1	%s0, cy");
# #line 806 "rl78-decode.opc"
#                 ID(mov); DM(None, SFR); DB(bit); SCY();
#-              
#+
#               /*----------------------------------------------------------------------*/
#-              
#+
#               }
#             break;
#           case 0x0a:
#@@ -3651,7 +3651,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 ID(mov); DM(None, op0); DB(bit); SC(1);
#                 if (op0 == RL78_SFR_PSW && bit == 7)
#                   rl78->syntax = "ei";
#-              
#+
#               }
#             break;
#           case 0x0b:
#@@ -3679,7 +3679,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 ID(mov); DM(None, op0); DB(bit); SC(0);
#                 if (op0 == RL78_SFR_PSW && bit == 7)
#                   rl78->syntax = "di";
#-              
#+
#               }
#             break;
#           case 0x0c:
#@@ -3704,7 +3704,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("mov1	cy, %s1");
# #line 800 "rl78-decode.opc"
#                 ID(mov); DCY(); SM(None, SFR); SB(bit);
#-              
#+
#               }
#             break;
#           case 0x0d:
#@@ -3729,7 +3729,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("and1	cy, %s1");
# #line 323 "rl78-decode.opc"
#                 ID(and); DCY(); SM(None, SFR); SB(bit);
#-              
#+
#               }
#             break;
#           case 0x0e:
#@@ -3754,7 +3754,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("or1	cy, %s1");
# #line 979 "rl78-decode.opc"
#                 ID(or); DCY(); SM(None, SFR); SB(bit);
#-              
#+
#               }
#             break;
#           case 0x0f:
#@@ -3779,7 +3779,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("xor1	cy, %s1");
# #line 1283 "rl78-decode.opc"
#                 ID(xor); DCY(); SM(None, SFR); SB(bit);
#-              
#+
#               }
#             break;
#           case 0x80:
#@@ -3794,7 +3794,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("set1	cy");
# #line 1056 "rl78-decode.opc"
#                 ID(mov); DCY(); SC(1);
#-              
#+
#               }
#             break;
#           case 0x81:
#@@ -3819,7 +3819,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("mov1	%e0, cy");
# #line 785 "rl78-decode.opc"
#                 ID(mov); DM(HL, 0); DB(bit); SCY();
#-              
#+
#               }
#             break;
#           case 0x82:
#@@ -3844,7 +3844,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("set1	%e0");
# #line 1050 "rl78-decode.opc"
#                 ID(mov); DM(HL, 0); DB(bit); SC(1);
#-              
#+
#               }
#             break;
#           case 0x83:
#@@ -3869,7 +3869,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("clr1	%e0");
# #line 441 "rl78-decode.opc"
#                 ID(mov); DM(HL, 0); DB(bit); SC(0);
#-              
#+
#               }
#             break;
#           case 0x84:
#@@ -3894,7 +3894,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("mov1	cy, %e1");
# #line 791 "rl78-decode.opc"
#                 ID(mov); DCY(); SM(HL, 0); SB(bit);
#-              
#+
#               }
#             break;
#           case 0x85:
#@@ -3919,7 +3919,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("and1	cy, %e1");
# #line 317 "rl78-decode.opc"
#                 ID(and); DCY(); SM(HL, 0); SB(bit);
#-              
#+
#               }
#             break;
#           case 0x86:
#@@ -3944,7 +3944,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("or1	cy, %e1");
# #line 973 "rl78-decode.opc"
#                 ID(or); DCY(); SM(HL, 0); SB(bit);
#-              
#+
#               }
#             break;
#           case 0x87:
#@@ -3969,7 +3969,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("xor1	cy, %e1");
# #line 1277 "rl78-decode.opc"
#                 ID(xor); DCY(); SM(HL, 0); SB(bit);
#-              
#+
#               }
#             break;
#           case 0x88:
#@@ -3984,7 +3984,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("clr1	cy");
# #line 447 "rl78-decode.opc"
#                 ID(mov); DCY(); SC(0);
#-              
#+
#               }
#             break;
#           case 0x89:
#@@ -4009,7 +4009,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("mov1	%e0, cy");
# #line 788 "rl78-decode.opc"
#                 ID(mov); DR(A); DB(bit); SCY();
#-              
#+
#               }
#             break;
#           case 0x8a:
#@@ -4034,7 +4034,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("set1	%0");
# #line 1053 "rl78-decode.opc"
#                 ID(mov); DR(A); DB(bit); SC(1);
#-              
#+
#               }
#             break;
#           case 0x8b:
#@@ -4059,7 +4059,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("clr1	%0");
# #line 444 "rl78-decode.opc"
#                 ID(mov); DR(A); DB(bit); SC(0);
#-              
#+
#               }
#             break;
#           case 0x8c:
#@@ -4084,7 +4084,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("mov1	cy, %e1");
# #line 794 "rl78-decode.opc"
#                 ID(mov); DCY(); SR(A); SB(bit);
#-              
#+
#               }
#             break;
#           case 0x8d:
#@@ -4109,7 +4109,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("and1	cy, %1");
# #line 320 "rl78-decode.opc"
#                 ID(and); DCY(); SR(A); SB(bit);
#-              
#+
#               }
#             break;
#           case 0x8e:
#@@ -4134,7 +4134,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("or1	cy, %1");
# #line 976 "rl78-decode.opc"
#                 ID(or); DCY(); SR(A); SB(bit);
#-              
#+
#               }
#             break;
#           case 0x8f:
#@@ -4159,7 +4159,7 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("xor1	cy, %1");
# #line 1280 "rl78-decode.opc"
#                 ID(xor); DCY(); SR(A); SB(bit);
#-              
#+
#               }
#             break;
#           case 0xc0:
#@@ -4174,9 +4174,9 @@ rl78_decode_opcode (unsigned long pc AU,
#                 SYNTAX("not1	cy");
# #line 917 "rl78-decode.opc"
#                 ID(xor); DCY(); SC(1);
#-              
#+
#               /*----------------------------------------------------------------------*/
#-              
#+
#               }
#             break;
#           default: UNSUPPORTED(); break;
#@@ -4194,7 +4194,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("movw	%e0, %1");
# #line 877 "rl78-decode.opc"
#           ID(mov); W(); DM(BC, IMMU(2)); SR(AX);
#-        
#+
#         }
#       break;
#     case 0x79:
#@@ -4209,7 +4209,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("movw	%0, %e1");
# #line 868 "rl78-decode.opc"
#           ID(mov); W(); DR(AX); SM(BC, IMMU(2));
#-        
#+
#         }
#       break;
#     case 0x7a:
#@@ -4224,9 +4224,9 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("xor	%0, #%1");
# #line 1272 "rl78-decode.opc"
#           ID(xor); DM(None, SADDR); SC(IMMU(1)); Fz;
#-        
#+
#         /*----------------------------------------------------------------------*/
#-        
#+
#         }
#       break;
#     case 0x7b:
#@@ -4241,7 +4241,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("xor	%0, %1");
# #line 1269 "rl78-decode.opc"
#           ID(xor); DR(A); SM(None, SADDR); Fz;
#-        
#+
#         }
#       break;
#     case 0x7c:
#@@ -4256,7 +4256,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("xor	%0, #%1");
# #line 1260 "rl78-decode.opc"
#           ID(xor); DR(A); SC(IMMU(1)); Fz;
#-        
#+
#         }
#       break;
#     case 0x7d:
#@@ -4271,7 +4271,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("xor	%0, %e1");
# #line 1248 "rl78-decode.opc"
#           ID(xor); DR(A); SM(HL, 0); Fz;
#-        
#+
#         }
#       break;
#     case 0x7e:
#@@ -4286,7 +4286,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("xor	%0, %ea1");
# #line 1254 "rl78-decode.opc"
#           ID(xor); DR(A); SM(HL, IMMU(1)); Fz;
#-        
#+
#         }
#       break;
#     case 0x7f:
#@@ -4301,7 +4301,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("xor	%0, %e!1");
# #line 1245 "rl78-decode.opc"
#           ID(xor); DR(A); SM(None, IMMU(2)); Fz;
#-        
#+
#         }
#       break;
#     case 0x80:
#@@ -4326,7 +4326,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("inc	%0");
# #line 587 "rl78-decode.opc"
#           ID(add); DRB(reg); SC(1); Fza;
#-        
#+
#         }
#       break;
#     case 0x88:
#@@ -4341,7 +4341,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("mov	%0, %e1");
# #line 666 "rl78-decode.opc"
#           ID(mov); DR(A); SM(SP, IMMU(1));
#-        
#+
#         }
#       break;
#     case 0x89:
#@@ -4356,7 +4356,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("mov	%0, %e1");
# #line 648 "rl78-decode.opc"
#           ID(mov); DR(A); SM(DE, 0);
#-        
#+
#         }
#       break;
#     case 0x8a:
#@@ -4371,7 +4371,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("mov	%0, %e1");
# #line 651 "rl78-decode.opc"
#           ID(mov); DR(A); SM(DE, IMMU(1));
#-        
#+
#         }
#       break;
#     case 0x8b:
#@@ -4386,7 +4386,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("mov	%0, %e1");
# #line 654 "rl78-decode.opc"
#           ID(mov); DR(A); SM(HL, 0);
#-        
#+
#         }
#       break;
#     case 0x8c:
#@@ -4401,7 +4401,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("mov	%0, %ea1");
# #line 657 "rl78-decode.opc"
#           ID(mov); DR(A); SM(HL, IMMU(1));
#-        
#+
#         }
#       break;
#     case 0x8d:
#@@ -4416,7 +4416,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("mov	%0, %1");
# #line 690 "rl78-decode.opc"
#           ID(mov); DR(A); SM(None, SADDR);
#-        
#+
#         }
#       break;
#     case 0x8e:
#@@ -4431,7 +4431,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("mov	%0, %s1");
# #line 687 "rl78-decode.opc"
#           ID(mov); DR(A); SM(None, SFR);
#-        
#+
#         }
#       break;
#     case 0x8f:
#@@ -4446,7 +4446,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("mov	%0, %e!1");
# #line 645 "rl78-decode.opc"
#           ID(mov); DR(A); SM(None, IMMU(2));
#-        
#+
#         }
#       break;
#     case 0x90:
#@@ -4471,7 +4471,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("dec	%0");
# #line 554 "rl78-decode.opc"
#           ID(sub); DRB(reg); SC(1); Fza;
#-        
#+
#         }
#       break;
#     case 0x98:
#@@ -4486,7 +4486,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("mov	%0, %1");
# #line 642 "rl78-decode.opc"
#           ID(mov); DM(SP, IMMU(1)); SR(A);
#-        
#+
#         }
#       break;
#     case 0x99:
#@@ -4501,7 +4501,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("mov	%e0, %1");
# #line 615 "rl78-decode.opc"
#           ID(mov); DM(DE, 0); SR(A);
#-        
#+
#         }
#       break;
#     case 0x9a:
#@@ -4516,7 +4516,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("mov	%e0, %1");
# #line 621 "rl78-decode.opc"
#           ID(mov); DM(DE, IMMU(1)); SR(A);
#-        
#+
#         }
#       break;
#     case 0x9b:
#@@ -4531,7 +4531,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("mov	%e0, %1");
# #line 624 "rl78-decode.opc"
#           ID(mov); DM(HL, 0); SR(A);
#-        
#+
#         }
#       break;
#     case 0x9c:
#@@ -4546,7 +4546,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("mov	%ea0, %1");
# #line 633 "rl78-decode.opc"
#           ID(mov); DM(HL, IMMU(1)); SR(A);
#-        
#+
#         }
#       break;
#     case 0x9d:
#@@ -4561,7 +4561,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("mov	%0, %1");
# #line 747 "rl78-decode.opc"
#           ID(mov); DM(None, SADDR); SR(A);
#-        
#+
#         }
#       break;
#     case 0x9e:
#@@ -4576,9 +4576,9 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("mov	%0, %1");
# #line 780 "rl78-decode.opc"
#           ID(mov); DM(None, SFR); SR(A);
#-        
#+
#         /*----------------------------------------------------------------------*/
#-        
#+
#         }
#       break;
#     case 0x9f:
#@@ -4593,7 +4593,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("mov	%e!0, %1");
# #line 612 "rl78-decode.opc"
#           ID(mov); DM(None, IMMU(2)); SR(A);
#-        
#+
#         }
#       break;
#     case 0xa0:
#@@ -4608,7 +4608,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("inc	%e!0");
# #line 581 "rl78-decode.opc"
#           ID(add); DM(None, IMMU(2)); SC(1); Fza;
#-        
#+
#         }
#       break;
#     case 0xa1:
#@@ -4629,7 +4629,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("incw	%0");
# #line 601 "rl78-decode.opc"
#           ID(add); W(); DRW(rg); SC(1);
#-        
#+
#         }
#       break;
#     case 0xa2:
#@@ -4644,7 +4644,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("incw	%e!0");
# #line 595 "rl78-decode.opc"
#           ID(add); W(); DM(None, IMMU(2)); SC(1);
#-        
#+
#         }
#       break;
#     case 0xa4:
#@@ -4659,9 +4659,9 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("inc	%0");
# #line 590 "rl78-decode.opc"
#           ID(add); DM(None, SADDR); SC(1); Fza;
#-        
#+
#         /*----------------------------------------------------------------------*/
#-        
#+
#         }
#       break;
#     case 0xa6:
#@@ -4676,9 +4676,9 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("incw	%0");
# #line 604 "rl78-decode.opc"
#           ID(add); W(); DM(None, SADDR); SC(1);
#-        
#+
#         /*----------------------------------------------------------------------*/
#-        
#+
#         }
#       break;
#     case 0xa8:
#@@ -4693,7 +4693,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("movw	%0, %1");
# #line 850 "rl78-decode.opc"
#           ID(mov); W(); DR(AX); SM(SP, IMMU(1));
#-        
#+
#         }
#       break;
#     case 0xa9:
#@@ -4708,7 +4708,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("movw	%0, %e1");
# #line 838 "rl78-decode.opc"
#           ID(mov); W(); DR(AX); SM(DE, 0);
#-        
#+
#         }
#       break;
#     case 0xaa:
#@@ -4723,7 +4723,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("movw	%0, %e1");
# #line 841 "rl78-decode.opc"
#           ID(mov); W(); DR(AX); SM(DE, IMMU(1));
#-        
#+
#         }
#       break;
#     case 0xab:
#@@ -4738,7 +4738,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("movw	%0, %e1");
# #line 844 "rl78-decode.opc"
#           ID(mov); W(); DR(AX); SM(HL, 0);
#-        
#+
#         }
#       break;
#     case 0xac:
#@@ -4753,7 +4753,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("movw	%0, %ea1");
# #line 847 "rl78-decode.opc"
#           ID(mov); W(); DR(AX); SM(HL, IMMU(1));
#-        
#+
#         }
#       break;
#     case 0xad:
#@@ -4768,7 +4768,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("movw	%0, %1");
# #line 880 "rl78-decode.opc"
#           ID(mov); W(); DR(AX); SM(None, SADDR);
#-        
#+
#         }
#       break;
#     case 0xae:
#@@ -4783,7 +4783,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("movw	%0, %s1");
# #line 883 "rl78-decode.opc"
#           ID(mov); W(); DR(AX); SM(None, SFR);
#-        
#+
#         }
#       break;
#     case 0xaf:
#@@ -4798,8 +4798,8 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("movw	%0, %e!1");
# #line 834 "rl78-decode.opc"
#           ID(mov); W(); DR(AX); SM(None, IMMU(2));
#-        
#-        
#+
#+
#         }
#       break;
#     case 0xb0:
#@@ -4814,7 +4814,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("dec	%e!0");
# #line 548 "rl78-decode.opc"
#           ID(sub); DM(None, IMMU(2)); SC(1); Fza;
#-        
#+
#         }
#       break;
#     case 0xb1:
#@@ -4835,7 +4835,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("decw	%0");
# #line 568 "rl78-decode.opc"
#           ID(sub); W(); DRW(rg); SC(1);
#-        
#+
#         }
#       break;
#     case 0xb2:
#@@ -4850,7 +4850,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("decw	%e!0");
# #line 562 "rl78-decode.opc"
#           ID(sub); W(); DM(None, IMMU(2)); SC(1);
#-        
#+
#         }
#       break;
#     case 0xb4:
#@@ -4865,9 +4865,9 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("dec	%0");
# #line 557 "rl78-decode.opc"
#           ID(sub); DM(None, SADDR); SC(1); Fza;
#-        
#+
#         /*----------------------------------------------------------------------*/
#-        
#+
#         }
#       break;
#     case 0xb6:
#@@ -4882,9 +4882,9 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("decw	%0");
# #line 571 "rl78-decode.opc"
#           ID(sub); W(); DM(None, SADDR); SC(1);
#-        
#+
#         /*----------------------------------------------------------------------*/
#-        
#+
#         }
#       break;
#     case 0xb8:
#@@ -4899,7 +4899,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("movw	%0, %1");
# #line 831 "rl78-decode.opc"
#           ID(mov); W(); DM(SP, IMMU(1)); SR(AX);
#-        
#+
#         }
#       break;
#     case 0xb9:
#@@ -4914,7 +4914,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("movw	%e0, %1");
# #line 819 "rl78-decode.opc"
#           ID(mov); W(); DM(DE, 0); SR(AX);
#-        
#+
#         }
#       break;
#     case 0xba:
#@@ -4929,7 +4929,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("movw	%e0, %1");
# #line 822 "rl78-decode.opc"
#           ID(mov); W(); DM(DE, IMMU(1)); SR(AX);
#-        
#+
#         }
#       break;
#     case 0xbb:
#@@ -4944,7 +4944,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("movw	%e0, %1");
# #line 825 "rl78-decode.opc"
#           ID(mov); W(); DM(HL, 0); SR(AX);
#-        
#+
#         }
#       break;
#     case 0xbc:
#@@ -4959,7 +4959,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("movw	%ea0, %1");
# #line 828 "rl78-decode.opc"
#           ID(mov); W(); DM(HL, IMMU(1)); SR(AX);
#-        
#+
#         }
#       break;
#     case 0xbd:
#@@ -4974,7 +4974,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("movw	%0, %1");
# #line 895 "rl78-decode.opc"
#           ID(mov); W(); DM(None, SADDR); SR(AX);
#-        
#+
#         }
#       break;
#     case 0xbe:
#@@ -4989,9 +4989,9 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("movw	%0, %1");
# #line 901 "rl78-decode.opc"
#           ID(mov); W(); DM(None, SFR); SR(AX);
#-        
#+
#         /*----------------------------------------------------------------------*/
#-        
#+
#         }
#       break;
#     case 0xbf:
#@@ -5006,7 +5006,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("movw	%e!0, %1");
# #line 816 "rl78-decode.opc"
#           ID(mov); W(); DM(None, IMMU(2)); SR(AX);
#-        
#+
#         }
#       break;
#     case 0xc0:
#@@ -5027,7 +5027,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("pop	%0");
# #line 987 "rl78-decode.opc"
#           ID(mov); W(); DRW(rg); SPOP();
#-        
#+
#         }
#       break;
#     case 0xc1:
#@@ -5048,7 +5048,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("push	%1");
# #line 995 "rl78-decode.opc"
#           ID(mov); W(); DPUSH(); SRW(rg);
#-        
#+
#         }
#       break;
#     case 0xc8:
#@@ -5063,7 +5063,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("mov	%0, #%1");
# #line 639 "rl78-decode.opc"
#           ID(mov); DM(SP, IMMU(1)); SC(IMMU(1));
#-        
#+
#         }
#       break;
#     case 0xc9:
#@@ -5078,7 +5078,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("movw	%0, #%1");
# #line 892 "rl78-decode.opc"
#           ID(mov); W(); DM(None, SADDR); SC(IMMU(2));
#-        
#+
#         }
#       break;
#     case 0xca:
#@@ -5093,7 +5093,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("mov	%e0, #%1");
# #line 618 "rl78-decode.opc"
#           ID(mov); DM(DE, IMMU(1)); SC(IMMU(1));
#-        
#+
#         }
#       break;
#     case 0xcb:
#@@ -5108,7 +5108,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("movw	%0, #%1");
# #line 898 "rl78-decode.opc"
#           ID(mov); W(); DM(None, SFR); SC(IMMU(2));
#-        
#+
#         }
#       break;
#     case 0xcc:
#@@ -5123,7 +5123,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("mov	%ea0, #%1");
# #line 630 "rl78-decode.opc"
#           ID(mov); DM(HL, IMMU(1)); SC(IMMU(1));
#-        
#+
#         }
#       break;
#     case 0xcd:
#@@ -5138,7 +5138,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("mov	%0, #%1");
# #line 744 "rl78-decode.opc"
#           ID(mov); DM(None, SADDR); SC(IMMU(1));
#-        
#+
#         }
#       break;
#     case 0xce:
#@@ -5180,7 +5180,7 @@ rl78_decode_opcode (unsigned long pc AU,
#         	rl78->syntax = "divwu"; ID(divwu);
#         	break;
#               }
#-        
#+
#         }
#       break;
#     case 0xcf:
#@@ -5195,7 +5195,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("mov	%e!0, #%1");
# #line 609 "rl78-decode.opc"
#           ID(mov); DM(None, IMMU(2)); SC(IMMU(1));
#-        
#+
#         }
#       break;
#     case 0xd0:
#@@ -5216,7 +5216,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("cmp0	%0");
# #line 518 "rl78-decode.opc"
#           ID(cmp); DRB(rg); SC(0); Fzac;
#-        
#+
#         }
#       break;
#     case 0xd4:
#@@ -5231,9 +5231,9 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("cmp0	%0");
# #line 521 "rl78-decode.opc"
#           ID(cmp); DM(None, SADDR); SC(0); Fzac;
#-        
#+
#         /*----------------------------------------------------------------------*/
#-        
#+
#         }
#       break;
#     case 0xd5:
#@@ -5248,7 +5248,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("cmp0	%e!0");
# #line 515 "rl78-decode.opc"
#           ID(cmp); DM(None, IMMU(2)); SC(0); Fzac;
#-        
#+
#         }
#       break;
#     case 0xd6:
#@@ -5264,9 +5264,9 @@ rl78_decode_opcode (unsigned long pc AU,
# #line 906 "rl78-decode.opc"
#           if (isa == RL78_ISA_G14)
#             ID(mulu);
#-        
#+
#         /*----------------------------------------------------------------------*/
#-        
#+
#         }
#       break;
#     case 0xd7:
#@@ -5281,7 +5281,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("ret");
# #line 1003 "rl78-decode.opc"
#           ID(ret);
#-        
#+
#         }
#       break;
#     case 0xd8:
#@@ -5296,7 +5296,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("mov	%0, %1");
# #line 711 "rl78-decode.opc"
#           ID(mov); DR(X); SM(None, SADDR);
#-        
#+
#         }
#       break;
#     case 0xd9:
#@@ -5311,7 +5311,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("mov	%0, %e!1");
# #line 708 "rl78-decode.opc"
#           ID(mov); DR(X); SM(None, IMMU(2));
#-        
#+
#         }
#       break;
#     case 0xda:
#@@ -5331,7 +5331,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("movw	%0, %1");
# #line 889 "rl78-decode.opc"
#           ID(mov); W(); DRW(ra); SM(None, SADDR);
#-        
#+
#         }
#       break;
#     case 0xdb:
#@@ -5351,7 +5351,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("movw	%0, %e!1");
# #line 886 "rl78-decode.opc"
#           ID(mov); W(); DRW(ra); SM(None, IMMU(2));
#-        
#+
#         }
#       break;
#     case 0xdc:
#@@ -5366,7 +5366,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("bc	$%a0");
# #line 334 "rl78-decode.opc"
#           ID(branch_cond); DC(pc+IMMS(1)+2); SR(None); COND(C);
#-        
#+
#         }
#       break;
#     case 0xdd:
#@@ -5381,7 +5381,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("bz	$%a0");
# #line 346 "rl78-decode.opc"
#           ID(branch_cond); DC(pc+IMMS(1)+2); SR(None); COND(Z);
#-        
#+
#         }
#       break;
#     case 0xde:
#@@ -5396,7 +5396,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("bnc	$%a0");
# #line 337 "rl78-decode.opc"
#           ID(branch_cond); DC(pc+IMMS(1)+2); SR(None); COND(NC);
#-        
#+
#         }
#       break;
#     case 0xdf:
#@@ -5411,9 +5411,9 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("bnz	$%a0");
# #line 349 "rl78-decode.opc"
#           ID(branch_cond); DC(pc+IMMS(1)+2); SR(None); COND(NZ);
#-        
#+
#         /*----------------------------------------------------------------------*/
#-        
#+
#         }
#       break;
#     case 0xe0:
#@@ -5434,7 +5434,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("oneb	%0");
# #line 925 "rl78-decode.opc"
#           ID(mov); DRB(rg); SC(1);
#-        
#+
#         }
#       break;
#     case 0xe4:
#@@ -5449,9 +5449,9 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("oneb	%0");
# #line 928 "rl78-decode.opc"
#           ID(mov); DM(None, SADDR); SC(1);
#-        
#+
#         /*----------------------------------------------------------------------*/
#-        
#+
#         }
#       break;
#     case 0xe5:
#@@ -5466,7 +5466,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("oneb	%e!0");
# #line 922 "rl78-decode.opc"
#           ID(mov); DM(None, IMMU(2)); SC(1);
#-        
#+
#         }
#       break;
#     case 0xe6:
#@@ -5481,7 +5481,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("onew	%0");
# #line 933 "rl78-decode.opc"
#           ID(mov); DR(AX); SC(1);
#-        
#+
#         }
#       break;
#     case 0xe7:
#@@ -5496,9 +5496,9 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("onew	%0");
# #line 936 "rl78-decode.opc"
#           ID(mov); DR(BC); SC(1);
#-        
#+
#         /*----------------------------------------------------------------------*/
#-        
#+
#         }
#       break;
#     case 0xe8:
#@@ -5513,7 +5513,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("mov	%0, %1");
# #line 699 "rl78-decode.opc"
#           ID(mov); DR(B); SM(None, SADDR);
#-        
#+
#         }
#       break;
#     case 0xe9:
#@@ -5528,7 +5528,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("mov	%0, %e!1");
# #line 693 "rl78-decode.opc"
#           ID(mov); DR(B); SM(None, IMMU(2));
#-        
#+
#         }
#       break;
#     case 0xec:
#@@ -5543,7 +5543,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("br	!%!a0");
# #line 368 "rl78-decode.opc"
#           ID(branch); DC(IMMU(3));
#-        
#+
#         }
#       break;
#     case 0xed:
#@@ -5558,7 +5558,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("br	%!a0");
# #line 371 "rl78-decode.opc"
#           ID(branch); DC(IMMU(2));
#-        
#+
#         }
#       break;
#     case 0xee:
#@@ -5573,7 +5573,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("br	$%!a0");
# #line 374 "rl78-decode.opc"
#           ID(branch); DC(pc+IMMS(2)+3);
#-        
#+
#         }
#       break;
#     case 0xef:
#@@ -5588,7 +5588,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("br	$%a0");
# #line 377 "rl78-decode.opc"
#           ID(branch); DC(pc+IMMS(1)+2);
#-        
#+
#         }
#       break;
#     case 0xf0:
#@@ -5609,7 +5609,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("clrb	%0");
# #line 464 "rl78-decode.opc"
#           ID(mov); DRB(rg); SC(0);
#-        
#+
#         }
#       break;
#     case 0xf4:
#@@ -5624,9 +5624,9 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("clrb	%0");
# #line 467 "rl78-decode.opc"
#           ID(mov); DM(None, SADDR); SC(0);
#-        
#+
#         /*----------------------------------------------------------------------*/
#-        
#+
#         }
#       break;
#     case 0xf5:
#@@ -5641,7 +5641,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("clrb	%e!0");
# #line 461 "rl78-decode.opc"
#           ID(mov); DM(None, IMMU(2)); SC(0);
#-        
#+
#         }
#       break;
#     case 0xf6:
#@@ -5656,7 +5656,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("clrw	%0");
# #line 472 "rl78-decode.opc"
#           ID(mov); DR(AX); SC(0);
#-        
#+
#         }
#       break;
#     case 0xf7:
#@@ -5671,9 +5671,9 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("clrw	%0");
# #line 475 "rl78-decode.opc"
#           ID(mov); DR(BC); SC(0);
#-        
#+
#         /*----------------------------------------------------------------------*/
#-        
#+
#         }
#       break;
#     case 0xf8:
#@@ -5688,7 +5688,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("mov	%0, %1");
# #line 705 "rl78-decode.opc"
#           ID(mov); DR(C); SM(None, SADDR);
#-        
#+
#         }
#       break;
#     case 0xf9:
#@@ -5703,7 +5703,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("mov	%0, %e!1");
# #line 702 "rl78-decode.opc"
#           ID(mov); DR(C); SM(None, IMMU(2));
#-        
#+
#         }
#       break;
#     case 0xfc:
#@@ -5718,7 +5718,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("call	!%!a0");
# #line 421 "rl78-decode.opc"
#           ID(call); DC(IMMU(3));
#-        
#+
#         }
#       break;
#     case 0xfd:
#@@ -5733,7 +5733,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("call	%!a0");
# #line 424 "rl78-decode.opc"
#           ID(call); DC(IMMU(2));
#-        
#+
#         }
#       break;
#     case 0xfe:
#@@ -5748,7 +5748,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("call	$%!a0");
# #line 427 "rl78-decode.opc"
#           ID(call); DC(pc+IMMS(2)+3);
#-        
#+
#         }
#       break;
#     case 0xff:
#@@ -5763,7 +5763,7 @@ rl78_decode_opcode (unsigned long pc AU,
#           SYNTAX("brk1");
# #line 385 "rl78-decode.opc"
#           ID(break);
#-        
#+
#         }
#       break;
#   }
#--- a/opcodes/rl78-decode.opc
#+++ b/opcodes/rl78-decode.opc
#@@ -208,7 +208,7 @@ rl78_decode_opcode (unsigned long pc AU,
# 
# /** 0000 1110			add	%0, %ea1			*/
#   ID(add); DR(A); SM(HL, IMMU(1)); Fzac;
#-  
#+
# /** 0110 0001 1000 0010		add	%0, %e1				*/
#   ID(add); DR(A); SM2(HL, C, 0); Fzac;
# 
#@@ -714,28 +714,28 @@ rl78_decode_opcode (unsigned long pc AU,
#   ID(mov); DR(CS); SR(A);
# 
# /** 0100 0001			mov	%0, #%1				*/
#-  ID(mov); DR(ES); SC(IMMU(1));	
#+  ID(mov); DR(ES); SC(IMMU(1));
# 
# /** 1001 1110 1111 1101		mov	%0, %1				*/
#-  ID(mov); DR(ES); SR(A);	
#+  ID(mov); DR(ES); SR(A);
# 
# /** 0110 0001 1011 1000		mov	%0, %1				*/
#-  ID(mov); DR(ES); SM(None, SADDR);	
#+  ID(mov); DR(ES); SM(None, SADDR);
# 
# /** 0001 1001			mov	%e0, #%1			*/
#-  ID(mov); DM(B, IMMU(2)); SC(IMMU(1));	
#+  ID(mov); DM(B, IMMU(2)); SC(IMMU(1));
# 
# /** 0001 1000			mov	%e0, %1				*/
#-  ID(mov); DM(B, IMMU(2)); SR(A);	
#+  ID(mov); DM(B, IMMU(2)); SR(A);
# 
# /** 0011 1001			mov	%e0, #%1			*/
#-  ID(mov); DM(BC, IMMU(2)); SC(IMMU(1));	
#+  ID(mov); DM(BC, IMMU(2)); SC(IMMU(1));
# 
# /** 0100 1000			mov	%e0, %1				*/
#-  ID(mov); DM(BC, IMMU(2)); SR(A);	
#+  ID(mov); DM(BC, IMMU(2)); SR(A);
# 
# /** 0011 1000			mov	%e0, #%1			*/
#-  ID(mov); DM(C, IMMU(2)); SC(IMMU(1));	
#+  ID(mov); DM(C, IMMU(2)); SC(IMMU(1));
# 
# /** 0010 1000			mov	%e0, %1				*/
#   ID(mov); DM(C, IMMU(2)); SR(A);
--- a/opcodes/rl78-dis.c
+++ b/opcodes/rl78-dis.c
@@ -204,7 +204,7 @@ print_insn_rl78_common (bfd_vma addr, disassemble_info * dis, RL78_Dis_Isa isa)
 		{
 		  char *comma = "";
 		  PR (PS, "  \033[35m");
-	      
+
 		  if (opcode.flags & RL78_PSW_Z)
 		    { PR (PS, "Z"); comma = ","; }
 		  if (opcode.flags & RL78_PSW_AC)
@@ -290,7 +290,7 @@ print_insn_rl78_common (bfd_vma addr, disassemble_info * dis, RL78_Dis_Isa isa)
 		      PR (PS, "+%d", oper->addend);
 		    PC (']');
 		    break;
-		      
+
 		  }
 		if (oper->type == RL78_Operand_BitIndirect)
 		  PR (PS, ".%d", oper->bit_number);
#--- a/opcodes/rx-decode.c
#+++ b/opcodes/rx-decode.c
#@@ -66,7 +66,7 @@ static int ubwl[] =
#   RX_UByte,
#   RX_UWord,
#   RX_Long,
#-  0 /* Bogus instructions can have a size field set to 3.  */  
#+  0 /* Bogus instructions can have a size field set to 3.  */
# };
# 
# static int memex[] =
#@@ -250,7 +250,7 @@ rx_disp (int n, int type, int reg, int size, LocalData * ld)
# #define xZ 2
# #define xC 1
# 
#-#define F_____ 
#+#define F_____
# #define F___ZC rx->flags_0 = rx->flags_s = xZ|xC;
# #define F__SZ_ rx->flags_0 = rx->flags_s = xS|xZ;
# #define F__SZC rx->flags_0 = rx->flags_s = xS|xZ|xC;
#@@ -296,7 +296,7 @@ rx_decode_opcode (unsigned long pc AU,
#           SYNTAX("brk");
# #line 987 "rx-decode.opc"
#           ID(brk);
#-        
#+
#         }
#       break;
#     case 0x01:
#@@ -311,7 +311,7 @@ rx_decode_opcode (unsigned long pc AU,
#           SYNTAX("dbt");
# #line 990 "rx-decode.opc"
#           ID(dbt);
#-        
#+
#         }
#       break;
#     case 0x02:
#@@ -326,10 +326,10 @@ rx_decode_opcode (unsigned long pc AU,
#           SYNTAX("rts");
# #line 768 "rx-decode.opc"
#           ID(rts);
#-        
#+
#         /*----------------------------------------------------------------------*/
#         /* NOP								*/
#-        
#+
#         }
#       break;
#     case 0x03:
#@@ -344,10 +344,10 @@ rx_decode_opcode (unsigned long pc AU,
#           SYNTAX("nop");
# #line 774 "rx-decode.opc"
#           ID(nop);
#-        
#+
#         /*----------------------------------------------------------------------*/
#         /* STRING FUNCTIONS							*/
#-        
#+
#         }
#       break;
#     case 0x04:
#@@ -362,7 +362,7 @@ rx_decode_opcode (unsigned long pc AU,
#           SYNTAX("bra.a	%a0");
# #line 746 "rx-decode.opc"
#           ID(branch); DC(pc + IMMex(3));
#-        
#+
#         }
#       break;
#     case 0x05:
#@@ -377,7 +377,7 @@ rx_decode_opcode (unsigned long pc AU,
#           SYNTAX("bsr.a	%a0");
# #line 762 "rx-decode.opc"
#           ID(jsr); DC(pc + IMMex(3));
#-        
#+
#         }
#       break;
#     case 0x06:
#@@ -413,7 +413,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("sub	%2%S2, %1");
# #line 542 "rx-decode.opc"
#                       ID(sub); S2Pm(ss, rsrc, mx); SR(rdst); DR(rdst); F_OSZC;
#-                    
#+
#                     }
#                   break;
#               }
#@@ -474,10 +474,10 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("cmp	%2%S2, %1");
# #line 530 "rx-decode.opc"
#                       ID(sub); S2Pm(ss, rsrc, mx); SR(rdst); F_OSZC;
#-                    
#+
#                     /*----------------------------------------------------------------------*/
#                     /* SUB									*/
#-                    
#+
#                     }
#                   break;
#               }
#@@ -538,7 +538,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("add	%1%S1, %0");
# #line 506 "rx-decode.opc"
#                       ID(add); SPm(ss, rsrc, mx); DR(rdst); F_OSZC;
#-                    
#+
#                     }
#                   break;
#               }
#@@ -599,7 +599,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("mul	%1%S1, %0");
# #line 611 "rx-decode.opc"
#                       ID(mul); SPm(ss, rsrc, mx); DR(rdst); F_____;
#-                    
#+
#                     }
#                   break;
#               }
#@@ -660,7 +660,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("and	%1%S1, %0");
# #line 419 "rx-decode.opc"
#                       ID(and); SPm(ss, rsrc, mx); DR(rdst); F__SZ_;
#-                    
#+
#                     }
#                   break;
#               }
#@@ -721,7 +721,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("or	%1%S1, %0");
# #line 437 "rx-decode.opc"
#                       ID(or); SPm(ss, rsrc, mx); DR(rdst); F__SZ_;
#-                    
#+
#                     }
#                   break;
#               }
#@@ -786,10 +786,10 @@ rx_decode_opcode (unsigned long pc AU,
#                             SYNTAX("sbb	%1%S1, %0");
# #line 555 "rx-decode.opc"
#                             ID(sbb); SPm(sp, rsrc, mx); DR(rdst); F_OSZC;
#-                          
#+
#                           /*----------------------------------------------------------------------*/
#                           /* ABS									*/
#-                          
#+
#                           }
#                         break;
#                     }
#@@ -823,10 +823,10 @@ rx_decode_opcode (unsigned long pc AU,
#                             SYNTAX("max	%1%S1, %0");
# #line 584 "rx-decode.opc"
#                             ID(max); SPm(ss, rsrc, mx); DR(rdst);
#-                          
#+
#                           /*----------------------------------------------------------------------*/
#                           /* MIN									*/
#-                          
#+
#                           }
#                         break;
#                     }
#@@ -860,10 +860,10 @@ rx_decode_opcode (unsigned long pc AU,
#                             SYNTAX("min	%1%S1, %0");
# #line 596 "rx-decode.opc"
#                             ID(min); SPm(ss, rsrc, mx); DR(rdst);
#-                          
#+
#                           /*----------------------------------------------------------------------*/
#                           /* MUL									*/
#-                          
#+
#                           }
#                         break;
#                     }
#@@ -897,10 +897,10 @@ rx_decode_opcode (unsigned long pc AU,
#                             SYNTAX("emul	%1%S1, %0");
# #line 626 "rx-decode.opc"
#                             ID(emul); SPm(ss, rsrc, mx); DR(rdst);
#-                          
#+
#                           /*----------------------------------------------------------------------*/
#                           /* EMULU									*/
#-                          
#+
#                           }
#                         break;
#                     }
#@@ -934,10 +934,10 @@ rx_decode_opcode (unsigned long pc AU,
#                             SYNTAX("emulu	%1%S1, %0");
# #line 638 "rx-decode.opc"
#                             ID(emulu); SPm(ss, rsrc, mx); DR(rdst);
#-                          
#+
#                           /*----------------------------------------------------------------------*/
#                           /* DIV									*/
#-                          
#+
#                           }
#                         break;
#                     }
#@@ -971,10 +971,10 @@ rx_decode_opcode (unsigned long pc AU,
#                             SYNTAX("div	%1%S1, %0");
# #line 650 "rx-decode.opc"
#                             ID(div); SPm(ss, rsrc, mx); DR(rdst); F_O___;
#-                          
#+
#                           /*----------------------------------------------------------------------*/
#                           /* DIVU									*/
#-                          
#+
#                           }
#                         break;
#                     }
#@@ -1008,10 +1008,10 @@ rx_decode_opcode (unsigned long pc AU,
#                             SYNTAX("divu	%1%S1, %0");
# #line 662 "rx-decode.opc"
#                             ID(divu); SPm(ss, rsrc, mx); DR(rdst); F_O___;
#-                          
#+
#                           /*----------------------------------------------------------------------*/
#                           /* SHIFT								*/
#-                          
#+
#                           }
#                         break;
#                     }
#@@ -1045,10 +1045,10 @@ rx_decode_opcode (unsigned long pc AU,
#                             SYNTAX("tst	%1%S1, %2");
# #line 473 "rx-decode.opc"
#                             ID(and); SPm(ss, rsrc, mx); S2R(rdst); F__SZ_;
#-                          
#+
#                           /*----------------------------------------------------------------------*/
#                           /* NEG									*/
#-                          
#+
#                           }
#                         break;
#                     }
#@@ -1082,10 +1082,10 @@ rx_decode_opcode (unsigned long pc AU,
#                             SYNTAX("xor	%1%S1, %0");
# #line 452 "rx-decode.opc"
#                             ID(xor); SPm(ss, rsrc, mx); DR(rdst); F__SZ_;
#-                          
#+
#                           /*----------------------------------------------------------------------*/
#                           /* NOT									*/
#-                          
#+
#                           }
#                         break;
#                     }
#@@ -1119,10 +1119,10 @@ rx_decode_opcode (unsigned long pc AU,
#                             SYNTAX("xchg	%1%S1, %0");
# #line 386 "rx-decode.opc"
#                             ID(xchg); DR(rdst); SPm(ss, rsrc, mx);
#-                          
#+
#                           /*----------------------------------------------------------------------*/
#                           /* STZ/STNZ								*/
#-                          
#+
#                           }
#                         break;
#                     }
#@@ -1156,10 +1156,10 @@ rx_decode_opcode (unsigned long pc AU,
#                             SYNTAX("itof	%1%S1, %0");
# #line 891 "rx-decode.opc"
#                             ID(itof); DR (rdst); SPm(sd, rsrc, mx); F__SZ_;
#-                          
#+
#                           /*----------------------------------------------------------------------*/
#                           /* BIT OPS								*/
#-                          
#+
#                           }
#                         break;
#                     }
#@@ -2380,10 +2380,10 @@ rx_decode_opcode (unsigned long pc AU,
#                             SYNTAX("adc	%1%S1, %0");
# #line 494 "rx-decode.opc"
#                             ID(adc); SPm(ss, rsrc, 2); DR(rdst); F_OSZC;
#-                          
#+
#                           /*----------------------------------------------------------------------*/
#                           /* ADD									*/
#-                          
#+
#                           }
#                         break;
#                     }
#@@ -3491,7 +3491,7 @@ rx_decode_opcode (unsigned long pc AU,
#           SYNTAX("bra.s	%a0");
# #line 737 "rx-decode.opc"
#           ID(branch); DC(pc + dsp3map[dsp]);
#-        
#+
#         }
#       break;
#     case 0x10:
#@@ -3527,7 +3527,7 @@ rx_decode_opcode (unsigned long pc AU,
#           SYNTAX("b%1.s	%a0");
# #line 727 "rx-decode.opc"
#           ID(branch); Scc(n); DC(pc + dsp3map[dsp]);
#-        
#+
#         }
#       break;
#     case 0x20:
#@@ -3559,7 +3559,7 @@ rx_decode_opcode (unsigned long pc AU,
#           SYNTAX("b%1.b	%a0");
# #line 730 "rx-decode.opc"
#           ID(branch); Scc(cond); DC(pc + IMMex (1));
#-        
#+
#         }
#       break;
#     case 0x2e:
#@@ -3574,7 +3574,7 @@ rx_decode_opcode (unsigned long pc AU,
#           SYNTAX("bra.b	%a0");
# #line 740 "rx-decode.opc"
#           ID(branch); DC(pc + IMMex(1));
#-        
#+
#         }
#       break;
#     case 0x38:
#@@ -3589,7 +3589,7 @@ rx_decode_opcode (unsigned long pc AU,
#           SYNTAX("bra.w	%a0");
# #line 743 "rx-decode.opc"
#           ID(branch); DC(pc + IMMex(2));
#-        
#+
#         }
#       break;
#     case 0x39:
#@@ -3604,7 +3604,7 @@ rx_decode_opcode (unsigned long pc AU,
#           SYNTAX("bsr.w	%a0");
# #line 759 "rx-decode.opc"
#           ID(jsr); DC(pc + IMMex(2));
#-        
#+
#         }
#       break;
#     case 0x3a:
#@@ -3623,8 +3623,8 @@ rx_decode_opcode (unsigned long pc AU,
#           SYNTAX("b%1.w	%a0");
# #line 733 "rx-decode.opc"
#           ID(branch); Scc(c); DC(pc + IMMex (2));
#-        
#-        
#+
#+
#         }
#       break;
#     case 0x3c:
#@@ -3656,7 +3656,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("mov%s	#%1, %0");
# #line 307 "rx-decode.opc"
#                 ID(mov); sBWL (sz); DIs(dst, d*16+sppp, sz); SC(IMM(1)); F_____;
#-              
#+
#               }
#             break;
#         }
#@@ -3701,10 +3701,10 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("rtsd	#%1, %2-%0");
# #line 404 "rx-decode.opc"
#                 ID(rtsd); SC(IMM(1) * 4); S2R(rega); DR(regb);
#-              
#+
#               /*----------------------------------------------------------------------*/
#               /* AND									*/
#-              
#+
#               }
#             break;
#         }
#@@ -3735,7 +3735,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("sub	%2%S2, %1");
# #line 539 "rx-decode.opc"
#                 ID(sub); S2P(ss, rsrc); SR(rdst); DR(rdst); F_OSZC;
#-              
#+
#               }
#             break;
#         }
#@@ -3793,7 +3793,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("cmp	%2%S2, %1");
# #line 527 "rx-decode.opc"
#                 ID(sub); S2P(ss, rsrc); SR(rdst); F_OSZC;
#-              
#+
#               }
#             break;
#         }
#@@ -3851,7 +3851,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("add	%1%S1, %0");
# #line 503 "rx-decode.opc"
#                 ID(add); SP(ss, rsrc); DR(rdst); F_OSZC;
#-              
#+
#               }
#             break;
#         }
#@@ -3909,7 +3909,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("mul	%1%S1, %0");
# #line 608 "rx-decode.opc"
#                 ID(mul); SP(ss, rsrc); DR(rdst); F_____;
#-              
#+
#               }
#             break;
#         }
#@@ -3967,7 +3967,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("and	%1%S1, %0");
# #line 416 "rx-decode.opc"
#                 ID(and); SP(ss, rsrc); DR(rdst); F__SZ_;
#-              
#+
#               }
#             break;
#         }
#@@ -4025,7 +4025,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("or	%1%S1, %0");
# #line 434 "rx-decode.opc"
#                 ID(or); SP(ss, rsrc); DR(rdst); F__SZ_;
#-              
#+
#               }
#             break;
#         }
#@@ -4086,7 +4086,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("movu%s	%1, %0");
# #line 355 "rx-decode.opc"
#                 ID(mov); uBWL(s); SD(ss, rsrc, s); DR(rdst); F_____;
#-              
#+
#               }
#             break;
#         }
#@@ -4176,7 +4176,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("sub	#%2, %0");
# #line 536 "rx-decode.opc"
#                 ID(sub); S2C(immm); SR(rdst); DR(rdst); F_OSZC;
#-              
#+
#               }
#             break;
#         }
#@@ -4203,7 +4203,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("cmp	#%2, %1");
# #line 518 "rx-decode.opc"
#                 ID(sub); S2C(immm); SR(rdst); F_OSZC;
#-              
#+
#               }
#             break;
#         }
#@@ -4230,7 +4230,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("add	#%1, %0");
# #line 500 "rx-decode.opc"
#                 ID(add); SC(immm); DR(rdst); F_OSZC;
#-              
#+
#               }
#             break;
#         }
#@@ -4257,7 +4257,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("mul	#%1, %0");
# #line 602 "rx-decode.opc"
#                 ID(mul); DR(rdst); SC(immm); F_____;
#-              
#+
#               }
#             break;
#         }
#@@ -4284,7 +4284,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("and	#%1, %0");
# #line 410 "rx-decode.opc"
#                 ID(and); SC(immm); DR(rdst); F__SZ_;
#-              
#+
#               }
#             break;
#         }
#@@ -4311,7 +4311,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("or	#%1, %0");
# #line 428 "rx-decode.opc"
#                 ID(or); SC(immm); DR(rdst); F__SZ_;
#-              
#+
#               }
#             break;
#         }
#@@ -4338,7 +4338,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("mov%s	#%1, %0");
# #line 304 "rx-decode.opc"
#                 ID(mov); DR(rdst); SC(immm); F_____;
#-              
#+
#               }
#             break;
#         }
#@@ -4355,7 +4355,7 @@ rx_decode_opcode (unsigned long pc AU,
#           SYNTAX("rtsd	#%1");
# #line 401 "rx-decode.opc"
#           ID(rtsd); SC(IMM(1) * 4);
#-        
#+
#         }
#       break;
#     case 0x68:
#@@ -4384,7 +4384,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("shlr	#%2, %0");
# #line 688 "rx-decode.opc"
#                 ID(shlr); S2C(i*16+mmmm); SR(rdst); DR(rdst); F__SZC;
#-              
#+
#               }
#             break;
#         }
#@@ -4424,7 +4424,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("shar	#%2, %0");
# #line 678 "rx-decode.opc"
#                 ID(shar); S2C(i*16+mmmm); SR(rdst); DR(rdst); F_0SZC;
#-              
#+
#               }
#             break;
#         }
#@@ -4464,7 +4464,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("shll	#%2, %0");
# #line 668 "rx-decode.opc"
#                 ID(shll); S2C(i*16+mmmm); SR(rdst); DR(rdst); F_OSZC;
#-              
#+
#               }
#             break;
#         }
#@@ -4500,7 +4500,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("pushm	%1-%2");
# #line 368 "rx-decode.opc"
#                 ID(pushm); SR(dsta); S2R(dstb); F_____;
#-                
#+
#               }
#             break;
#         }
#@@ -4527,7 +4527,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("popm	%1-%2");
# #line 365 "rx-decode.opc"
#                 ID(popm); SR(dsta); S2R(dstb); F_____;
#-              
#+
#               }
#             break;
#         }
#@@ -4558,7 +4558,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("add	#%1, %2, %0");
# #line 509 "rx-decode.opc"
#                 ID(add); SC(IMMex(im)); S2R(rsrc); DR(rdst); F_OSZC;
#-              
#+
#               }
#             break;
#         }
#@@ -4613,7 +4613,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("cmp	#%2, %1%S1");
# #line 521 "rx-decode.opc"
#                 ID(sub); SR(rsrc); S2C(IMMex(im)); F_OSZC;
#-              
#+
#               }
#             break;
#           case 0x10:
#@@ -4635,7 +4635,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("mul	#%1, %0");
# #line 605 "rx-decode.opc"
#                 ID(mul); DR(rdst); SC(IMMex(im)); F_____;
#-              
#+
#               }
#             break;
#           case 0x20:
#@@ -4657,7 +4657,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("and	#%1, %0");
# #line 413 "rx-decode.opc"
#                 ID(and); SC(IMMex(im)); DR(rdst); F__SZ_;
#-              
#+
#               }
#             break;
#           case 0x30:
#@@ -4679,7 +4679,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("or	#%1, %0");
# #line 431 "rx-decode.opc"
#                 ID(or); SC(IMMex(im)); DR(rdst); F__SZ_;
#-              
#+
#               }
#             break;
#           default: UNSUPPORTED(); break;
#@@ -4791,7 +4791,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("mov%s	#%1, %0");
# #line 285 "rx-decode.opc"
#                 ID(mov); DR(rdst); SC(IMM (1)); F_____;
#-              
#+
#               }
#             break;
#           case 0x50:
#@@ -4824,7 +4824,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("cmp	#%2, %1");
# #line 524 "rx-decode.opc"
#                 ID(sub); SR(rsrc); S2C(IMM(1)); F_OSZC;
#-              
#+
#               }
#             break;
#           case 0x60:
#@@ -4839,7 +4839,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("int #%1");
# #line 993 "rx-decode.opc"
#                 ID(int); SC(IMM(1));
#-              
#+
#               }
#             break;
#           case 0x70:
#@@ -4861,7 +4861,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("mvtipl	#%1");
# #line 960 "rx-decode.opc"
#                       ID(mvtipl); SC(immm);
#-                    
#+
#                     }
#                   break;
#                 default: UNSUPPORTED(); break;
#@@ -4934,8 +4934,8 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("bset	#%1, %0");
# #line 905 "rx-decode.opc"
#                 ID(bset); BWL(LSIZE); SC(b*16+ittt); DR(rdst); F_____;
#-              
#-              
#+
#+
#               }
#             break;
#         }
#@@ -4975,8 +4975,8 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("bclr	#%1, %0");
# #line 917 "rx-decode.opc"
#                 ID(bclr); BWL(LSIZE); SC(b*16+ittt); DR(rdst); F_____;
#-              
#-              
#+
#+
#               }
#             break;
#         }
#@@ -5016,8 +5016,8 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("btst	#%2, %1");
# #line 929 "rx-decode.opc"
#                 ID(btst); BWL(LSIZE); S2C(b*16+ittt); SR(rdst); F___ZC;
#-              
#-              
#+
#+
#               }
#             break;
#         }
#@@ -5050,7 +5050,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("not	%0");
# #line 458 "rx-decode.opc"
#                 ID(xor); DR(rdst); SR(rdst); S2C(~0); F__SZ_;
#-              
#+
#               }
#             break;
#           case 0x10:
#@@ -5068,7 +5068,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("neg	%0");
# #line 479 "rx-decode.opc"
#                 ID(sub); DR(rdst); SC(0); S2R(rdst); F_OSZC;
#-              
#+
#               }
#             break;
#           case 0x20:
#@@ -5086,7 +5086,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("abs	%0");
# #line 561 "rx-decode.opc"
#                 ID(abs); DR(rdst); SR(rdst); F_OSZ_;
#-              
#+
#               }
#             break;
#           case 0x30:
#@@ -5104,7 +5104,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("sat	%0");
# #line 843 "rx-decode.opc"
#                 ID(sat); DR (rdst);
#-              
#+
#               }
#             break;
#           case 0x40:
#@@ -5122,7 +5122,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("rorc	%0");
# #line 703 "rx-decode.opc"
#                 ID(rorc); DR(rdst); F__SZC;
#-              
#+
#               }
#             break;
#           case 0x50:
#@@ -5140,7 +5140,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("rolc	%0");
# #line 700 "rx-decode.opc"
#                 ID(rolc); DR(rdst); F__SZC;
#-              
#+
#               }
#             break;
#           case 0x80:
#@@ -5163,7 +5163,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("push%s	%1");
# #line 374 "rx-decode.opc"
#                 ID(mov); BWL(sz); OP(0, RX_Operand_Predec, 0, 0); SR(rsrc); F_____;
#-              
#+
#               }
#             break;
#           case 0xb0:
#@@ -5181,7 +5181,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("pop	%0");
# #line 371 "rx-decode.opc"
#                 ID(mov); OP(1, RX_Operand_Postinc, 0, 0); DR(rdst); F_____;
#-                
#+
#               }
#             break;
#           case 0xc0:
#@@ -5200,7 +5200,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("pushc	%1");
# #line 966 "rx-decode.opc"
#                 ID(mov); OP(0, RX_Operand_Predec, 0, 0); SR(crsrc + 16);
#-              
#+
#               }
#             break;
#           case 0xe0:
#@@ -5219,7 +5219,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("popc	%0");
# #line 963 "rx-decode.opc"
#                 ID(mov); OP(1, RX_Operand_Postinc, 0, 0); DR(crdst + 16);
#-              
#+
#               }
#             break;
#           default: UNSUPPORTED(); break;
#@@ -5259,7 +5259,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("jmp	%0");
# #line 753 "rx-decode.opc"
#                 ID(branch); DR(rsrc);
#-              
#+
#               }
#             break;
#           case 0x10:
#@@ -5292,7 +5292,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("jsr	%0");
# #line 756 "rx-decode.opc"
#                 ID(jsr); DR(rsrc);
#-              
#+
#               }
#             break;
#           case 0x40:
#@@ -5325,8 +5325,8 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("bra.l	%0");
# #line 749 "rx-decode.opc"
#                 ID(branchrel); DR(rsrc);
#-              
#-              
#+
#+
#               }
#             break;
#           case 0x50:
#@@ -5359,7 +5359,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("bsr.l	%0");
# #line 765 "rx-decode.opc"
#                 ID(jsrrel); DR(rsrc);
#-              
#+
#               }
#             break;
#           case 0x80:
#@@ -5379,7 +5379,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("suntil%s");
# #line 789 "rx-decode.opc"
#                 ID(suntil); BWL(sz); F___ZC;
#-              
#+
#               }
#             break;
#           case 0x83:
#@@ -5394,7 +5394,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("scmpu");
# #line 780 "rx-decode.opc"
#                 ID(scmpu); F___ZC;
#-              
#+
#               }
#             break;
#           case 0x84:
#@@ -5414,7 +5414,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("swhile%s");
# #line 792 "rx-decode.opc"
#                 ID(swhile); BWL(sz); F___ZC;
#-              
#+
#               }
#             break;
#           case 0x87:
#@@ -5429,7 +5429,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("smovu");
# #line 783 "rx-decode.opc"
#                 ID(smovu);
#-              
#+
#               }
#             break;
#           case 0x88:
#@@ -5449,10 +5449,10 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("sstr%s");
# #line 798 "rx-decode.opc"
#                 ID(sstr); BWL(sz);
#-              
#+
#               /*----------------------------------------------------------------------*/
#               /* RMPA									*/
#-              
#+
#               }
#             break;
#           case 0x8b:
#@@ -5467,7 +5467,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("smovb");
# #line 786 "rx-decode.opc"
#                 ID(smovb);
#-              
#+
#               }
#             break;
#           case 0x8c:
#@@ -5487,10 +5487,10 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("rmpa%s");
# #line 804 "rx-decode.opc"
#                 ID(rmpa); BWL(sz); F_OS__;
#-              
#+
#               /*----------------------------------------------------------------------*/
#               /* HI/LO stuff								*/
#-              
#+
#               }
#             break;
#           case 0x8f:
#@@ -5505,7 +5505,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("smovf");
# #line 795 "rx-decode.opc"
#                 ID(smovf);
#-              
#+
#               }
#             break;
#           case 0x93:
#@@ -5520,10 +5520,10 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("satr");
# #line 846 "rx-decode.opc"
#                 ID(satr);
#-              
#+
#               /*----------------------------------------------------------------------*/
#               /* FLOAT								*/
#-              
#+
#               }
#             break;
#           case 0x94:
#@@ -5538,7 +5538,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("rtfi");
# #line 981 "rx-decode.opc"
#                 ID(rtfi);
#-              
#+
#               }
#             break;
#           case 0x95:
#@@ -5553,7 +5553,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("rte");
# #line 984 "rx-decode.opc"
#                 ID(rte);
#-              
#+
#               }
#             break;
#           case 0x96:
#@@ -5568,10 +5568,10 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("wait");
# #line 996 "rx-decode.opc"
#                 ID(wait);
#-              
#+
#               /*----------------------------------------------------------------------*/
#               /* SCcnd								*/
#-              
#+
#               }
#             break;
#           case 0xa0:
#@@ -5604,7 +5604,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("setpsw	%0");
# #line 957 "rx-decode.opc"
#                 ID(setpsw); DF(rdst);
#-              
#+
#               }
#             break;
#           case 0xb0:
#@@ -5637,7 +5637,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("clrpsw	%0");
# #line 954 "rx-decode.opc"
#                 ID(clrpsw); DF(rdst);
#-              
#+
#               }
#             break;
#           default: UNSUPPORTED(); break;
#@@ -5678,7 +5678,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("mov%s	%1, %0");
# #line 332 "rx-decode.opc"
#                 ID(mov); sBWL(sz); DIs(dst, dsp*4+a*2+b, sz); SR(src); F_____;
#-              
#+
#               }
#             break;
#         }
#@@ -5781,7 +5781,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("mov%s	%1, %0");
# #line 329 "rx-decode.opc"
#                 ID(mov); sBWL(sz); DR(dst); SIs(src, dsp*4+a*2+b, sz); F_____;
#-              
#+
#               }
#             break;
#         }
#@@ -6172,7 +6172,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("movu%s	%1, %0");
# #line 352 "rx-decode.opc"
#                 ID(mov); uBWL(w); DR(dst); SIs(src, dsp*4+a*2+b, w); F_____;
#-              
#+
#               }
#             break;
#         }
#@@ -6360,7 +6360,7 @@ rx_decode_opcode (unsigned long pc AU,
#               	  SD(ss, rsrc, sz); DD(sd, rdst, sz);
#               	}
#                   }
#-              
#+
#               }
#             break;
#         }
#@@ -6814,7 +6814,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("bset	#%1, %0%S0");
# #line 897 "rx-decode.opc"
#                 ID(bset); BWL(BSIZE); SC(bit); DD(sd, rdst, BSIZE); F_____;
#-              
#+
#               }
#             break;
#           case 0x08:
#@@ -6839,7 +6839,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("bclr	#%1, %0%S0");
# #line 909 "rx-decode.opc"
#                 ID(bclr); BWL(BSIZE); SC(bit); DD(sd, rdst, BSIZE); F_____;
#-              
#+
#               }
#             break;
#         }
#@@ -6907,7 +6907,7 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("btst	#%2, %1%S1");
# #line 921 "rx-decode.opc"
#                 ID(btst); BWL(BSIZE); S2C(bit); SD(sd, rdst, BSIZE); F___ZC;
#-              
#+
#               }
#             break;
#           case 0x08:
#@@ -6932,10 +6932,10 @@ rx_decode_opcode (unsigned long pc AU,
#                 SYNTAX("push%s	%1");
# #line 377 "rx-decode.opc"
#                 ID(mov); BWL(sz); OP(0, RX_Operand_Predec, 0, 0); SD(ss, rsrc, sz); F_____;
#-              
#+
#               /*----------------------------------------------------------------------*/
#               /* XCHG									*/
#-              
#+
#               }
#             break;
#           default: UNSUPPORTED(); break;
#@@ -7025,7 +7025,7 @@ rx_decode_opcode (unsigned long pc AU,
#                     SC(IMMex(im));
#                   }
#                  F_____;
#-              
#+
#               }
#             break;
#         }
#@@ -7083,7 +7083,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("sbb	%1, %0");
# #line 551 "rx-decode.opc"
#                       ID(sbb); SR (rsrc); DR(rdst); F_OSZC;
#-                    
#+
#                       /* FIXME: only supports .L */
#                     }
#                   break;
#@@ -7111,10 +7111,10 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("neg	%2, %0");
# #line 482 "rx-decode.opc"
#                       ID(sub); DR(rdst); SC(0); S2R(rsrc); F_OSZC;
#-                    
#+
#                     /*----------------------------------------------------------------------*/
#                     /* ADC									*/
#-                    
#+
#                     }
#                   break;
#               }
#@@ -7141,7 +7141,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("adc	%1, %0");
# #line 491 "rx-decode.opc"
#                       ID(adc); SR(rsrc); DR(rdst); F_OSZC;
#-                    
#+
#                     }
#                   break;
#               }
#@@ -7168,10 +7168,10 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("abs	%1, %0");
# #line 564 "rx-decode.opc"
#                       ID(abs); DR(rdst); SR(rsrc); F_OSZ_;
#-                    
#+
#                     /*----------------------------------------------------------------------*/
#                     /* MAX									*/
#-                    
#+
#                     }
#                   break;
#               }
#@@ -7210,7 +7210,7 @@ rx_decode_opcode (unsigned long pc AU,
#                         {
#                           ID(max); SP(ss, rsrc); DR(rdst);
#                         }
#-                    
#+
#                     }
#                   break;
#               }
#@@ -7268,7 +7268,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("min	%1%S1, %0");
# #line 593 "rx-decode.opc"
#                       ID(min); SP(ss, rsrc); DR(rdst);
#-                    
#+
#                     }
#                   break;
#               }
#@@ -7326,7 +7326,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("emul	%1%S1, %0");
# #line 623 "rx-decode.opc"
#                       ID(emul); SP(ss, rsrc); DR(rdst);
#-                    
#+
#                     }
#                   break;
#               }
#@@ -7384,7 +7384,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("emulu	%1%S1, %0");
# #line 635 "rx-decode.opc"
#                       ID(emulu); SP(ss, rsrc); DR(rdst);
#-                    
#+
#                     }
#                   break;
#               }
#@@ -7442,7 +7442,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("div	%1%S1, %0");
# #line 647 "rx-decode.opc"
#                       ID(div); SP(ss, rsrc); DR(rdst); F_O___;
#-                    
#+
#                     }
#                   break;
#               }
#@@ -7500,7 +7500,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("divu	%1%S1, %0");
# #line 659 "rx-decode.opc"
#                       ID(divu); SP(ss, rsrc); DR(rdst); F_O___;
#-                    
#+
#                     }
#                   break;
#               }
#@@ -7558,7 +7558,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("tst	%1%S1, %2");
# #line 470 "rx-decode.opc"
#                       ID(and); SP(ss, rsrc); S2R(rdst); F__SZ_;
#-                    
#+
#                     }
#                   break;
#               }
#@@ -7616,7 +7616,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("xor	%1%S1, %0");
# #line 449 "rx-decode.opc"
#                       ID(xor); SP(ss, rsrc); DR(rdst); F__SZ_;
#-                    
#+
#                     }
#                   break;
#               }
#@@ -7670,10 +7670,10 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("not	%1, %0");
# #line 461 "rx-decode.opc"
#                       ID(xor); DR(rdst); SR(rsrc); S2C(~0); F__SZ_;
#-                    
#+
#                     /*----------------------------------------------------------------------*/
#                     /* TST									*/
#-                    
#+
#                     }
#                   break;
#               }
#@@ -7704,7 +7704,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("xchg	%1%S1, %0");
# #line 383 "rx-decode.opc"
#                       ID(xchg); DR(rdst); SP(ss, rsrc);
#-                    
#+
#                     }
#                   break;
#               }
#@@ -7762,7 +7762,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("itof	%1%S1, %0");
# #line 888 "rx-decode.opc"
#                       ID(itof); DR (rdst); SP(sd, rsrc); F__SZ_;
#-                    
#+
#                     }
#                   break;
#               }
#@@ -7822,7 +7822,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       ID(bset); BWL(BSIZE); SR(rsrc); DD(sd, rdst, BSIZE); F_____;
#                       if (sd == 3) /* bset reg,reg */
#                         BWL(LSIZE);
#-                    
#+
#                     }
#                   break;
#               }
#@@ -7882,7 +7882,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       ID(bclr); BWL(BSIZE); SR(rsrc); DD(sd, rdst, BSIZE); F_____;
#                       if (sd == 3) /* bset reg,reg */
#                         BWL(LSIZE);
#-                    
#+
#                     }
#                   break;
#               }
#@@ -7942,7 +7942,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       ID(btst); BWL(BSIZE); S2R(rsrc); SD(sd, rdst, BSIZE); F___ZC;
#                       if (sd == 3) /* bset reg,reg */
#                         BWL(LSIZE);
#-                    
#+
#                     }
#                   break;
#               }
#@@ -8002,7 +8002,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       ID(bnot); BWL(BSIZE); SR(rsrc); DD(sd, rdst, BSIZE);
#                       if (sd == 3) /* bset reg,reg */
#                         BWL(LSIZE);
#-                    
#+
#                     }
#                   break;
#               }
#@@ -8060,7 +8060,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("fsub	%1%S1, %0");
# #line 867 "rx-decode.opc"
#                       ID(fsub); DR(rdst); SD(sd, rsrc, LSIZE); F__SZ_;
#-                    
#+
#                     }
#                   break;
#               }
#@@ -8118,7 +8118,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("fcmp	%1%S1, %0");
# #line 861 "rx-decode.opc"
#                       ID(fcmp); DR(rdst); SD(sd, rsrc, LSIZE); F_OSZ_;
#-                    
#+
#                     }
#                   break;
#               }
#@@ -8176,7 +8176,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("fadd	%1%S1, %0");
# #line 855 "rx-decode.opc"
#                       ID(fadd); DR(rdst); SD(sd, rsrc, LSIZE); F__SZ_;
#-                    
#+
#                     }
#                   break;
#               }
#@@ -8234,7 +8234,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("fmul	%1%S1, %0");
# #line 876 "rx-decode.opc"
#                       ID(fmul); DR(rdst); SD(sd, rsrc, LSIZE); F__SZ_;
#-                    
#+
#                     }
#                   break;
#               }
#@@ -8292,7 +8292,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("fdiv	%1%S1, %0");
# #line 882 "rx-decode.opc"
#                       ID(fdiv); DR(rdst); SD(sd, rsrc, LSIZE); F__SZ_;
#-                    
#+
#                     }
#                   break;
#               }
#@@ -8350,7 +8350,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("ftoi	%1%S1, %0");
# #line 870 "rx-decode.opc"
#                       ID(ftoi); DR(rdst); SD(sd, rsrc, LSIZE); F__SZ_;
#-                    
#+
#                     }
#                   break;
#               }
#@@ -8408,7 +8408,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("round	%1%S1, %0");
# #line 885 "rx-decode.opc"
#                       ID(round); DR(rdst); SD(sd, rsrc, LSIZE); F__SZ_;
#-                    
#+
#                     }
#                   break;
#               }
#@@ -8469,7 +8469,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("sc%1%s	%0");
# #line 1002 "rx-decode.opc"
#                       ID(sccnd); BWL(sz); DD (sd, rdst, sz); Scc(cond);
#-                    
#+
#                     }
#                   break;
#               }
#@@ -8616,7 +8616,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("bm%2	#%1, %0%S0");
# #line 945 "rx-decode.opc"
#                       ID(bmcc); BWL(BSIZE); S2cc(cond); SC(bit); DD(sd, rdst, BSIZE);
#-                    
#+
#                     }
#                   break;
#                 case 0x0f:
#@@ -8641,7 +8641,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("bnot	#%1, %0%S0");
# #line 933 "rx-decode.opc"
#                       ID(bnot); BWL(BSIZE); SC(bit); DD(sd, rdst, BSIZE);
#-                    
#+
#                     }
#                   break;
#               }
#@@ -9481,7 +9481,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("mulhi	%1, %2");
# #line 810 "rx-decode.opc"
#                       ID(mulhi); SR(srca); S2R(srcb); F_____;
#-                    
#+
#                     }
#                   break;
#               }
#@@ -9508,7 +9508,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("mullo	%1, %2");
# #line 813 "rx-decode.opc"
#                       ID(mullo); SR(srca); S2R(srcb); F_____;
#-                    
#+
#                     }
#                   break;
#               }
#@@ -9535,7 +9535,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("machi	%1, %2");
# #line 816 "rx-decode.opc"
#                       ID(machi); SR(srca); S2R(srcb); F_____;
#-                    
#+
#                     }
#                   break;
#               }
#@@ -9562,7 +9562,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("maclo	%1, %2");
# #line 819 "rx-decode.opc"
#                       ID(maclo); SR(srca); S2R(srcb); F_____;
#-                    
#+
#                     }
#                   break;
#               }
#@@ -9586,7 +9586,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("mvtachi	%1");
# #line 822 "rx-decode.opc"
#                       ID(mvtachi); SR(rsrc); F_____;
#-                    
#+
#                     }
#                   break;
#                 case 0x10:
#@@ -9604,7 +9604,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("mvtaclo	%1");
# #line 825 "rx-decode.opc"
#                       ID(mvtaclo); SR(rsrc); F_____;
#-                    
#+
#                     }
#                   break;
#                 default: UNSUPPORTED(); break;
#@@ -9629,10 +9629,10 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("racw	#%1");
# #line 837 "rx-decode.opc"
#                       ID(racw); SC(i+1); F_____;
#-                    
#+
#                     /*----------------------------------------------------------------------*/
#                     /* SAT									*/
#-                    
#+
#                     }
#                   break;
#                 default: UNSUPPORTED(); break;
#@@ -9657,7 +9657,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("mvfachi	%0");
# #line 828 "rx-decode.opc"
#                       ID(mvfachi); DR(rdst); F_____;
#-                    
#+
#                     }
#                   break;
#                 case 0x10:
#@@ -9675,7 +9675,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("mvfaclo	%0");
# #line 834 "rx-decode.opc"
#                       ID(mvfaclo); DR(rdst); F_____;
#-                    
#+
#                     }
#                   break;
#                 case 0x20:
#@@ -9693,7 +9693,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("mvfacmi	%0");
# #line 831 "rx-decode.opc"
#                       ID(mvfacmi); DR(rdst); F_____;
#-                    
#+
#                     }
#                   break;
#                 default: UNSUPPORTED(); break;
#@@ -9729,7 +9729,7 @@ rx_decode_opcode (unsigned long pc AU,
# #line 344 "rx-decode.opc"
#                       ID(mov); sBWL (sz); SR(rsrc); F_____;
#                       OP(0, p ? RX_Operand_Predec : RX_Operand_Postinc, rdst, 0);
#-                    
#+
#                     }
#                   break;
#               }
#@@ -9809,7 +9809,7 @@ rx_decode_opcode (unsigned long pc AU,
# #line 348 "rx-decode.opc"
#                       ID(mov); sBWL (sz); DR(rdst); F_____;
#                       OP(1, p ? RX_Operand_Predec : RX_Operand_Postinc, rsrc, 0);
#-                    
#+
#                     }
#                   break;
#               }
#@@ -9889,10 +9889,10 @@ rx_decode_opcode (unsigned long pc AU,
# #line 358 "rx-decode.opc"
#                       ID(mov); uBWL (sz); DR(rdst); F_____;
#                        OP(1, p ? RX_Operand_Predec : RX_Operand_Postinc, rsrc, 0);
#-                    
#+
#                     /*----------------------------------------------------------------------*/
#                     /* PUSH/POP								*/
#-                    
#+
#                     }
#                   break;
#               }
#@@ -9964,7 +9964,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("shlr	%2, %0");
# #line 691 "rx-decode.opc"
#                       ID(shlr); S2R(rsrc); SR(rdst); DR(rdst); F__SZC;
#-                    
#+
#                     }
#                   break;
#               }
#@@ -9991,7 +9991,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("shar	%2, %0");
# #line 681 "rx-decode.opc"
#                       ID(shar); S2R(rsrc); SR(rdst); DR(rdst); F_0SZC;
#-                    
#+
#                     }
#                   break;
#               }
#@@ -10018,7 +10018,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("shll	%2, %0");
# #line 671 "rx-decode.opc"
#                       ID(shll); S2R(rsrc); SR(rdst); DR(rdst); F_OSZC;
#-                    
#+
#                     }
#                   break;
#               }
#@@ -10045,7 +10045,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("rotr	%1, %0");
# #line 715 "rx-decode.opc"
#                       ID(rotr); SR(rsrc); DR(rdst); F__SZC;
#-                    
#+
#                     }
#                   break;
#               }
#@@ -10072,7 +10072,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("revw	%1, %0");
# #line 718 "rx-decode.opc"
#                       ID(revw); SR(rsrc); DR(rdst);
#-                    
#+
#                     }
#                   break;
#               }
#@@ -10099,7 +10099,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("rotl	%1, %0");
# #line 709 "rx-decode.opc"
#                       ID(rotl); SR(rsrc); DR(rdst); F__SZC;
#-                    
#+
#                     }
#                   break;
#               }
#@@ -10126,10 +10126,10 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("revl	%1, %0");
# #line 721 "rx-decode.opc"
#                       ID(revl); SR(rsrc); DR(rdst);
#-                    
#+
#                     /*----------------------------------------------------------------------*/
#                     /* BRANCH								*/
#-                    
#+
#                     }
#                   break;
#               }
#@@ -10160,7 +10160,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("mvtc	%1, %0");
# #line 972 "rx-decode.opc"
#                       ID(mov); SR(rsrc); DR(c*16+rdst + 16);
#-                    
#+
#                     }
#                   break;
#               }
#@@ -10200,10 +10200,10 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("mvfc	%1, %0");
# #line 975 "rx-decode.opc"
#                       ID(mov); SR((s*16+rsrc) + 16); DR(rdst);
#-                    
#+
#                     /*----------------------------------------------------------------------*/
#                     /* INTERRUPTS								*/
#-                    
#+
#                     }
#                   break;
#               }
#@@ -10243,7 +10243,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("rotr	#%1, %0");
# #line 712 "rx-decode.opc"
#                       ID(rotr); SC(i*16+mmmm); DR(rdst); F__SZC;
#-                    
#+
#                     }
#                   break;
#               }
#@@ -10283,7 +10283,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("rotl	#%1, %0");
# #line 706 "rx-decode.opc"
#                       ID(rotl); SC(i*16+mmmm); DR(rdst); F__SZC;
#-                    
#+
#                     }
#                   break;
#               }
#@@ -10320,7 +10320,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("adc	#%1, %0");
# #line 488 "rx-decode.opc"
#                       ID(adc); SC(IMMex(im)); DR(rdst); F_OSZC;
#-                    
#+
#                     }
#                   break;
#                 case 0x40:
#@@ -10342,7 +10342,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("max	#%1, %0");
# #line 570 "rx-decode.opc"
#                       ID(max); DR(rdst); SC(IMMex(im));
#-                    
#+
#                     }
#                   break;
#                 case 0x50:
#@@ -10364,7 +10364,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("min	#%1, %0");
# #line 590 "rx-decode.opc"
#                       ID(min); DR(rdst); SC(IMMex(im));
#-                    
#+
#                     }
#                   break;
#                 case 0x60:
#@@ -10386,7 +10386,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("emul	#%1, %0");
# #line 620 "rx-decode.opc"
#                       ID(emul); DR(rdst); SC(IMMex(im));
#-                    
#+
#                     }
#                   break;
#                 case 0x70:
#@@ -10408,7 +10408,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("emulu	#%1, %0");
# #line 632 "rx-decode.opc"
#                       ID(emulu); DR(rdst); SC(IMMex(im));
#-                    
#+
#                     }
#                   break;
#                 case 0x80:
#@@ -10430,7 +10430,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("div	#%1, %0");
# #line 644 "rx-decode.opc"
#                       ID(div); DR(rdst); SC(IMMex(im)); F_O___;
#-                    
#+
#                     }
#                   break;
#                 case 0x90:
#@@ -10452,7 +10452,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("divu	#%1, %0");
# #line 656 "rx-decode.opc"
#                       ID(divu); DR(rdst); SC(IMMex(im)); F_O___;
#-                    
#+
#                     }
#                   break;
#                 case 0xc0:
#@@ -10474,7 +10474,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("tst	#%1, %2");
# #line 467 "rx-decode.opc"
#                       ID(and); SC(IMMex(im)); S2R(rdst); F__SZ_;
#-                    
#+
#                     }
#                   break;
#                 case 0xd0:
#@@ -10496,7 +10496,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("xor	#%1, %0");
# #line 446 "rx-decode.opc"
#                       ID(xor); SC(IMMex(im)); DR(rdst); F__SZ_;
#-                    
#+
#                     }
#                   break;
#                 case 0xe0:
#@@ -10518,7 +10518,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("stz	#%1, %0");
# #line 392 "rx-decode.opc"
#                       ID(stcc); SC(IMMex(im)); DR(rdst); S2cc(RXC_z);
#-                    
#+
#                     }
#                   break;
#                 case 0xf0:
#@@ -10540,10 +10540,10 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("stnz	#%1, %0");
# #line 395 "rx-decode.opc"
#                       ID(stcc); SC(IMMex(im)); DR(rdst); S2cc(RXC_nz);
#-                    
#+
#                     /*----------------------------------------------------------------------*/
#                     /* RTSD									*/
#-                    
#+
#                     }
#                   break;
#                 default: UNSUPPORTED(); break;
#@@ -10568,7 +10568,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("fsub	#%1, %0");
# #line 864 "rx-decode.opc"
#                       ID(fsub); DR(rdst); SC(IMM(0)); F__SZ_;
#-                    
#+
#                     }
#                   break;
#                 case 0x10:
#@@ -10586,7 +10586,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("fcmp	#%1, %0");
# #line 858 "rx-decode.opc"
#                       ID(fcmp); DR(rdst); SC(IMM(0)); F_OSZ_;
#-                    
#+
#                     }
#                   break;
#                 case 0x20:
#@@ -10604,7 +10604,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("fadd	#%1, %0");
# #line 852 "rx-decode.opc"
#                       ID(fadd); DR(rdst); SC(IMM(0)); F__SZ_;
#-                    
#+
#                     }
#                   break;
#                 case 0x30:
#@@ -10622,7 +10622,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("fmul	#%1, %0");
# #line 873 "rx-decode.opc"
#                       ID(fmul); DR(rdst); SC(IMM(0)); F__SZ_;
#-                    
#+
#                     }
#                   break;
#                 case 0x40:
#@@ -10640,7 +10640,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("fdiv	#%1, %0");
# #line 879 "rx-decode.opc"
#                       ID(fdiv); DR(rdst); SC(IMM(0)); F__SZ_;
#-                    
#+
#                     }
#                   break;
#                 default: UNSUPPORTED(); break;
#@@ -10669,7 +10669,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("mvtc	#%1, %0");
# #line 969 "rx-decode.opc"
#                       ID(mov); SC(IMMex(im)); DR(crdst + 16);
#-                    
#+
#                     }
#                   break;
#                 default: UNSUPPORTED(); break;
#@@ -10851,10 +10851,10 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("shlr	#%2, %1, %0");
# #line 694 "rx-decode.opc"
#                       ID(shlr); S2C(immmm); SR(rsrc); DR(rdst); F__SZC;
#-                    
#+
#                     /*----------------------------------------------------------------------*/
#                     /* ROTATE								*/
#-                    
#+
#                     }
#                   break;
#               }
#@@ -11164,8 +11164,8 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("shar	#%2, %1, %0");
# #line 684 "rx-decode.opc"
#                       ID(shar); S2C(immmm); SR(rsrc); DR(rdst); F_0SZC;
#-                    
#-                    
#+
#+
#                     }
#                   break;
#               }
#@@ -11475,8 +11475,8 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("shll	#%2, %1, %0");
# #line 674 "rx-decode.opc"
#                       ID(shll); S2C(immmm); SR(rsrc); DR(rdst); F_OSZC;
#-                    
#-                    
#+
#+
#                     }
#                   break;
#               }
#@@ -11800,10 +11800,10 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("bm%2	#%1, %0%S0");
# #line 948 "rx-decode.opc"
#                       ID(bmcc); BWL(LSIZE); S2cc(cond); SC(bittt); DR(rdst);
#-                    
#+
#                     /*----------------------------------------------------------------------*/
#                     /* CONTROL REGISTERS							*/
#-                    
#+
#                     }
#                   break;
#                 case 0xf0:
#@@ -11825,8 +11825,8 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("bnot	#%1, %0");
# #line 941 "rx-decode.opc"
#                       ID(bnot); BWL(LSIZE); SC(bittt); DR(rdst);
#-                    
#-                    
#+
#+
#                     }
#                   break;
#               }
#@@ -12673,7 +12673,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("mov%s	%0, [%1, %2]");
# #line 338 "rx-decode.opc"
#                       ID(movbir); sBWL(sz); DR(rdst); SRR(isrc); S2R(bsrc); F_____;
#-                    
#+
#                     }
#                   break;
#               }
#@@ -13130,7 +13130,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("mov%s	[%1, %2], %0");
# #line 335 "rx-decode.opc"
#                       ID(movbi); sBWL(sz); DR(rdst); SRR(isrc); S2R(bsrc); F_____;
#-                    
#+
#                     }
#                   break;
#               }
#@@ -13587,7 +13587,7 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("movu%s	[%1, %2], %0");
# #line 341 "rx-decode.opc"
#                       ID(movbi); uBWL(sz); DR(rdst); SRR(isrc); S2R(bsrc); F_____;
#-                    
#+
#                     }
#                   break;
#               }
#@@ -14048,10 +14048,10 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("sub	%2, %1, %0");
# #line 545 "rx-decode.opc"
#                       ID(sub); DR(rdst); SR(srcb); S2R(srca); F_OSZC;
#-                    
#+
#                     /*----------------------------------------------------------------------*/
#                     /* SBB									*/
#-                    
#+
#                     }
#                   break;
#               }
#@@ -14217,10 +14217,10 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("add	%2, %1, %0");
# #line 512 "rx-decode.opc"
#                       ID(add); DR(rdst); SR(srcb); S2R(srca); F_OSZC;
#-                    
#+
#                     /*----------------------------------------------------------------------*/
#                     /* CMP									*/
#-                    
#+
#                     }
#                   break;
#               }
#@@ -14386,10 +14386,10 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("mul 	%2, %1, %0");
# #line 614 "rx-decode.opc"
#                       ID(mul); DR(rdst); SR(srcb); S2R(srca); F_____;
#-                    
#+
#                     /*----------------------------------------------------------------------*/
#                     /* EMUL									*/
#-                    
#+
#                     }
#                   break;
#               }
#@@ -14555,10 +14555,10 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("and	%2, %1, %0");
# #line 422 "rx-decode.opc"
#                       ID(and); DR(rdst); SR(srcb); S2R(srca); F__SZ_;
#-                    
#+
#                     /*----------------------------------------------------------------------*/
#                     /* OR									*/
#-                    
#+
#                     }
#                   break;
#               }
#@@ -14724,10 +14724,10 @@ rx_decode_opcode (unsigned long pc AU,
#                       SYNTAX("or	%2, %1, %0");
# #line 440 "rx-decode.opc"
#                       ID(or); DR(rdst); SR(srcb); S2R(srca); F__SZ_;
#-                    
#+
#                     /*----------------------------------------------------------------------*/
#                     /* XOR									*/
#-                    
#+
#                     }
#                   break;
#               }
#--- a/opcodes/rx-decode.opc
#+++ b/opcodes/rx-decode.opc
#@@ -65,7 +65,7 @@ static int ubwl[] =
#   RX_UByte,
#   RX_UWord,
#   RX_Long,
#-  0 /* Bogus instructions can have a size field set to 3.  */  
#+  0 /* Bogus instructions can have a size field set to 3.  */
# };
# 
# static int memex[] =
#@@ -249,7 +249,7 @@ rx_disp (int n, int type, int reg, int size, LocalData * ld)
# #define xZ 2
# #define xC 1
# 
#-#define F_____ 
#+#define F_____
# #define F___ZC rx->flags_0 = rx->flags_s = xZ|xC;
# #define F__SZ_ rx->flags_0 = rx->flags_s = xS|xZ;
# #define F__SZC rx->flags_0 = rx->flags_s = xS|xZ|xC;
#@@ -366,10 +366,10 @@ rx_decode_opcode (unsigned long pc AU,
# 
# /** 0110 1110 dsta dstb		pushm	%1-%2 */
#   ID(pushm); SR(dsta); S2R(dstb); F_____;
#-  
#+
# /** 0111 1110 1011 rdst		pop	%0 */
#   ID(mov); OP(1, RX_Operand_Postinc, 0, 0); DR(rdst); F_____;
#-  
#+
# /** 0111 1110 10sz rsrc		push%s	%1 */
#   ID(mov); BWL(sz); OP(0, RX_Operand_Predec, 0, 0); SR(rsrc); F_____;
# 
--- a/opcodes/score-dis.c
+++ b/opcodes/score-dis.c
@@ -35,7 +35,7 @@
 
 #ifdef BFD64
 /* s3_s7: opcodes and export prototypes.  */
-extern int 
+extern int
 s7_print_insn (bfd_vma pc, struct disassemble_info *info, bfd_boolean little);
 
 struct score_opcode
@@ -52,7 +52,7 @@ static struct score_opcode score_opcodes[] =
 {
   /* Score Instructions.  */
   {0x3800000a, 0x3e007fff, "abs\t\t%20-24r, %15-19r"},
-  {0x3800004b, 0x3e007fff, "abs.s\t\t%20-24r, %15-19r"},        
+  {0x3800004b, 0x3e007fff, "abs.s\t\t%20-24r, %15-19r"},
   {0x00000010, 0x3e0003ff, "add\t\t%20-24r, %15-19r, %10-14r"},
   {0x00000011, 0x3e0003ff, "add.c\t\t%20-24r, %15-19r, %10-14r"},
   {0x38000048, 0x3e0003ff, "add.s\t\t%20-24r, %15-19r, %10-14r"},
@@ -190,36 +190,36 @@ static struct score_opcode score_opcodes[] =
   {0x31e00000, 0x3ff00000, "cache\t\t%20-24d, [%15-19r, %0-14i]"},
   {0x31f00000, 0x3ff00000, "cache\t\t%20-24d, [%15-19r, %0-14i]"},
   {0x38000000, 0x3ff003ff, "mad\t\t%15-19r, %10-14r"},
-  {0x38000020, 0x3ff003ff, "madu\t\t%15-19r, %10-14r"},        
+  {0x38000020, 0x3ff003ff, "madu\t\t%15-19r, %10-14r"},
   {0x38000080, 0x3ff003ff, "mad.f\t\t%15-19r, %10-14r"},
-  {0x38000001, 0x3ff003ff, "msb\t\t%15-19r, %10-14r"},    
+  {0x38000001, 0x3ff003ff, "msb\t\t%15-19r, %10-14r"},
   {0x38000021, 0x3ff003ff, "msbu\t\t%15-19r, %10-14r"},
   {0x38000081, 0x3ff003ff, "msb.f\t\t%15-19r, %10-14r"},
-  {0x38000102, 0x3ff003ff, "mazl\t\t%15-19r, %10-14r"},        
-  {0x38000182, 0x3ff003ff, "mazl.f\t\t%15-19r, %10-14r"},        
-  {0x38000002, 0x3ff003ff, "madl\t\t%15-19r, %10-14r"},    
-  {0x380000c2, 0x3ff003ff, "madl.fs\t\t%15-19r, %10-14r"},        
-  {0x38000303, 0x3ff003ff, "mazh\t\t%15-19r, %10-14r"},    
-  {0x38000383, 0x3ff003ff, "mazh.f\t\t%15-19r, %10-14r"},    
-  {0x38000203, 0x3ff003ff, "madh\t\t%15-19r, %10-14r"},    
-  {0x380002c3, 0x3ff003ff, "madh.fs\t\t%15-19r, %10-14r"},    
-  {0x38000007, 0x3e0003ff, "max\t\t%20-24r, %15-19r, %10-14r"},    
-
-  {0x00000064, 0x3e00007e, "mbitclr\t\t[%15-19r, %m], %10-14d"},    
-  {0x0000006c, 0x3e00007e, "mbitset\t\t[%15-19r, %m], %10-14d"},    
+  {0x38000102, 0x3ff003ff, "mazl\t\t%15-19r, %10-14r"},
+  {0x38000182, 0x3ff003ff, "mazl.f\t\t%15-19r, %10-14r"},
+  {0x38000002, 0x3ff003ff, "madl\t\t%15-19r, %10-14r"},
+  {0x380000c2, 0x3ff003ff, "madl.fs\t\t%15-19r, %10-14r"},
+  {0x38000303, 0x3ff003ff, "mazh\t\t%15-19r, %10-14r"},
+  {0x38000383, 0x3ff003ff, "mazh.f\t\t%15-19r, %10-14r"},
+  {0x38000203, 0x3ff003ff, "madh\t\t%15-19r, %10-14r"},
+  {0x380002c3, 0x3ff003ff, "madh.fs\t\t%15-19r, %10-14r"},
+  {0x38000007, 0x3e0003ff, "max\t\t%20-24r, %15-19r, %10-14r"},
+
+  {0x00000064, 0x3e00007e, "mbitclr\t\t[%15-19r, %m], %10-14d"},
+  {0x0000006c, 0x3e00007e, "mbitset\t\t[%15-19r, %m], %10-14d"},
 
   {0x38000006, 0x3e0003ff, "min\t\t%20-24r, %15-19r, %10-14r"},
-  {0x38000104, 0x3ff003ff, "mszl\t\t%15-19r, %10-14r"},    
-  {0x38000184, 0x3ff003ff, "mszl.f\t\t%15-19r, %10-14r"},    
-  {0x38000004, 0x3ff003ff, "msbl\t\t%15-19r, %10-14r"},        
+  {0x38000104, 0x3ff003ff, "mszl\t\t%15-19r, %10-14r"},
+  {0x38000184, 0x3ff003ff, "mszl.f\t\t%15-19r, %10-14r"},
+  {0x38000004, 0x3ff003ff, "msbl\t\t%15-19r, %10-14r"},
   {0x380000c4, 0x3ff003ff, "msbl.fs\t\t%15-19r, %10-14r"},
-  {0x38000305, 0x3ff003ff, "mszh\t\t%15-19r, %10-14r"},        
-  {0x38000385, 0x3ff003ff, "mszh.f\t\t%15-19r, %10-14r"},    
-  {0x38000205, 0x3ff003ff, "msbh\t\t%15-19r, %10-14r"},        
-  {0x380002c5, 0x3ff003ff, "msbh.fs\t\t%15-19r, %10-14r"},        
-  {0x3800004e, 0x3e0003ff, "sll.s\t\t%20-24r, %15-19r, %10-14r"},                
-  {0x38000049, 0x3e0003ff, "sub.s\t\t%20-24r, %15-19r, %10-14r"},    
-  {0x0000001c, 0x3e007fff, "clz\t\t%20-24r, %15-19r"},    
+  {0x38000305, 0x3ff003ff, "mszh\t\t%15-19r, %10-14r"},
+  {0x38000385, 0x3ff003ff, "mszh.f\t\t%15-19r, %10-14r"},
+  {0x38000205, 0x3ff003ff, "msbh\t\t%15-19r, %10-14r"},
+  {0x380002c5, 0x3ff003ff, "msbh.fs\t\t%15-19r, %10-14r"},
+  {0x3800004e, 0x3e0003ff, "sll.s\t\t%20-24r, %15-19r, %10-14r"},
+  {0x38000049, 0x3e0003ff, "sub.s\t\t%20-24r, %15-19r, %10-14r"},
+  {0x0000001c, 0x3e007fff, "clz\t\t%20-24r, %15-19r"},
   {0x38000000, 0x3e000000, "ceinst\t\t%20-24d, %15-19r, %10-14r, %5-9d, %0-4d"},
   {0x00000019, 0x3ff003ff, "cmpteq.c\t\t%15-19r, %10-14r"},
   {0x00100019, 0x3ff003ff, "cmptmi.c\t\t%15-19r, %10-14r"},
@@ -285,15 +285,15 @@ static struct score_opcode score_opcodes[] =
   {0x0e000000, 0x3e000007, "lw\t\t%20-24r, [%15-19r]+, %3-14i"},
   {0x00001000, 0x00007000, "lw!\t\t%8-11r, [%5-7r,%0-4d2]"},
   {0x000000000002LL, 0x1c000000001fLL, "lw48\t\t%37-41r,[0x%7-36w]"},
-  {0x00007a00, 0x00007f00, "madl.fs!\t\t%4-7r, %0-3r"}, 
-  {0x00007500, 0x00007f00, "madu!\t\t%4-7r, %0-3r"}, 
+  {0x00007a00, 0x00007f00, "madl.fs!\t\t%4-7r, %0-3r"},
+  {0x00007500, 0x00007f00, "madu!\t\t%4-7r, %0-3r"},
   {0x00007400, 0x00007f00, "mad.f!\t\t%4-7r, %0-3r"},
-  {0x00007900, 0x00007f00, "mazh.f!\t\t%4-7r, %0-3r"}, 
+  {0x00007900, 0x00007f00, "mazh.f!\t\t%4-7r, %0-3r"},
   {0x00007800, 0x00007f00, "mazl.f!\t\t%4-7r, %0-3r"},
   {0x00000448, 0x3e007fff, "mfcel\t\t%20-24r"},
   {0x00007100, 0x00007ff0, "mfcel!\t\t%0-3r"},
-  {0x00000848, 0x3e007fff, "mfceh\t\t%20-24r"},  
-  {0x00007110, 0x00007ff0, "mfceh!\t\t%0-3r"}, 
+  {0x00000848, 0x3e007fff, "mfceh\t\t%20-24r"},
+  {0x00007110, 0x00007ff0, "mfceh!\t\t%0-3r"},
   {0x00000c48, 0x3e007fff, "mfcehl\t\t%20-24r, %15-19r"},
   {0x00000048, 0x3e0003ff, "mfce\t\t%20-24r, er%10-14d"},
   {0x00000050, 0x3e0003ff, "mfsr\t\t%20-24r, sr%10-14d"},
@@ -311,7 +311,7 @@ static struct score_opcode score_opcodes[] =
   {0x00006c00, 0x00007c00, "rpush!\t\t%5-9r, %0-4d"},
   {0x00007600, 0x00007f00, "msb.f!\t\t%4-7r, %0-3r"},
   {0x00007f00, 0x00007f00, "msbh.fs!\t\t%4-7r, %0-3r"},
-  {0x00007e00, 0x00007f00, "msbl.fs!\t\t%4-7r, %0-3r"}, 
+  {0x00007e00, 0x00007f00, "msbl.fs!\t\t%4-7r, %0-3r"},
   {0x00007700, 0x00007f00, "msbu!\t\t%4-7r, %0-3r"},
   {0x00007d00, 0x00007f00, "mszh.f!\t\t%4-7r, %0-3r"},
   {0x00007c00, 0x00007f00, "mszl.f!\t\t%4-7r, %0-3r"},
@@ -338,14 +338,14 @@ static struct score_opcode score_opcodes[] =
   {0x00000341, 0x3e0003ff, "mulr.f\t\t%20-24r,%15-19r, %10-14r"},
   {0x00000040, 0x3e0003ff, "maz\t\t%15-19r, %10-14r"},
   {0x00000041, 0x3e0003ff, "mul.f\t\t%15-19r, %10-14r"},
-  {0x00000041, 0x3e0003ff, "maz.f\t\t%15-19r, %10-14r"},    
+  {0x00000041, 0x3e0003ff, "maz.f\t\t%15-19r, %10-14r"},
   {0x00007200, 0x00007f00, "mul.f!\t\t%4-7r, %0-3r"},
   {0x00000042, 0x3e0003ff, "mulu\t\t%15-19r, %10-14r"},
   {0x00000142, 0x3e0003ff, "mulur.l\t\t%20-24r,%15-19r, %10-14r"},
   {0x00000242, 0x3e0003ff, "mulur.h\t\t%20-24r,%15-19r, %10-14r"},
   {0x00000342, 0x3e0003ff, "mulur\t\t%20-24r,%15-19r, %10-14r"},
   {0x00000042, 0x3e0003ff, "mazu\t\t%15-19r, %10-14r"},
-  {0x00007300, 0x00007f00, "mulu!\t\t%4-7r, %0-3r"},    
+  {0x00007300, 0x00007f00, "mulu!\t\t%4-7r, %0-3r"},
   {0x00000056, 0x3e007fff, "mvcs\t\t%20-24r, %15-19r"},
   {0x00000456, 0x3e007fff, "mvcc\t\t%20-24r, %15-19r"},
   {0x00000856, 0x3e007fff, "mvgtu\t\t%20-24r, %15-19r"},
@@ -370,8 +370,8 @@ static struct score_opcode score_opcodes[] =
   {0x00000000, 0x00007fff, "nop!"},
   {0x00000022, 0x3e0003ff, "or\t\t%20-24r, %15-19r, %10-14r"},
   {0x00000023, 0x3e0003ff, "or.c\t\t%20-24r, %15-19r, %10-14r"},
-  {0x020a0000, 0x3e0e0001, "ori\t\t%20-24r, 0x%1-16x"},    
-  {0x020a0001, 0x3e0e0001, "ori.c\t\t%20-24r, 0x%1-16x"},    
+  {0x020a0000, 0x3e0e0001, "ori\t\t%20-24r, 0x%1-16x"},
+  {0x020a0001, 0x3e0e0001, "ori.c\t\t%20-24r, 0x%1-16x"},
   {0x0a0a0000, 0x3e0e0001, "oris\t\t%20-24r, 0x%1-16x"},
   {0x0a0a0001, 0x3e0e0001, "oris.c\t\t%20-24r, 0x%1-16x"},
   {0x1a000000, 0x3e000001, "orri\t\t%20-24r, %15-19r, 0x%1-14x"},
@@ -589,7 +589,7 @@ print_insn_score48 (struct disassemble_info *info, bfd_vma given)
                                   reg &= (2 << (bitend - bitstart)) - 1;
                                   reg = ((reg ^ (1 << (bitend - bitstart))) -
                                         (1 << (bitend - bitstart)));
-                                  /* Fix bug: s3_testsuite 64-bit.  
+                                  /* Fix bug: s3_testsuite 64-bit.
                                      Remove high 32 bits.  */
                                   reg = (int) reg;
 
@@ -610,7 +610,7 @@ print_insn_score48 (struct disassemble_info *info, bfd_vma given)
 
                                   reg = given >> bitstart;
                                   reg &= (2 << (bitend - bitstart)) - 1;
-                                  /* Fix bug: s3_testsuite 64-bit.  
+                                  /* Fix bug: s3_testsuite 64-bit.
                                      Remove high 32 bits.  */
                                   reg = (int) reg;
 
@@ -626,7 +626,7 @@ print_insn_score48 (struct disassemble_info *info, bfd_vma given)
                                     func (stream, "%lx", reg);
                                 }
                                 break;
-                   
+
                               default:
                                 abort ();
                               }
@@ -662,7 +662,7 @@ print_insn_score48 (struct disassemble_info *info, bfd_vma given)
   func (stream, _("<illegal instruction>"));
   return 6;
 #endif
-  
+
   abort ();
 }
 
@@ -682,7 +682,7 @@ print_insn_score32 (bfd_vma pc, struct disassemble_info *info, long given)
         {
           /* check for bcmpeq / bcmpeqz / bcmpne / bcmpnez */
             /* given &0x7c00 is for to test if rb is zero  ,
-                 rb_equal_zero =1 : index to bcmpeqz 
+                 rb_equal_zero =1 : index to bcmpeqz
                  rb_equal_zero =0 , index to bcmpeq
                 this checking rule only for branch compare ( insn->mask ==0x3e00007e*/
             if (((given & 0x7c00) !=0)&&(rb_equal_zero ==1)&&(insn->mask == 0x3e00007e)
@@ -691,7 +691,7 @@ print_insn_score32 (bfd_vma pc, struct disassemble_info *info, long given)
                 rb_equal_zero =0;
                continue;
              }
-          
+
           char *c;
 
           for (c = insn->assembler; *c; c++)
@@ -743,9 +743,9 @@ print_insn_score32 (bfd_vma pc, struct disassemble_info *info, long given)
                                int target = (pc + SEXT10 (disp));
                                func (stream, "%s ,", score_regnames[reg] );
                                   (*info->print_address_func) (target, info);
-                               
+
                                }
- 
+
                       }
                       break;
                     case 'm':
@@ -1030,7 +1030,7 @@ print_insn_score16 (bfd_vma pc, struct disassemble_info *info, long given)
   func (stream, _("<illegal instruction>"));
   return 2;
 #endif
-  
+
   /* No match.  */
   abort ();
 }
@@ -1077,7 +1077,7 @@ s3_print_insn (bfd_vma pc, struct disassemble_info *info, bfd_boolean little)
   if ((given & 0x8000)==0)
     return  print_insn_score16 (pc, info, given);
 
-  else 
+  else
     {
       if (little)
         {
@@ -1120,7 +1120,7 @@ s3_print_insn (bfd_vma pc, struct disassemble_info *info, bfd_boolean little)
       given_l = ((bfd_vma)b[5]) | ((bfd_vma)b[4] << 8) | ((bfd_vma)b[3] << 16) | ((bfd_vma)b[2] << 24) ;
       given_h = ((bfd_vma)b[1] )|((bfd_vma)b[0] <<8);
       given = ((bfd_vma)given_h<<32) | (bfd_vma)given_l ;
-    
+
     }
 
     /* Set given_48.  */
@@ -1205,4 +1205,4 @@ print_insn_little_score (bfd_vma pc ATTRIBUTE_UNUSED,
 {
   abort ();
 }
-#endif 
+#endif
#--- a/opcodes/score-opc.h
#+++ b/opcodes/score-opc.h
#@@ -1,5 +1,5 @@
# /* Copyright (C) 2006-2015 Free Software Foundation, Inc.
#-   
#+
#    This file is part of the GNU opcodes library.
# 
#    This library is free software; you can redistribute it and/or modify
#@@ -31,7 +31,7 @@ static struct score_opcode score_opcodes[] =
# {
#   /* Score Instructions.  */
#   {0x3800000a, 0x3e007fff, "abs\t\t%20-24r, %15-19r"},
#-  {0x3800004b, 0x3e007fff, "abs.s\t\t%20-24r, %15-19r"},        
#+  {0x3800004b, 0x3e007fff, "abs.s\t\t%20-24r, %15-19r"},
#   {0x00000010, 0x3e0003ff, "add\t\t%20-24r, %15-19r, %10-14r"},
#   {0x00000011, 0x3e0003ff, "add.c\t\t%20-24r, %15-19r, %10-14r"},
#   {0x38000048, 0x3e0003ff, "add.s\t\t%20-24r, %15-19r, %10-14r"},
#@@ -169,36 +169,36 @@ static struct score_opcode score_opcodes[] =
#   {0x31e00000, 0x3ff00000, "cache\t\t%20-24d, [%15-19r, %0-14i]"},
#   {0x31f00000, 0x3ff00000, "cache\t\t%20-24d, [%15-19r, %0-14i]"},
#   {0x38000000, 0x3ff003ff, "mad\t\t%15-19r, %10-14r"},
#-  {0x38000020, 0x3ff003ff, "madu\t\t%15-19r, %10-14r"},        
#+  {0x38000020, 0x3ff003ff, "madu\t\t%15-19r, %10-14r"},
#   {0x38000080, 0x3ff003ff, "mad.f\t\t%15-19r, %10-14r"},
#-  {0x38000001, 0x3ff003ff, "msb\t\t%15-19r, %10-14r"},    
#+  {0x38000001, 0x3ff003ff, "msb\t\t%15-19r, %10-14r"},
#   {0x38000021, 0x3ff003ff, "msbu\t\t%15-19r, %10-14r"},
#   {0x38000081, 0x3ff003ff, "msb.f\t\t%15-19r, %10-14r"},
#-  {0x38000102, 0x3ff003ff, "mazl\t\t%15-19r, %10-14r"},        
#-  {0x38000182, 0x3ff003ff, "mazl.f\t\t%15-19r, %10-14r"},        
#-  {0x38000002, 0x3ff003ff, "madl\t\t%15-19r, %10-14r"},    
#-  {0x380000c2, 0x3ff003ff, "madl.fs\t\t%15-19r, %10-14r"},        
#-  {0x38000303, 0x3ff003ff, "mazh\t\t%15-19r, %10-14r"},    
#-  {0x38000383, 0x3ff003ff, "mazh.f\t\t%15-19r, %10-14r"},    
#-  {0x38000203, 0x3ff003ff, "madh\t\t%15-19r, %10-14r"},    
#-  {0x380002c3, 0x3ff003ff, "madh.fs\t\t%15-19r, %10-14r"},    
#-  {0x38000007, 0x3e0003ff, "max\t\t%20-24r, %15-19r, %10-14r"},    
#+  {0x38000102, 0x3ff003ff, "mazl\t\t%15-19r, %10-14r"},
#+  {0x38000182, 0x3ff003ff, "mazl.f\t\t%15-19r, %10-14r"},
#+  {0x38000002, 0x3ff003ff, "madl\t\t%15-19r, %10-14r"},
#+  {0x380000c2, 0x3ff003ff, "madl.fs\t\t%15-19r, %10-14r"},
#+  {0x38000303, 0x3ff003ff, "mazh\t\t%15-19r, %10-14r"},
#+  {0x38000383, 0x3ff003ff, "mazh.f\t\t%15-19r, %10-14r"},
#+  {0x38000203, 0x3ff003ff, "madh\t\t%15-19r, %10-14r"},
#+  {0x380002c3, 0x3ff003ff, "madh.fs\t\t%15-19r, %10-14r"},
#+  {0x38000007, 0x3e0003ff, "max\t\t%20-24r, %15-19r, %10-14r"},
# 
#-  {0x00000064, 0x3e00007e, "mbitclr\t\t[%15-19r, %m], %10-14d"},    
#-  {0x0000006c, 0x3e00007e, "mbitset\t\t[%20-24r, %m], %10-14d"},    
#+  {0x00000064, 0x3e00007e, "mbitclr\t\t[%15-19r, %m], %10-14d"},
#+  {0x0000006c, 0x3e00007e, "mbitset\t\t[%20-24r, %m], %10-14d"},
# 
#   {0x38000006, 0x3e0003ff, "min\t\t%20-24r, %15-19r, %10-14r"},
#-  {0x38000104, 0x3ff003ff, "mszl\t\t%15-19r, %10-14r"},    
#-  {0x38000184, 0x3ff003ff, "mszl.f\t\t%15-19r, %10-14r"},    
#-  {0x38000004, 0x3ff003ff, "msbl\t\t%15-19r, %10-14r"},        
#+  {0x38000104, 0x3ff003ff, "mszl\t\t%15-19r, %10-14r"},
#+  {0x38000184, 0x3ff003ff, "mszl.f\t\t%15-19r, %10-14r"},
#+  {0x38000004, 0x3ff003ff, "msbl\t\t%15-19r, %10-14r"},
#   {0x380000c4, 0x3ff003ff, "msbl.fs\t\t%15-19r, %10-14r"},
#-  {0x38000305, 0x3ff003ff, "mszh\t\t%15-19r, %10-14r"},        
#-  {0x38000385, 0x3ff003ff, "mszh.f\t\t%15-19r, %10-14r"},    
#-  {0x38000205, 0x3ff003ff, "msbh\t\t%15-19r, %10-14r"},        
#-  {0x380002c5, 0x3ff003ff, "msbh.fs\t\t%15-19r, %10-14r"},        
#-  {0x3800004e, 0x3e0003ff, "sll.s\t\t%20-24r, %15-19r, %10-14r"},                
#-  {0x38000049, 0x3e0003ff, "sub.s\t\t%20-24r, %15-19r, %10-14r"},    
#-  {0x0000001c, 0x3e007fff, "clz\t\t%20-24r, %15-19r"},    
#+  {0x38000305, 0x3ff003ff, "mszh\t\t%15-19r, %10-14r"},
#+  {0x38000385, 0x3ff003ff, "mszh.f\t\t%15-19r, %10-14r"},
#+  {0x38000205, 0x3ff003ff, "msbh\t\t%15-19r, %10-14r"},
#+  {0x380002c5, 0x3ff003ff, "msbh.fs\t\t%15-19r, %10-14r"},
#+  {0x3800004e, 0x3e0003ff, "sll.s\t\t%20-24r, %15-19r, %10-14r"},
#+  {0x38000049, 0x3e0003ff, "sub.s\t\t%20-24r, %15-19r, %10-14r"},
#+  {0x0000001c, 0x3e007fff, "clz\t\t%20-24r, %15-19r"},
#   {0x38000000, 0x3e000000, "ceinst\t\t%20-24d, %15-19r, %10-14r, %5-9d, %0-4d"},
#   {0x00000019, 0x3ff003ff, "cmpteq.c\t\t%15-19r, %10-14r"},
#   {0x00100019, 0x3ff003ff, "cmptmi.c\t\t%15-19r, %10-14r"},
#@@ -264,16 +264,16 @@ static struct score_opcode score_opcodes[] =
#   {0x0e000000, 0x3e000007, "lw\t\t%20-24r, [%15-19r]+, %3-14i"},
#   {0x00001000, 0x00007000, "lw!\t\t%8-11r, [%5-7r,%0-4d2]"},
#   {0x000000000002LL, 0x1c000000001fLL, "lw48\t\t%37-41r,[0x%7-36w]"},
#-  {0x00007b00, 0x00007f00, "madh.fs!\t\t%8-11r, %4-7r"}, 
#-  {0x00007a00, 0x00007f00, "madl.fs!\t\t%8-11r, %4-7r"}, 
#-  {0x00007500, 0x00007f00, "madu!\t\t%8-11r, %4-7r"}, 
#+  {0x00007b00, 0x00007f00, "madh.fs!\t\t%8-11r, %4-7r"},
#+  {0x00007a00, 0x00007f00, "madl.fs!\t\t%8-11r, %4-7r"},
#+  {0x00007500, 0x00007f00, "madu!\t\t%8-11r, %4-7r"},
#   {0x00007400, 0x00007f00, "mad.f!\t\t%8-11r, %4-7r"},
#-  {0x00007900, 0x00007f00, "mazh.f!\t\t%8-11r, %4-7r"}, 
#+  {0x00007900, 0x00007f00, "mazh.f!\t\t%8-11r, %4-7r"},
#   {0x00007800, 0x00007f00, "mazl.f!\t\t%8-11r, %4-7r"},
#   {0x00000448, 0x3e007fff, "mfcel\t\t%20-24r"},
#   {0x00007100, 0x00007ff0, "mfcel!\t\t%4-7r"},
#-  {0x00000848, 0x3e007fff, "mfceh\t\t%20-24r"},  
#-  {0x00007110, 0x00007ff0, "mfceh!\t\t%4-7r"},        
#+  {0x00000848, 0x3e007fff, "mfceh\t\t%20-24r"},
#+  {0x00007110, 0x00007ff0, "mfceh!\t\t%4-7r"},
#   {0x00000c48, 0x3e007fff, "mfcehl\t\t%20-24r, %15-19r"},
#   {0x00000048, 0x3e0003ff, "mfce\t\t%20-24r, er%10-14d"},
#   {0x00000050, 0x3e0003ff, "mfsr\t\t%20-24r, sr%10-14d"},
#@@ -291,7 +291,7 @@ static struct score_opcode score_opcodes[] =
#   {0x00006c00, 0x00007c00, "rpush!\t\t%5-9r, %0-4d"},
#   {0x00007600, 0x00007f00, "msb.f!\t\t%8-11r, %4-7r"},
#   {0x00007f00, 0x00007f00, "msbh.fs!\t\t%8-11r, %4-7r"},
#-  {0x00007e00, 0x00007f00, "msbl.fs!\t\t%8-11r, %4-7r"}, 
#+  {0x00007e00, 0x00007f00, "msbl.fs!\t\t%8-11r, %4-7r"},
#   {0x00007700, 0x00007f00, "msbu!\t\t%8-11r, %4-7r"},
#   {0x00007d00, 0x00007f00, "mszh.f!\t\t%8-11r, %4-7r"},
#   {0x00007c00, 0x00007f00, "mszl.f!\t\t%8-11r, %4-7r"},
#@@ -318,14 +318,14 @@ static struct score_opcode score_opcodes[] =
#   {0x00000241, 0x3e0003ff, "mulr.hf\t\t%20-24r,%15-19r, %10-14r"},
#   {0x00000341, 0x3e0003ff, "mulr.f\t\t%20-24r,%15-19r, %10-14r"},
#   {0x00000040, 0x3e0003ff, "maz\t\t%15-19r, %10-14r"},
#-  {0x00000041, 0x3e0003ff, "maz.f\t\t%15-19r, %10-14r"},    
#+  {0x00000041, 0x3e0003ff, "maz.f\t\t%15-19r, %10-14r"},
#   {0x00007200, 0x00007f00, "mul.f!\t\t%8-11r, %4-7r"},
#   {0x00000042, 0x3e0003ff, "mulu\t\t%15-19r, %10-14r"},
#   {0x00000142, 0x3e0003ff, "mulur.l\t\t%20-24r,%15-19r, %10-14r"},
#   {0x00000242, 0x3e0003ff, "mulur.h\t\t%20-24r,%15-19r, %10-14r"},
#   {0x00000342, 0x3e0003ff, "mulur\t\t%20-24r,%15-19r, %10-14r"},
#   {0x00000042, 0x3e0003ff, "mazu\t\t%15-19r, %10-14r"},
#-  {0x00007300, 0x00007f00, "mulu!\t\t%8-11r, %4-7r"},    
#+  {0x00007300, 0x00007f00, "mulu!\t\t%8-11r, %4-7r"},
#   {0x00000056, 0x3e007fff, "mvcs\t\t%20-24r, %15-19r"},
#   {0x00000456, 0x3e007fff, "mvcc\t\t%20-24r, %15-19r"},
#   {0x00000856, 0x3e007fff, "mvgtu\t\t%20-24r, %15-19r"},
#@@ -350,8 +350,8 @@ static struct score_opcode score_opcodes[] =
#   {0x00000000, 0x00007fff, "nop!"},
#   {0x00000022, 0x3e0003ff, "or\t\t%20-24r, %15-19r, %10-14r"},
#   {0x00000023, 0x3e0003ff, "or.c\t\t%20-24r, %15-19r, %10-14r"},
#-  {0x020a0000, 0x3e0e0001, "ori\t\t%20-24r, 0x%1-16x"},    
#-  {0x020a0001, 0x3e0e0001, "ori.c\t\t%20-24r, 0x%1-16x"},    
#+  {0x020a0000, 0x3e0e0001, "ori\t\t%20-24r, 0x%1-16x"},
#+  {0x020a0001, 0x3e0e0001, "ori.c\t\t%20-24r, 0x%1-16x"},
#   {0x0a0a0000, 0x3e0e0001, "oris\t\t%20-24r, 0x%1-16x"},
#   {0x0a0a0001, 0x3e0e0001, "oris.c\t\t%20-24r, 0x%1-16x"},
#   {0x1a000000, 0x3e000001, "orri\t\t%20-24r, %15-19r, 0x%1-14x"},
#@@ -381,7 +381,7 @@ static struct score_opcode score_opcodes[] =
#   {0x0000006a, 0x3e0003ff, "scw\t\t%20-24r, [%15-19r]+"},
#   {0x0000006e, 0x3e0003ff, "sce\t\t[%15-19r]+"},
#   {0x00000006, 0x3e0003ff, "sdbbp\t\t%15-19d"},
#-  {0x00000020, 0x00007fe0, "sdbbp!\t\t%0-4d"}, 
#+  {0x00000020, 0x00007fe0, "sdbbp!\t\t%0-4d"},
#   {0x000000000000LL, 0x1c000000001fLL, "sdbbp48\t\t%5-9d"},
#   {0x2a000000, 0x3e000000, "sh\t\t%20-24r, [%15-19r, %0-14i]"},
#   {0x06000005, 0x3e000007, "sh\t\t%20-24r, [%15-19r, %3-14i]+"},
--- a/opcodes/score7-dis.c
+++ b/opcodes/score7-dis.c
@@ -59,7 +59,7 @@ static struct score_opcode score_opcodes[] =
 {
   /* Score Instructions.  */
   {0x3800000a, 0x3e007fff, "abs\t\t%20-24r, %15-19r"},
-  {0x3800004b, 0x3e007fff, "abs.s\t\t%20-24r, %15-19r"},        
+  {0x3800004b, 0x3e007fff, "abs.s\t\t%20-24r, %15-19r"},
   {0x00000010, 0x3e0003ff, "add\t\t%20-24r, %15-19r, %10-14r"},
   {0x00000011, 0x3e0003ff, "add.c\t\t%20-24r, %15-19r, %10-14r"},
   {0x38000048, 0x3e0003ff, "add.s\t\t%20-24r, %15-19r, %10-14r"},
@@ -226,32 +226,32 @@ static struct score_opcode score_opcodes[] =
   {0x31e00000, 0x3ff00000, "cache\t\t%20-24d, [%15-19r, %0-14i]"},
   {0x31f00000, 0x3ff00000, "cache\t\t%20-24d, [%15-19r, %0-14i]"},
   {0x38000000, 0x3ff003ff, "mad\t\t%15-19r, %10-14r"},
-  {0x38000020, 0x3ff003ff, "madu\t\t%15-19r, %10-14r"},        
+  {0x38000020, 0x3ff003ff, "madu\t\t%15-19r, %10-14r"},
   {0x38000080, 0x3ff003ff, "mad.f\t\t%15-19r, %10-14r"},
-  {0x38000001, 0x3ff003ff, "msb\t\t%15-19r, %10-14r"},    
+  {0x38000001, 0x3ff003ff, "msb\t\t%15-19r, %10-14r"},
   {0x38000021, 0x3ff003ff, "msbu\t\t%15-19r, %10-14r"},
   {0x38000081, 0x3ff003ff, "msb.f\t\t%15-19r, %10-14r"},
-  {0x38000102, 0x3ff003ff, "mazl\t\t%15-19r, %10-14r"},        
-  {0x38000182, 0x3ff003ff, "mazl.f\t\t%15-19r, %10-14r"},        
-  {0x38000002, 0x3ff003ff, "madl\t\t%15-19r, %10-14r"},    
-  {0x380000c2, 0x3ff003ff, "madl.fs\t\t%15-19r, %10-14r"},        
-  {0x38000303, 0x3ff003ff, "mazh\t\t%15-19r, %10-14r"},    
-  {0x38000383, 0x3ff003ff, "mazh.f\t\t%15-19r, %10-14r"},    
-  {0x38000203, 0x3ff003ff, "madh\t\t%15-19r, %10-14r"},    
-  {0x380002c3, 0x3ff003ff, "madh.fs\t\t%15-19r, %10-14r"},    
-  {0x38000007, 0x3e0003ff, "max\t\t%20-24r, %15-19r, %10-14r"},    
+  {0x38000102, 0x3ff003ff, "mazl\t\t%15-19r, %10-14r"},
+  {0x38000182, 0x3ff003ff, "mazl.f\t\t%15-19r, %10-14r"},
+  {0x38000002, 0x3ff003ff, "madl\t\t%15-19r, %10-14r"},
+  {0x380000c2, 0x3ff003ff, "madl.fs\t\t%15-19r, %10-14r"},
+  {0x38000303, 0x3ff003ff, "mazh\t\t%15-19r, %10-14r"},
+  {0x38000383, 0x3ff003ff, "mazh.f\t\t%15-19r, %10-14r"},
+  {0x38000203, 0x3ff003ff, "madh\t\t%15-19r, %10-14r"},
+  {0x380002c3, 0x3ff003ff, "madh.fs\t\t%15-19r, %10-14r"},
+  {0x38000007, 0x3e0003ff, "max\t\t%20-24r, %15-19r, %10-14r"},
   {0x38000006, 0x3e0003ff, "min\t\t%20-24r, %15-19r, %10-14r"},
-  {0x38000104, 0x3ff003ff, "mszl\t\t%15-19r, %10-14r"},    
-  {0x38000184, 0x3ff003ff, "mszl.f\t\t%15-19r, %10-14r"},    
-  {0x38000004, 0x3ff003ff, "msbl\t\t%15-19r, %10-14r"},        
+  {0x38000104, 0x3ff003ff, "mszl\t\t%15-19r, %10-14r"},
+  {0x38000184, 0x3ff003ff, "mszl.f\t\t%15-19r, %10-14r"},
+  {0x38000004, 0x3ff003ff, "msbl\t\t%15-19r, %10-14r"},
   {0x380000c4, 0x3ff003ff, "msbl.fs\t\t%15-19r, %10-14r"},
-  {0x38000305, 0x3ff003ff, "mszh\t\t%15-19r, %10-14r"},        
-  {0x38000385, 0x3ff003ff, "mszh.f\t\t%15-19r, %10-14r"},    
-  {0x38000205, 0x3ff003ff, "msbh\t\t%15-19r, %10-14r"},        
-  {0x380002c5, 0x3ff003ff, "msbh.fs\t\t%15-19r, %10-14r"},        
-  {0x3800004e, 0x3e0003ff, "sll.s\t\t%20-24r, %15-19r, %10-14r"},                
-  {0x38000049, 0x3e0003ff, "sub.s\t\t%20-24r, %15-19r, %10-14r"},    
-  {0x3800000d, 0x3e007fff, "clz\t\t%20-24r, %15-19r"},    
+  {0x38000305, 0x3ff003ff, "mszh\t\t%15-19r, %10-14r"},
+  {0x38000385, 0x3ff003ff, "mszh.f\t\t%15-19r, %10-14r"},
+  {0x38000205, 0x3ff003ff, "msbh\t\t%15-19r, %10-14r"},
+  {0x380002c5, 0x3ff003ff, "msbh.fs\t\t%15-19r, %10-14r"},
+  {0x3800004e, 0x3e0003ff, "sll.s\t\t%20-24r, %15-19r, %10-14r"},
+  {0x38000049, 0x3e0003ff, "sub.s\t\t%20-24r, %15-19r, %10-14r"},
+  {0x3800000d, 0x3e007fff, "clz\t\t%20-24r, %15-19r"},
   {0x38000000, 0x3e000000, "ceinst\t\t%20-24d, %15-19r, %10-14r, %5-9d, %0-4d"},
   {0x00000019, 0x3ff003ff, "cmpteq.c\t\t%15-19r, %10-14r"},
   {0x00100019, 0x3ff003ff, "cmptmi.c\t\t%15-19r, %10-14r"},
@@ -310,16 +310,16 @@ static struct score_opcode score_opcodes[] =
   {0x0e000000, 0x3e000007, "lw\t\t%20-24r, [%15-19r]+, %3-14i"},
   {0x00002008, 0x0000700f, "lw!\t\t%8-11r, [%4-7r]"},
   {0x00007000, 0x00007007, "lwp!\t\t%8-11r, %3-7d2"},
-  {0x0000100b, 0x0000700f, "madh.fs!\t\t%8-11r, %4-7r"}, 
-  {0x0000100a, 0x0000700f, "madl.fs!\t\t%8-11r, %4-7r"}, 
-  {0x00001005, 0x0000700f, "madu!\t\t%8-11r, %4-7r"}, 
+  {0x0000100b, 0x0000700f, "madh.fs!\t\t%8-11r, %4-7r"},
+  {0x0000100a, 0x0000700f, "madl.fs!\t\t%8-11r, %4-7r"},
+  {0x00001005, 0x0000700f, "madu!\t\t%8-11r, %4-7r"},
   {0x00001004, 0x0000700f, "mad.f!\t\t%8-11r, %4-7r"},
-  {0x00001009, 0x0000700f, "mazh.f!\t\t%8-11r, %4-7r"}, 
+  {0x00001009, 0x0000700f, "mazh.f!\t\t%8-11r, %4-7r"},
   {0x00001008, 0x0000700f, "mazl.f!\t\t%8-11r, %4-7r"},
   {0x00000448, 0x3e007fff, "mfcel\t\t%20-24r"},
   {0x00001001, 0x00007f0f, "mfcel!\t\t%4-7r"},
-  {0x00000848, 0x3e007fff, "mfceh\t\t%20-24r"},  
-  {0x00001101, 0x00007f0f, "mfceh!\t\t%4-7r"},        
+  {0x00000848, 0x3e007fff, "mfceh\t\t%20-24r"},
+  {0x00001101, 0x00007f0f, "mfceh!\t\t%4-7r"},
   {0x00000c48, 0x3e007fff, "mfcehl\t\t%20-24r, %15-19r"},
   {0x00000048, 0x3e0003ff, "mfce\t\t%20-24r, er%10-14d"},
   {0x00000050, 0x3e0003ff, "mfsr\t\t%20-24r, sr%10-14d"},
@@ -331,10 +331,10 @@ static struct score_opcode score_opcodes[] =
   {0x0c000017, 0x3e00001f, "mfcc2\t\t%20-24r, c%15-19r"},
   {0x0c00001f, 0x3e00001f, "mfcc3\t\t%20-24r, c%15-19r"},
   {0x00000002, 0x0000700f, "mhfl!\t\t%8-11R, %4-7r"},
-  {0x00000001, 0x0000700f, "mlfh!\t\t%8-11r, %4-7R"},  
+  {0x00000001, 0x0000700f, "mlfh!\t\t%8-11r, %4-7R"},
   {0x00001006, 0x0000700f, "msb.f!\t\t%8-11r, %4-7r"},
   {0x0000100f, 0x0000700f, "msbh.fs!\t\t%8-11r, %4-7r"},
-  {0x0000100e, 0x0000700f, "msbl.fs!\t\t%8-11r, %4-7r"}, 
+  {0x0000100e, 0x0000700f, "msbl.fs!\t\t%8-11r, %4-7r"},
   {0x00001007, 0x0000700f, "msbu!\t\t%8-11r, %4-7r"},
   {0x0000100d, 0x0000700f, "mszh.f!\t\t%8-11r, %4-7r"},
   {0x0000100c, 0x0000700f, "mszl.f!\t\t%8-11r, %4-7r"},
@@ -355,11 +355,11 @@ static struct score_opcode score_opcodes[] =
   {0x00000040, 0x3e0003ff, "mul\t\t%15-19r, %10-14r"},
   {0x00000040, 0x3e0003ff, "maz\t\t%15-19r, %10-14r"},
   {0x00000041, 0x3e0003ff, "mul.f\t\t%15-19r, %10-14r"},
-  {0x00000041, 0x3e0003ff, "maz.f\t\t%15-19r, %10-14r"},    
+  {0x00000041, 0x3e0003ff, "maz.f\t\t%15-19r, %10-14r"},
   {0x00001002, 0x0000700f, "mul.f!\t\t%8-11r, %4-7r"},
   {0x00000042, 0x3e0003ff, "mulu\t\t%15-19r, %10-14r"},
   {0x00000042, 0x3e0003ff, "mazu\t\t%15-19r, %10-14r"},
-  {0x00001003, 0x0000700f, "mulu!\t\t%8-11r, %4-7r"},    
+  {0x00001003, 0x0000700f, "mulu!\t\t%8-11r, %4-7r"},
   {0x00000056, 0x3e007fff, "mvcs\t\t%20-24r, %15-19r"},
   {0x00000456, 0x3e007fff, "mvcc\t\t%20-24r, %15-19r"},
   {0x00000856, 0x3e007fff, "mvgtu\t\t%20-24r, %15-19r"},
@@ -386,8 +386,8 @@ static struct score_opcode score_opcodes[] =
   {0x00002006, 0x0000700f, "not!\t\t%8-11r, %4-7r"},
   {0x00000022, 0x3e0003ff, "or\t\t%20-24r, %15-19r, %10-14r"},
   {0x00000023, 0x3e0003ff, "or.c\t\t%20-24r, %15-19r, %10-14r"},
-  {0x020a0000, 0x3e0e0001, "ori\t\t%20-24r, 0x%1-16x"},    
-  {0x020a0001, 0x3e0e0001, "ori.c\t\t%20-24r, 0x%1-16x"},    
+  {0x020a0000, 0x3e0e0001, "ori\t\t%20-24r, 0x%1-16x"},
+  {0x020a0001, 0x3e0e0001, "ori.c\t\t%20-24r, 0x%1-16x"},
   {0x0a0a0000, 0x3e0e0001, "oris\t\t%20-24r, 0x%1-16x"},
   {0x0a0a0001, 0x3e0e0001, "oris.c\t\t%20-24r, 0x%1-16x"},
   {0x1a000000, 0x3e000001, "orri\t\t%20-24r, %15-19r, 0x%1-14x"},
@@ -537,7 +537,7 @@ static unsigned int regname_selected = 0;
 #define score_regnames      regnames[regname_selected].reg_names
 
 /* s3_s7: opcodes and export prototypes.  */
-int 
+int
 s7_print_insn (bfd_vma pc, struct disassemble_info *info, bfd_boolean little);
 
 /* Print one instruction from PC on INFO->STREAM.
--- a/opcodes/sh-dis.c
+++ b/opcodes/sh-dis.c
@@ -152,7 +152,7 @@ print_insn_ddt (int insn, struct disassemble_info *info)
 	while (op->nibbles[2] != (unsigned) ((insn >> 4) & 3)
 	       || op->nibbles[3] != (unsigned) (insn & 0xf))
 	  op++;
-	
+
 	print_movxy (op,
 		     (4 * ((insn & (is_movy ? 0x200 : 0x100)) == 0)
 		      + 2 * is_movy
--- a/opcodes/sh-opc.h
+++ b/opcodes/sh-opc.h
@@ -285,7 +285,7 @@ bfd_boolean sh_merge_bfd_arch (bfd *ibfd, bfd *obfd);
 
 /* Below are the 'architecture sets'.
    They describe the following inheritance graph:
-   
+
                 SH1
                  |
                 SH2
@@ -529,7 +529,7 @@ const sh_opcode_info sh_table[] =
 /* 0100nnnn10111010 lds <REG_N>,Y1	*/{"lds",{A_REG_N,A_Y1},{HEX_4,REG_N,HEX_B,HEX_A}, arch_sh_dsp_up},
 
 /* 0100nnnn01011010 lds <REG_N>,FPUL    */{"lds",{A_REG_M,FPUL_N},{HEX_4,REG_M,HEX_5,HEX_A}, arch_sh2e_up},
-  
+
 /* 0100nnnn01101010 lds <REG_M>,FPSCR   */{"lds",{A_REG_M,FPSCR_N},{HEX_4,REG_M,HEX_6,HEX_A}, arch_sh2e_up},
 
 /* 0100nnnn00000110 lds.l @<REG_N>+,MACH*/{"lds.l",{A_INC_N,A_MACH},{HEX_4,REG_N,HEX_0,HEX_6}, arch_sh_up},
@@ -551,7 +551,7 @@ const sh_opcode_info sh_table[] =
 /* 0100nnnn10110110 lds.l @<REG_N>+,Y1	*/{"lds.l",{A_INC_N,A_Y1},{HEX_4,REG_N,HEX_B,HEX_6}, arch_sh_dsp_up},
 
 /* 0100nnnn01010110 lds.l @<REG_M>+,FPUL*/{"lds.l",{A_INC_M,FPUL_N},{HEX_4,REG_M,HEX_5,HEX_6}, arch_sh2e_up},
-  
+
 /* 0100nnnn01100110 lds.l @<REG_M>+,FPSCR*/{"lds.l",{A_INC_M,FPSCR_N},{HEX_4,REG_M,HEX_6,HEX_6}, arch_sh2e_up},
 
 /* 0000000000111000 ldtlb               */{"ldtlb",{0},{HEX_0,HEX_0,HEX_3,HEX_8}, arch_sh3_up},
@@ -804,7 +804,7 @@ const sh_opcode_info sh_table[] =
 /* 0000nnnn10111010 sts Y1,<REG_N>	*/{"sts",{A_Y1,A_REG_N},{HEX_0,REG_N,HEX_B,HEX_A}, arch_sh_dsp_up},
 
 /* 0000nnnn01011010 sts FPUL,<REG_N>    */{"sts",{FPUL_M,A_REG_N},{HEX_0,REG_N,HEX_5,HEX_A}, arch_sh2e_up},
-  
+
 /* 0000nnnn01101010 sts FPSCR,<REG_N>   */{"sts",{FPSCR_M,A_REG_N},{HEX_0,REG_N,HEX_6,HEX_A}, arch_sh2e_up},
 
 /* 0100nnnn00000010 sts.l MACH,@-<REG_N>*/{"sts.l",{A_MACH,A_DEC_N},{HEX_4,REG_N,HEX_0,HEX_2}, arch_sh_up},
@@ -826,7 +826,7 @@ const sh_opcode_info sh_table[] =
 /* 0100nnnn10110110 sts.l Y1,@-<REG_N>	*/{"sts.l",{A_Y1,A_DEC_N},{HEX_4,REG_N,HEX_B,HEX_2}, arch_sh_dsp_up},
 
 /* 0100nnnn01010010 sts.l FPUL,@-<REG_N>*/{"sts.l",{FPUL_M,A_DEC_N},{HEX_4,REG_N,HEX_5,HEX_2}, arch_sh2e_up},
-  
+
 /* 0100nnnn01100010 sts.l FPSCR,@-<REG_N>*/{"sts.l",{FPSCR_M,A_DEC_N},{HEX_4,REG_N,HEX_6,HEX_2}, arch_sh2e_up},
 
 /* 0011nnnnmmmm1000 sub <REG_M>,<REG_N> */{"sub",{ A_REG_M,A_REG_N},{HEX_3,REG_N,REG_M,HEX_8}, arch_sh_up},
@@ -1194,7 +1194,7 @@ const sh_opcode_info sh_table[] =
 /* 0011nnnnmmmm0001 1001dddddddddddd movu.w @(<DISP12>,<REG_M>),<REG_N> */
 {"movu.w",{A_DISP_REG_M,A_REG_N},{HEX_3,REG_N,REG_M,HEX_1,HEX_9,DISP0_12BY2}, arch_sh2a_nofpu_up | arch_op32},
 
-{ 0, {0}, {0}, 0 } 
+{ 0, {0}, {0}, 0 }
 };
 
 #endif
--- a/opcodes/sh64-opc.c
+++ b/opcodes/sh64-opc.c
@@ -33,7 +33,7 @@ const shmedia_opcode_info shmedia_table[] = {
     { "add.l",	    {A_GREG_M,A_GREG_N,A_GREG_D},     {OFFSET_20,OFFSET_10,OFFSET_4}, 0x00080000
     },
 /* 110100mmmmmmssssssssssdddddd0000  addi <A_GREG_M>,<A_IMMS10>,<A_GREG_D>  */
-    { "addi",	    {A_GREG_M,A_IMMS10BY1,A_GREG_D},  {OFFSET_20,OFFSET_10,OFFSET_4}, 
+    { "addi",	    {A_GREG_M,A_IMMS10BY1,A_GREG_D},  {OFFSET_20,OFFSET_10,OFFSET_4},
       SHMEDIA_ADDI_OPC
     },
 /* 110101mmmmmmssssssssssdddddd0000  addi.l <A_GREG_M>,<A_IMMS10>,<A_GREG_D>  */
#--- a/opcodes/sparc-dis.c
#+++ b/opcodes/sparc-dis.c
#@@ -94,7 +94,7 @@ static char *v9_priv_reg_names[] =
# static char *v9_hpriv_reg_names[] =
# {
#   "hpstate", "htstate", "resv2", "hintp", "resv4", "htba", "hver",
#-  "resv7", "resv8", "resv9", "resv10", "resv11", "resv12", "resv13", 
#+  "resv7", "resv8", "resv9", "resv10", "resv11", "resv12", "resv13",
#   "resv14", "resv15", "resv16", "resv17", "resv18", "resv19", "resv20",
#   "resv21", "resv22", "resv23", "resv24", "resv25", "resv26", "resv27",
#   "hstick_offset", "hstick_enable", "resv30", "hstick_cmpr"
--- a/opcodes/spu-opc.c
+++ b/opcodes/spu-opc.c
@@ -26,9 +26,9 @@
 
 /*
    Example contents of spu-insn.h
-      id_tag	mode	mode	type	opcode	mnemonic	asmtype	    dependency		FPU	L/S?	branch?	instruction   
-                QUAD	WORD                                               (0,RC,RB,RA,RT)    latency  			              		
-   APUOP(M_LQD,	1,	0,	RI9,	0x1f8,	"lqd",		ASM_RI9IDX,	00012,		FXU,	1,	0)	Load Quadword d-form 
+      id_tag	mode	mode	type	opcode	mnemonic	asmtype	    dependency		FPU	L/S?	branch?	instruction
+                QUAD	WORD                                               (0,RC,RB,RA,RT)    latency
+   APUOP(M_LQD,	1,	0,	RI9,	0x1f8,	"lqd",		ASM_RI9IDX,	00012,		FXU,	1,	0)	Load Quadword d-form
  */
 
 const struct spu_opcode spu_opcodes[] = {
--- a/opcodes/tic80-opc.c
+++ b/opcodes/tic80-opc.c
@@ -256,7 +256,7 @@ tic80_symbol_to_value (name, symbol_class)
 	{
 	  low = middle + 1;
 	}
-      else 
+      else
 	{
 	  pdsp = &tic80_predefined_symbols[middle];
 	  if ((symbol_class == 0) || (symbol_class & PDS_VALUE (pdsp)))
--- a/opcodes/v850-opc.c
+++ b/opcodes/v850-opc.c
@@ -1385,15 +1385,15 @@ const struct v850_opcode v850_opcodes[] =
 { "bgt",  two (0x07ef, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP },
 { "ble",  two (0x07e7, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP },
 { "blt",  two (0x07e6, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP },
-/* Unsigned integer.  */			      	 
+/* Unsigned integer.  */
 { "bh",   two (0x07eb, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP },
 { "bl",   two (0x07e1, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP },
 { "bnh",  two (0x07e3, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP },
 { "bnl",  two (0x07e9, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP },
-/* Common.  */					      	 
+/* Common.  */
 { "be",   two (0x07e2, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP },
 { "bne",  two (0x07ea, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP },
-/* Others.  */					      	 
+/* Others.  */
 { "bc",   two (0x07e1, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP },
 { "bf",   two (0x07ea, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP },
 { "bn",   two (0x07e4, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP },
@@ -1522,7 +1522,7 @@ const struct v850_opcode v850_opcodes[] =
 
 { "hvcall",	two (0xd7e0, 0x4160),	two (0xffe0, 0x41ff),	{VECTOR8}, 		0, PROCESSOR_V850E3V5_UP },
 { "hvtrap",	two (0x07e0, 0x0110),	two (0xffe0, 0xffff),	{VECTOR5}, 		0, PROCESSOR_V850E3V5_UP },
-  
+
 { "jarl",	two (0xc7e0, 0x0160),	two (0xffe0, 0x07ff),	{R1, R3_NOTR0},   	1, PROCESSOR_V850E3V5_UP},
 { "jarl",	two (0x0780, 0x0000),	two (0x07c0, 0x0001),	{D22, R2_NOTR0}, 	0, PROCESSOR_ALL},
 { "jarl",	one (0x02e0),		one (0xffe0),		{D32_31_PCREL, R1_NOTR0}, 	0, PROCESSOR_V850E2_UP },
--- a/opcodes/vax-dis.c
+++ b/opcodes/vax-dis.c
@@ -131,14 +131,14 @@ parse_disassembler_options (char * options)
 	  /* A guesstimate of the number of entries we will have to create.  */
 	  entry_addr_total_slots +=
 	    strlen (options) / (strlen (entry_switch) + 5);
-	  
+
 	  entry_addr = realloc (entry_addr, sizeof (bfd_vma)
 				* entry_addr_total_slots);
 	}
 
       if (entry_addr == NULL)
 	return FALSE;
-	  
+
       entry_addr[entry_addr_occupied_slots] = bfd_scan_vma (options, NULL, 0);
       entry_addr_occupied_slots ++;
     }
#--- a/opcodes/w65-opc.h
#+++ b/opcodes/w65-opc.h
#@@ -1,4 +1,4 @@
#-/* Instruction opcode header for WDC 65816 
#+/* Instruction opcode header for WDC 65816
#    (generated by the program sim/w65/gencode -a)
# 
#    Copyright (C) 2001-2015 Free Software Foundation, Inc.
--- a/opcodes/xc16x-asm.c
+++ b/opcodes/xc16x-asm.c
@@ -94,7 +94,7 @@ parse_pof (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
       *strp += 4;
       return NULL;
     }
-  return _("Missing 'pof:' prefix");  
+  return _("Missing 'pof:' prefix");
 }
 
 /* Handle 'pag:' prefixes (i.e. skip over them).  */
@@ -379,7 +379,7 @@ xc16x_cgen_parse_operand (CGEN_CPU_DESC cd,
   return errmsg;
 }
 
-cgen_parse_fn * const xc16x_cgen_parse_handlers[] = 
+cgen_parse_fn * const xc16x_cgen_parse_handlers[] =
 {
   parse_insn_normal,
 };
@@ -409,9 +409,9 @@ CGEN_ASM_INIT_HOOK
 
    Returns NULL for success, an error message for failure.  */
 
-char * 
+char *
 xc16x_cgen_build_insn_regex (CGEN_INSN *insn)
-{  
+{
   CGEN_OPCODE *opc = (CGEN_OPCODE *) CGEN_INSN_OPCODE (insn);
   const char *mnem = CGEN_INSN_MNEMONIC (insn);
   char rxbuf[CGEN_MAX_RX_ELEMENTS];
@@ -450,18 +450,18 @@ xc16x_cgen_build_insn_regex (CGEN_INSN *insn)
   /* Copy any remaining literals from the syntax string into the rx.  */
   for(; * syn != 0 && rx <= rxbuf + (CGEN_MAX_RX_ELEMENTS - 7 - 4); ++syn)
     {
-      if (CGEN_SYNTAX_CHAR_P (* syn)) 
+      if (CGEN_SYNTAX_CHAR_P (* syn))
 	{
 	  char c = CGEN_SYNTAX_CHAR (* syn);
 
-	  switch (c) 
+	  switch (c)
 	    {
 	      /* Escape any regex metacharacters in the syntax.  */
-	    case '.': case '[': case '\\': 
-	    case '*': case '^': case '$': 
+	    case '.': case '[': case '\\':
+	    case '*': case '^': case '$':
 
 #ifdef CGEN_ESCAPE_EXTENDED_REGEX
-	    case '?': case '{': case '}': 
+	    case '?': case '{': case '}':
 	    case '(': case ')': case '*':
 	    case '|': case '+': case ']':
 #endif
@@ -491,20 +491,20 @@ xc16x_cgen_build_insn_regex (CGEN_INSN *insn)
     }
 
   /* Trailing whitespace ok.  */
-  * rx++ = '['; 
-  * rx++ = ' '; 
-  * rx++ = '\t'; 
-  * rx++ = ']'; 
-  * rx++ = '*'; 
+  * rx++ = '[';
+  * rx++ = ' ';
+  * rx++ = '\t';
+  * rx++ = ']';
+  * rx++ = '*';
 
   /* But anchor it after that.  */
-  * rx++ = '$'; 
+  * rx++ = '$';
   * rx = '\0';
 
   CGEN_INSN_RX (insn) = xmalloc (sizeof (regex_t));
   reg_err = regcomp ((regex_t *) CGEN_INSN_RX (insn), rxbuf, REG_NOSUB);
 
-  if (reg_err == 0) 
+  if (reg_err == 0)
     return NULL;
   else
     {
@@ -703,7 +703,7 @@ xc16x_cgen_assemble_insn (CGEN_CPU_DESC cd,
       const CGEN_INSN *insn = ilist->insn;
       recognized_mnemonic = 1;
 
-#ifdef CGEN_VALIDATE_INSN_SUPPORTED 
+#ifdef CGEN_VALIDATE_INSN_SUPPORTED
       /* Not usually needed as unsupported opcodes
 	 shouldn't be in the hash lists.  */
       /* Is this insn supported by the selected cpu?  */
@@ -763,7 +763,7 @@ xc16x_cgen_assemble_insn (CGEN_CPU_DESC cd,
 	if (strlen (start) > 50)
 	  /* xgettext:c-format */
 	  sprintf (errbuf, "%s `%.50s...'", tmp_errmsg, start);
-	else 
+	else
 	  /* xgettext:c-format */
 	  sprintf (errbuf, "%s `%.50s'", tmp_errmsg, start);
       }
@@ -772,11 +772,11 @@ xc16x_cgen_assemble_insn (CGEN_CPU_DESC cd,
 	if (strlen (start) > 50)
 	  /* xgettext:c-format */
 	  sprintf (errbuf, _("bad instruction `%.50s...'"), start);
-	else 
+	else
 	  /* xgettext:c-format */
 	  sprintf (errbuf, _("bad instruction `%.50s'"), start);
       }
-      
+
     *errmsg = errbuf;
     return NULL;
   }
--- a/opcodes/xc16x-desc.c
+++ b/opcodes/xc16x-desc.c
@@ -738,263 +738,263 @@ const CGEN_OPERAND xc16x_cgen_operand_table[] =
 {
 /* pc: program counter */
   { "pc", XC16X_OPERAND_PC, HW_H_PC, 0, 0,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_NIL] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_NIL] } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* sr: source register */
   { "sr", XC16X_OPERAND_SR, HW_H_GR, 11, 4,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_R2] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_R2] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* dr: destination register */
   { "dr", XC16X_OPERAND_DR, HW_H_GR, 15, 4,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_R1] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_R1] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* dri: destination register */
   { "dri", XC16X_OPERAND_DRI, HW_H_GR, 11, 4,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_R4] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_R4] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* srb: source register */
   { "srb", XC16X_OPERAND_SRB, HW_H_GRB, 11, 4,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_R2] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_R2] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* drb: destination register */
   { "drb", XC16X_OPERAND_DRB, HW_H_GRB, 15, 4,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_R1] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_R1] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* sr2: 2 bit source register */
   { "sr2", XC16X_OPERAND_SR2, HW_H_GR, 9, 2,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_R0] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_R0] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* src1: source register 1 */
   { "src1", XC16X_OPERAND_SRC1, HW_H_GR, 15, 4,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_R1] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_R1] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* src2: source register 2 */
   { "src2", XC16X_OPERAND_SRC2, HW_H_GR, 11, 4,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_R2] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_R2] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* srdiv: source register 2 */
   { "srdiv", XC16X_OPERAND_SRDIV, HW_H_REGDIV8, 15, 8,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_REG8] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_REG8] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* RegNam: PSW bits */
   { "RegNam", XC16X_OPERAND_REGNAM, HW_H_PSW, 15, 8,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_REG8] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_REG8] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* uimm2: 2 bit unsigned number */
   { "uimm2", XC16X_OPERAND_UIMM2, HW_H_EXT, 13, 2,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_UIMM2] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_UIMM2] } },
     { 0|A(HASH_PREFIX), { { { (1<<MACH_BASE), 0 } } } }  },
 /* uimm3: 3 bit unsigned number */
   { "uimm3", XC16X_OPERAND_UIMM3, HW_H_R01, 10, 3,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_UIMM3] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_UIMM3] } },
     { 0|A(HASH_PREFIX), { { { (1<<MACH_BASE), 0 } } } }  },
 /* uimm4: 4 bit unsigned number */
   { "uimm4", XC16X_OPERAND_UIMM4, HW_H_UINT, 15, 4,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_UIMM4] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_UIMM4] } },
     { 0|A(HASH_PREFIX), { { { (1<<MACH_BASE), 0 } } } }  },
 /* uimm7: 7 bit trap number */
   { "uimm7", XC16X_OPERAND_UIMM7, HW_H_UINT, 15, 7,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_UIMM7] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_UIMM7] } },
     { 0|A(HASH_PREFIX)|A(RELOC)|A(PCREL_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
 /* uimm8: 8 bit unsigned immediate */
   { "uimm8", XC16X_OPERAND_UIMM8, HW_H_UINT, 23, 8,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_UIMM8] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_UIMM8] } },
     { 0|A(HASH_PREFIX), { { { (1<<MACH_BASE), 0 } } } }  },
 /* uimm16: 16 bit unsigned immediate */
   { "uimm16", XC16X_OPERAND_UIMM16, HW_H_UINT, 31, 16,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_UIMM16] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_UIMM16] } },
     { 0|A(HASH_PREFIX), { { { (1<<MACH_BASE), 0 } } } }  },
 /* upof16: 16 bit unsigned immediate */
   { "upof16", XC16X_OPERAND_UPOF16, HW_H_ADDR, 31, 16,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_MEMORY] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_MEMORY] } },
     { 0|A(POF_PREFIX), { { { (1<<MACH_BASE), 0 } } } }  },
 /* reg8: 8 bit word register number */
   { "reg8", XC16X_OPERAND_REG8, HW_H_R8, 15, 8,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_REG8] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_REG8] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* regmem8: 8 bit word register number */
   { "regmem8", XC16X_OPERAND_REGMEM8, HW_H_REGMEM8, 15, 8,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_REGMEM8] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_REGMEM8] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* regbmem8: 8 bit byte register number */
   { "regbmem8", XC16X_OPERAND_REGBMEM8, HW_H_REGBMEM8, 15, 8,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_REGMEM8] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_REGMEM8] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* regoff8: 8 bit word register number */
   { "regoff8", XC16X_OPERAND_REGOFF8, HW_H_R8, 15, 8,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_REGOFF8] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_REGOFF8] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* reghi8: 8 bit word register number */
   { "reghi8", XC16X_OPERAND_REGHI8, HW_H_R8, 23, 8,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_REGHI8] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_REGHI8] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* regb8: 8 bit byte register number */
   { "regb8", XC16X_OPERAND_REGB8, HW_H_GRB8, 15, 8,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_REGB8] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_REGB8] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* genreg: 8 bit word register number */
   { "genreg", XC16X_OPERAND_GENREG, HW_H_R8, 15, 8,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_REGB8] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_REGB8] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* seg: 8 bit segment number */
   { "seg", XC16X_OPERAND_SEG, HW_H_UINT, 15, 8,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_SEG8] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_SEG8] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* seghi8: 8 bit hi segment number */
   { "seghi8", XC16X_OPERAND_SEGHI8, HW_H_UINT, 23, 8,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_SEGNUM8] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_SEGNUM8] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* caddr: 16 bit address offset */
   { "caddr", XC16X_OPERAND_CADDR, HW_H_ADDR, 31, 16,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_OFFSET16] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_OFFSET16] } },
     { 0|A(RELOC)|A(ABS_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
 /* rel: 8 bit signed relative offset */
   { "rel", XC16X_OPERAND_REL, HW_H_SINT, 15, 8,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_REL8] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_REL8] } },
     { 0|A(RELOC)|A(PCREL_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
 /* relhi: hi 8 bit signed relative offset */
   { "relhi", XC16X_OPERAND_RELHI, HW_H_SINT, 23, 8,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_RELHI8] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_RELHI8] } },
     { 0|A(RELOC)|A(PCREL_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
 /* condbit: condition bit */
   { "condbit", XC16X_OPERAND_CONDBIT, HW_H_COND, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* bit1: gap of 1 bit */
   { "bit1", XC16X_OPERAND_BIT1, HW_H_UINT, 11, 1,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_OP_BIT1] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_OP_BIT1] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* bit2: gap of 2 bits */
   { "bit2", XC16X_OPERAND_BIT2, HW_H_UINT, 11, 2,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_OP_BIT2] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_OP_BIT2] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* bit4: gap of 4 bits */
   { "bit4", XC16X_OPERAND_BIT4, HW_H_UINT, 11, 4,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_OP_BIT4] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_OP_BIT4] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* lbit4: gap of 4 bits */
   { "lbit4", XC16X_OPERAND_LBIT4, HW_H_UINT, 15, 4,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_OP_LBIT4] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_OP_LBIT4] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* lbit2: gap of 2 bits */
   { "lbit2", XC16X_OPERAND_LBIT2, HW_H_UINT, 15, 2,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_OP_LBIT2] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_OP_LBIT2] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* bit8: gap of 8 bits */
   { "bit8", XC16X_OPERAND_BIT8, HW_H_UINT, 31, 8,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_OP_BIT8] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_OP_BIT8] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* u4: gap of 4 bits */
   { "u4", XC16X_OPERAND_U4, HW_H_R0, 15, 4,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_UIMM4] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_UIMM4] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* bitone: field of 1 bit */
   { "bitone", XC16X_OPERAND_BITONE, HW_H_UINT, 9, 1,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_OP_ONEBIT] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_OP_ONEBIT] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* bit01: field of 1 bit */
   { "bit01", XC16X_OPERAND_BIT01, HW_H_UINT, 8, 1,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_OP_1BIT] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_OP_1BIT] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* cond: condition code */
   { "cond", XC16X_OPERAND_COND, HW_H_CC, 7, 4,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_CONDCODE] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_CONDCODE] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* icond: indirect condition code */
   { "icond", XC16X_OPERAND_ICOND, HW_H_CC, 15, 4,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_ICONDCODE] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_ICONDCODE] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* extcond: extended condition code */
   { "extcond", XC16X_OPERAND_EXTCOND, HW_H_ECC, 15, 5,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_EXTCCODE] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_EXTCCODE] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* memory: 16 bit memory */
   { "memory", XC16X_OPERAND_MEMORY, HW_H_ADDR, 31, 16,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_MEMORY] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_MEMORY] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* memgr8: 16 bit memory */
   { "memgr8", XC16X_OPERAND_MEMGR8, HW_H_MEMGR8, 31, 16,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_MEMGR8] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_MEMGR8] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* cbit: carry bit */
   { "cbit", XC16X_OPERAND_CBIT, HW_H_CBIT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* qbit: bit addr */
   { "qbit", XC16X_OPERAND_QBIT, HW_H_UINT, 7, 4,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_QBIT] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_QBIT] } },
     { 0|A(DOT_PREFIX), { { { (1<<MACH_BASE), 0 } } } }  },
 /* qlobit: bit addr */
   { "qlobit", XC16X_OPERAND_QLOBIT, HW_H_UINT, 31, 4,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_QLOBIT] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_QLOBIT] } },
     { 0|A(DOT_PREFIX), { { { (1<<MACH_BASE), 0 } } } }  },
 /* qhibit: bit addr */
   { "qhibit", XC16X_OPERAND_QHIBIT, HW_H_UINT, 27, 4,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_QHIBIT] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_QHIBIT] } },
     { 0|A(DOT_PREFIX), { { { (1<<MACH_BASE), 0 } } } }  },
 /* mask8: 8 bit mask */
   { "mask8", XC16X_OPERAND_MASK8, HW_H_UINT, 23, 8,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_MASK8] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_MASK8] } },
     { 0|A(HASH_PREFIX), { { { (1<<MACH_BASE), 0 } } } }  },
 /* masklo8: 8 bit mask */
   { "masklo8", XC16X_OPERAND_MASKLO8, HW_H_UINT, 31, 8,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_DATAHI8] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_DATAHI8] } },
     { 0|A(HASH_PREFIX), { { { (1<<MACH_BASE), 0 } } } }  },
 /* pagenum: 10 bit page number */
   { "pagenum", XC16X_OPERAND_PAGENUM, HW_H_UINT, 25, 10,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_PAGENUM] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_PAGENUM] } },
     { 0|A(HASH_PREFIX), { { { (1<<MACH_BASE), 0 } } } }  },
 /* data8: 8 bit data */
   { "data8", XC16X_OPERAND_DATA8, HW_H_UINT, 23, 8,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_DATA8] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_DATA8] } },
     { 0|A(HASH_PREFIX), { { { (1<<MACH_BASE), 0 } } } }  },
 /* datahi8: 8 bit data */
   { "datahi8", XC16X_OPERAND_DATAHI8, HW_H_UINT, 31, 8,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_DATAHI8] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_DATAHI8] } },
     { 0|A(HASH_PREFIX), { { { (1<<MACH_BASE), 0 } } } }  },
 /* sgtdisbit: segmentation enable bit */
   { "sgtdisbit", XC16X_OPERAND_SGTDISBIT, HW_H_SGTDIS, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* upag16: 16 bit unsigned immediate */
   { "upag16", XC16X_OPERAND_UPAG16, HW_H_UINT, 31, 16,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_UIMM16] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_UIMM16] } },
     { 0|A(PAG_PREFIX), { { { (1<<MACH_BASE), 0 } } } }  },
 /* useg8: 8 bit segment  */
   { "useg8", XC16X_OPERAND_USEG8, HW_H_UINT, 15, 8,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_SEG8] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_SEG8] } },
     { 0|A(SEG_PREFIX), { { { (1<<MACH_BASE), 0 } } } }  },
 /* useg16: 16 bit address offset */
   { "useg16", XC16X_OPERAND_USEG16, HW_H_UINT, 31, 16,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_OFFSET16] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_OFFSET16] } },
     { 0|A(SEG_PREFIX)|A(RELOC)|A(ABS_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
 /* usof16: 16 bit address offset */
   { "usof16", XC16X_OPERAND_USOF16, HW_H_UINT, 31, 16,
-    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_OFFSET16] } }, 
+    { 0, { (const PTR) &xc16x_cgen_ifld_table[XC16X_F_OFFSET16] } },
     { 0|A(SOF_PREFIX)|A(RELOC)|A(ABS_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
 /* hash: # prefix */
   { "hash", XC16X_OPERAND_HASH, HW_H_SINT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* dot: . prefix */
   { "dot", XC16X_OPERAND_DOT, HW_H_SINT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* pof: pof: prefix */
   { "pof", XC16X_OPERAND_POF, HW_H_SINT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* pag: pag: prefix */
   { "pag", XC16X_OPERAND_PAG, HW_H_SINT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* sof: sof: prefix */
   { "sof", XC16X_OPERAND_SOF, HW_H_SINT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* segm: seg: prefix */
   { "segm", XC16X_OPERAND_SEGM, HW_H_SINT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* sentinel */
   { 0, 0, 0, 0, 0,
@@ -3452,7 +3452,7 @@ xc16x_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)
 
   /* Default to not allowing signed overflow.  */
   cd->signed_overflow_ok_p = 0;
-  
+
   return (CGEN_CPU_DESC) cd;
 }
 
@@ -3492,7 +3492,7 @@ xc16x_cgen_cpu_close (CGEN_CPU_DESC cd)
       for (i = 0; i < cd->insn_table.num_init_entries; ++i, ++insns)
 	if (CGEN_INSN_RX (insns))
 	  regfree (CGEN_INSN_RX (insns));
-    }  
+    }
 
   if (cd->macro_insn_table.init_entries)
     free ((CGEN_INSN *) cd->macro_insn_table.init_entries);
--- a/opcodes/xc16x-dis.c
+++ b/opcodes/xc16x-dis.c
@@ -422,7 +422,7 @@ xc16x_cgen_print_operand (CGEN_CPU_DESC cd,
   }
 }
 
-cgen_print_fn * const xc16x_cgen_print_handlers[] = 
+cgen_print_fn * const xc16x_cgen_print_handlers[] =
 {
   print_insn_normal,
 };
@@ -612,7 +612,7 @@ print_insn (CGEN_CPU_DESC cd,
       int length;
       unsigned long insn_value_cropped;
 
-#ifdef CGEN_VALIDATE_INSN_SUPPORTED 
+#ifdef CGEN_VALIDATE_INSN_SUPPORTED
       /* Not needed as insn shouldn't be in hash lists if not supported.  */
       /* Supported by this cpu?  */
       if (! xc16x_cgen_insn_supported (cd, insn))
@@ -630,7 +630,7 @@ print_insn (CGEN_CPU_DESC cd,
          relevant part from the buffer. */
       if ((unsigned) (CGEN_INSN_BITSIZE (insn) / 8) < buflen &&
 	  (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
-	insn_value_cropped = bfd_get_bits (buf, CGEN_INSN_BITSIZE (insn), 
+	insn_value_cropped = bfd_get_bits (buf, CGEN_INSN_BITSIZE (insn),
 					   info->endian == BFD_ENDIAN_BIG);
       else
 	insn_value_cropped = insn_value;
@@ -749,7 +749,7 @@ print_insn_xc16x (bfd_vma pc, disassemble_info *info)
   arch = info->arch;
   if (arch == bfd_arch_unknown)
     arch = CGEN_BFD_ARCH;
-   
+
   /* There's no standard way to compute the machine or isa number
      so we leave it to the target.  */
 #ifdef CGEN_COMPUTE_MACH
@@ -790,7 +790,7 @@ print_insn_xc16x (bfd_vma pc, disassemble_info *info)
 	      break;
 	    }
 	}
-    } 
+    }
 
   /* If we haven't initialized yet, initialize the opcode table.  */
   if (! cd)
--- a/opcodes/xc16x-ibld.c
+++ b/opcodes/xc16x-ibld.c
@@ -154,7 +154,7 @@ insert_normal (CGEN_CPU_DESC cd,
     {
       long minval = - (1L << (length - 1));
       unsigned long maxval = mask;
-      
+
       if ((value > 0 && (unsigned long) value > maxval)
 	  || value < minval)
 	{
@@ -192,7 +192,7 @@ insert_normal (CGEN_CPU_DESC cd,
 	{
 	  long minval = - (1L << (length - 1));
 	  long maxval =   (1L << (length - 1)) - 1;
-	  
+
 	  if (value < minval || value > maxval)
 	    {
 	      sprintf
@@ -973,12 +973,12 @@ xc16x_cgen_extract_operand (CGEN_CPU_DESC cd,
   return length;
 }
 
-cgen_insert_fn * const xc16x_cgen_insert_handlers[] = 
+cgen_insert_fn * const xc16x_cgen_insert_handlers[] =
 {
   insert_insn_normal,
 };
 
-cgen_extract_fn * const xc16x_cgen_extract_handlers[] = 
+cgen_extract_fn * const xc16x_cgen_extract_handlers[] =
 {
   extract_insn_normal,
 };
--- a/opcodes/xc16x-opc.c
+++ b/opcodes/xc16x-opc.c
@@ -31,7 +31,7 @@ This file is part of the GNU Binutils and/or GDB, the GNU debugger.
 #include "libiberty.h"
 
 /* -- opc.c */
-                                                                                
+
 /* -- */
 /* The hash functions are recorded here to help keep assembler code out of
    the disassembler and vice versa.  */
--- a/opcodes/xstormy16-asm.c
+++ b/opcodes/xstormy16-asm.c
@@ -65,7 +65,7 @@ parse_mem8 (CGEN_CPU_DESC cd,
   if (**strp == '(')
     {
       const char *s = *strp;
-      
+
       if (s[1] == '-' && s[2] == '-')
 	return _("Bad register in preincrement");
 
@@ -76,7 +76,7 @@ parse_mem8 (CGEN_CPU_DESC cd,
       if (s[0] == ',' || s[0] == ')')
 	return _("Bad register name");
     }
-  else if (cgen_parse_keyword (cd, strp, & xstormy16_cgen_opval_gr_names, 
+  else if (cgen_parse_keyword (cd, strp, & xstormy16_cgen_opval_gr_names,
 			       (long *) valuep) == NULL)
     return _("Label conflicts with register name");
   else if (strncasecmp (*strp, "rx,", 3) == 0
@@ -85,7 +85,7 @@ parse_mem8 (CGEN_CPU_DESC cd,
     return _("Label conflicts with `Rx'");
   else if (**strp == '#')
     return _("Bad immediate expression");
-  
+
   return cgen_parse_unsigned_integer (cd, strp, opindex, valuep);
 }
 
@@ -93,7 +93,7 @@ parse_mem8 (CGEN_CPU_DESC cd,
    one for small operands and one for large ones.  We want to use
    the small one when possible, but we do not want to generate relocs
    of the small size.  This is somewhat tricky.  */
-   
+
 static const char *
 parse_small_immediate (CGEN_CPU_DESC cd,
 		       const char **strp,
@@ -110,7 +110,7 @@ parse_small_immediate (CGEN_CPU_DESC cd,
   errmsg = (* cd->parse_operand_fn)
     (cd, CGEN_PARSE_OPERAND_INTEGER, strp, opindex, BFD_RELOC_NONE,
      & result, & value);
-  
+
   if (errmsg)
     return errmsg;
 
@@ -122,7 +122,7 @@ parse_small_immediate (CGEN_CPU_DESC cd,
 }
 
 /* Literal scan be either a normal literal, a @hi() or @lo relocation.  */
-   
+
 static const char *
 parse_immediate16 (CGEN_CPU_DESC cd,
 		   const char **strp,
@@ -157,7 +157,7 @@ parse_immediate16 (CGEN_CPU_DESC cd,
 
       *valuep = value;
       if ((code == BFD_RELOC_HI16 || code == BFD_RELOC_LO16)
-	  && **strp == ')')        
+	  && **strp == ')')
 	*strp += 1;
       else
         {
@@ -279,7 +279,7 @@ xstormy16_cgen_parse_operand (CGEN_CPU_DESC cd,
   return errmsg;
 }
 
-cgen_parse_fn * const xstormy16_cgen_parse_handlers[] = 
+cgen_parse_fn * const xstormy16_cgen_parse_handlers[] =
 {
   parse_insn_normal,
 };
@@ -309,9 +309,9 @@ CGEN_ASM_INIT_HOOK
 
    Returns NULL for success, an error message for failure.  */
 
-char * 
+char *
 xstormy16_cgen_build_insn_regex (CGEN_INSN *insn)
-{  
+{
   CGEN_OPCODE *opc = (CGEN_OPCODE *) CGEN_INSN_OPCODE (insn);
   const char *mnem = CGEN_INSN_MNEMONIC (insn);
   char rxbuf[CGEN_MAX_RX_ELEMENTS];
@@ -350,18 +350,18 @@ xstormy16_cgen_build_insn_regex (CGEN_INSN *insn)
   /* Copy any remaining literals from the syntax string into the rx.  */
   for(; * syn != 0 && rx <= rxbuf + (CGEN_MAX_RX_ELEMENTS - 7 - 4); ++syn)
     {
-      if (CGEN_SYNTAX_CHAR_P (* syn)) 
+      if (CGEN_SYNTAX_CHAR_P (* syn))
 	{
 	  char c = CGEN_SYNTAX_CHAR (* syn);
 
-	  switch (c) 
+	  switch (c)
 	    {
 	      /* Escape any regex metacharacters in the syntax.  */
-	    case '.': case '[': case '\\': 
-	    case '*': case '^': case '$': 
+	    case '.': case '[': case '\\':
+	    case '*': case '^': case '$':
 
 #ifdef CGEN_ESCAPE_EXTENDED_REGEX
-	    case '?': case '{': case '}': 
+	    case '?': case '{': case '}':
 	    case '(': case ')': case '*':
 	    case '|': case '+': case ']':
 #endif
@@ -391,20 +391,20 @@ xstormy16_cgen_build_insn_regex (CGEN_INSN *insn)
     }
 
   /* Trailing whitespace ok.  */
-  * rx++ = '['; 
-  * rx++ = ' '; 
-  * rx++ = '\t'; 
-  * rx++ = ']'; 
-  * rx++ = '*'; 
+  * rx++ = '[';
+  * rx++ = ' ';
+  * rx++ = '\t';
+  * rx++ = ']';
+  * rx++ = '*';
 
   /* But anchor it after that.  */
-  * rx++ = '$'; 
+  * rx++ = '$';
   * rx = '\0';
 
   CGEN_INSN_RX (insn) = xmalloc (sizeof (regex_t));
   reg_err = regcomp ((regex_t *) CGEN_INSN_RX (insn), rxbuf, REG_NOSUB);
 
-  if (reg_err == 0) 
+  if (reg_err == 0)
     return NULL;
   else
     {
@@ -603,7 +603,7 @@ xstormy16_cgen_assemble_insn (CGEN_CPU_DESC cd,
       const CGEN_INSN *insn = ilist->insn;
       recognized_mnemonic = 1;
 
-#ifdef CGEN_VALIDATE_INSN_SUPPORTED 
+#ifdef CGEN_VALIDATE_INSN_SUPPORTED
       /* Not usually needed as unsupported opcodes
 	 shouldn't be in the hash lists.  */
       /* Is this insn supported by the selected cpu?  */
@@ -663,7 +663,7 @@ xstormy16_cgen_assemble_insn (CGEN_CPU_DESC cd,
 	if (strlen (start) > 50)
 	  /* xgettext:c-format */
 	  sprintf (errbuf, "%s `%.50s...'", tmp_errmsg, start);
-	else 
+	else
 	  /* xgettext:c-format */
 	  sprintf (errbuf, "%s `%.50s'", tmp_errmsg, start);
       }
@@ -672,11 +672,11 @@ xstormy16_cgen_assemble_insn (CGEN_CPU_DESC cd,
 	if (strlen (start) > 50)
 	  /* xgettext:c-format */
 	  sprintf (errbuf, _("bad instruction `%.50s...'"), start);
-	else 
+	else
 	  /* xgettext:c-format */
 	  sprintf (errbuf, _("bad instruction `%.50s'"), start);
       }
-      
+
     *errmsg = errbuf;
     return NULL;
   }
--- a/opcodes/xstormy16-desc.c
+++ b/opcodes/xstormy16-desc.c
@@ -320,159 +320,159 @@ const CGEN_OPERAND xstormy16_cgen_operand_table[] =
 {
 /* pc: program counter */
   { "pc", XSTORMY16_OPERAND_PC, HW_H_PC, 0, 0,
-    { 0, { (const PTR) &xstormy16_cgen_ifld_table[XSTORMY16_F_NIL] } }, 
+    { 0, { (const PTR) &xstormy16_cgen_ifld_table[XSTORMY16_F_NIL] } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* psw-z8:  */
   { "psw-z8", XSTORMY16_OPERAND_PSW_Z8, HW_H_Z8, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* psw-z16:  */
   { "psw-z16", XSTORMY16_OPERAND_PSW_Z16, HW_H_Z16, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* psw-cy:  */
   { "psw-cy", XSTORMY16_OPERAND_PSW_CY, HW_H_CY, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* psw-hc:  */
   { "psw-hc", XSTORMY16_OPERAND_PSW_HC, HW_H_HC, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* psw-ov:  */
   { "psw-ov", XSTORMY16_OPERAND_PSW_OV, HW_H_OV, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* psw-pt:  */
   { "psw-pt", XSTORMY16_OPERAND_PSW_PT, HW_H_PT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* psw-s:  */
   { "psw-s", XSTORMY16_OPERAND_PSW_S, HW_H_S, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* Rd: general register destination */
   { "Rd", XSTORMY16_OPERAND_RD, HW_H_GR, 12, 4,
-    { 0, { (const PTR) &xstormy16_cgen_ifld_table[XSTORMY16_F_RD] } }, 
+    { 0, { (const PTR) &xstormy16_cgen_ifld_table[XSTORMY16_F_RD] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* Rdm: general register destination */
   { "Rdm", XSTORMY16_OPERAND_RDM, HW_H_GR, 13, 3,
-    { 0, { (const PTR) &xstormy16_cgen_ifld_table[XSTORMY16_F_RDM] } }, 
+    { 0, { (const PTR) &xstormy16_cgen_ifld_table[XSTORMY16_F_RDM] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* Rm: general register for memory */
   { "Rm", XSTORMY16_OPERAND_RM, HW_H_GR, 4, 3,
-    { 0, { (const PTR) &xstormy16_cgen_ifld_table[XSTORMY16_F_RM] } }, 
+    { 0, { (const PTR) &xstormy16_cgen_ifld_table[XSTORMY16_F_RM] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* Rs: general register source */
   { "Rs", XSTORMY16_OPERAND_RS, HW_H_GR, 8, 4,
-    { 0, { (const PTR) &xstormy16_cgen_ifld_table[XSTORMY16_F_RS] } }, 
+    { 0, { (const PTR) &xstormy16_cgen_ifld_table[XSTORMY16_F_RS] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* Rb: base register */
   { "Rb", XSTORMY16_OPERAND_RB, HW_H_RB, 17, 3,
-    { 0, { (const PTR) &xstormy16_cgen_ifld_table[XSTORMY16_F_RB] } }, 
+    { 0, { (const PTR) &xstormy16_cgen_ifld_table[XSTORMY16_F_RB] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* Rbj: base register for jump */
   { "Rbj", XSTORMY16_OPERAND_RBJ, HW_H_RBJ, 11, 1,
-    { 0, { (const PTR) &xstormy16_cgen_ifld_table[XSTORMY16_F_RBJ] } }, 
+    { 0, { (const PTR) &xstormy16_cgen_ifld_table[XSTORMY16_F_RBJ] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* bcond2: branch condition opcode */
   { "bcond2", XSTORMY16_OPERAND_BCOND2, HW_H_BRANCHCOND, 4, 4,
-    { 0, { (const PTR) &xstormy16_cgen_ifld_table[XSTORMY16_F_OP2] } }, 
+    { 0, { (const PTR) &xstormy16_cgen_ifld_table[XSTORMY16_F_OP2] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* ws2: word size opcode */
   { "ws2", XSTORMY16_OPERAND_WS2, HW_H_WORDSIZE, 7, 1,
-    { 0, { (const PTR) &xstormy16_cgen_ifld_table[XSTORMY16_F_OP2M] } }, 
+    { 0, { (const PTR) &xstormy16_cgen_ifld_table[XSTORMY16_F_OP2M] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* bcond5: branch condition opcode */
   { "bcond5", XSTORMY16_OPERAND_BCOND5, HW_H_BRANCHCOND, 16, 4,
-    { 0, { (const PTR) &xstormy16_cgen_ifld_table[XSTORMY16_F_OP5] } }, 
+    { 0, { (const PTR) &xstormy16_cgen_ifld_table[XSTORMY16_F_OP5] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* imm2: 2 bit unsigned immediate */
   { "imm2", XSTORMY16_OPERAND_IMM2, HW_H_UINT, 10, 2,
-    { 0, { (const PTR) &xstormy16_cgen_ifld_table[XSTORMY16_F_IMM2] } }, 
+    { 0, { (const PTR) &xstormy16_cgen_ifld_table[XSTORMY16_F_IMM2] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* imm3: 3 bit unsigned immediate */
   { "imm3", XSTORMY16_OPERAND_IMM3, HW_H_UINT, 4, 3,
-    { 0, { (const PTR) &xstormy16_cgen_ifld_table[XSTORMY16_F_IMM3] } }, 
+    { 0, { (const PTR) &xstormy16_cgen_ifld_table[XSTORMY16_F_IMM3] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* imm3b: 3 bit unsigned immediate for bit tests */
   { "imm3b", XSTORMY16_OPERAND_IMM3B, HW_H_UINT, 17, 3,
-    { 0, { (const PTR) &xstormy16_cgen_ifld_table[XSTORMY16_F_IMM3B] } }, 
+    { 0, { (const PTR) &xstormy16_cgen_ifld_table[XSTORMY16_F_IMM3B] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* imm4: 4 bit unsigned immediate */
   { "imm4", XSTORMY16_OPERAND_IMM4, HW_H_UINT, 8, 4,
-    { 0, { (const PTR) &xstormy16_cgen_ifld_table[XSTORMY16_F_IMM4] } }, 
+    { 0, { (const PTR) &xstormy16_cgen_ifld_table[XSTORMY16_F_IMM4] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* imm8: 8 bit unsigned immediate */
   { "imm8", XSTORMY16_OPERAND_IMM8, HW_H_UINT, 8, 8,
-    { 0, { (const PTR) &xstormy16_cgen_ifld_table[XSTORMY16_F_IMM8] } }, 
+    { 0, { (const PTR) &xstormy16_cgen_ifld_table[XSTORMY16_F_IMM8] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* imm8small: 8 bit unsigned immediate */
   { "imm8small", XSTORMY16_OPERAND_IMM8SMALL, HW_H_UINT, 8, 8,
-    { 0, { (const PTR) &xstormy16_cgen_ifld_table[XSTORMY16_F_IMM8] } }, 
+    { 0, { (const PTR) &xstormy16_cgen_ifld_table[XSTORMY16_F_IMM8] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* imm12: 12 bit signed immediate */
   { "imm12", XSTORMY16_OPERAND_IMM12, HW_H_SINT, 20, 12,
-    { 0, { (const PTR) &xstormy16_cgen_ifld_table[XSTORMY16_F_IMM12] } }, 
+    { 0, { (const PTR) &xstormy16_cgen_ifld_table[XSTORMY16_F_IMM12] } },
     { 0, { { { (1<<MACH_BASE), 0 } } } }  },
 /* imm16: 16 bit immediate */
   { "imm16", XSTORMY16_OPERAND_IMM16, HW_H_UINT, 16, 16,
-    { 0, { (const PTR) &xstormy16_cgen_ifld_table[XSTORMY16_F_IMM16] } }, 
+    { 0, { (const PTR) &xstormy16_cgen_ifld_table[XSTORMY16_F_IMM16] } },
     { 0|A(SIGN_OPT), { { { (1<<MACH_BASE), 0 } } } }  },
 /* lmem8: 8 bit unsigned immediate low memory */
   { "lmem8", XSTORMY16_OPERAND_LMEM8, HW_H_UINT, 8, 8,
-    { 0, { (const PTR) &xstormy16_cgen_ifld_table[XSTORMY16_F_LMEM8] } }, 
+    { 0, { (const PTR) &xstormy16_cgen_ifld_table[XSTORMY16_F_LMEM8] } },
     { 0|A(ABS_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
 /* hmem8: 8 bit unsigned immediate high memory */
   { "hmem8", XSTORMY16_OPERAND_HMEM8, HW_H_UINT, 8, 8,
-    { 0, { (const PTR) &xstormy16_cgen_ifld_table[XSTORMY16_F_HMEM8] } }, 
+    { 0, { (const PTR) &xstormy16_cgen_ifld_table[XSTORMY16_F_HMEM8] } },
     { 0|A(ABS_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
 /* rel8-2: 8 bit relative address */
   { "rel8-2", XSTORMY16_OPERAND_REL8_2, HW_H_UINT, 8, 8,
-    { 0, { (const PTR) &xstormy16_cgen_ifld_table[XSTORMY16_F_REL8_2] } }, 
+    { 0, { (const PTR) &xstormy16_cgen_ifld_table[XSTORMY16_F_REL8_2] } },
     { 0|A(PCREL_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
 /* rel8-4: 8 bit relative address */
   { "rel8-4", XSTORMY16_OPERAND_REL8_4, HW_H_UINT, 8, 8,
-    { 0, { (const PTR) &xstormy16_cgen_ifld_table[XSTORMY16_F_REL8_4] } }, 
+    { 0, { (const PTR) &xstormy16_cgen_ifld_table[XSTORMY16_F_REL8_4] } },
     { 0|A(PCREL_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
 /* rel12: 12 bit relative address */
   { "rel12", XSTORMY16_OPERAND_REL12, HW_H_UINT, 20, 12,
-    { 0, { (const PTR) &xstormy16_cgen_ifld_table[XSTORMY16_F_REL12] } }, 
+    { 0, { (const PTR) &xstormy16_cgen_ifld_table[XSTORMY16_F_REL12] } },
     { 0|A(PCREL_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
 /* rel12a: 12 bit relative address */
   { "rel12a", XSTORMY16_OPERAND_REL12A, HW_H_UINT, 4, 11,
-    { 0, { (const PTR) &xstormy16_cgen_ifld_table[XSTORMY16_F_REL12A] } }, 
+    { 0, { (const PTR) &xstormy16_cgen_ifld_table[XSTORMY16_F_REL12A] } },
     { 0|A(PCREL_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
 /* abs24: 24 bit absolute address */
   { "abs24", XSTORMY16_OPERAND_ABS24, HW_H_UINT, 8, 24,
-    { 2, { (const PTR) &XSTORMY16_F_ABS24_MULTI_IFIELD[0] } }, 
+    { 2, { (const PTR) &XSTORMY16_F_ABS24_MULTI_IFIELD[0] } },
     { 0|A(ABS_ADDR)|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } }  },
 /* psw: program status word */
   { "psw", XSTORMY16_OPERAND_PSW, HW_H_GR, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* Rpsw: N0-N3 of the program status word */
   { "Rpsw", XSTORMY16_OPERAND_RPSW, HW_H_RPSW, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* sp: stack pointer */
   { "sp", XSTORMY16_OPERAND_SP, HW_H_GR, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* R0: R0 */
   { "R0", XSTORMY16_OPERAND_R0, HW_H_GR, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* R1: R1 */
   { "R1", XSTORMY16_OPERAND_R1, HW_H_GR, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* R2: R2 */
   { "R2", XSTORMY16_OPERAND_R2, HW_H_GR, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* R8: R8 */
   { "R8", XSTORMY16_OPERAND_R8, HW_H_GR, 0, 0,
-    { 0, { (const PTR) 0 } }, 
+    { 0, { (const PTR) 0 } },
     { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
 /* sentinel */
   { 0, 0, 0, 0, 0,
@@ -1420,7 +1420,7 @@ xstormy16_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)
 
   /* Default to not allowing signed overflow.  */
   cd->signed_overflow_ok_p = 0;
-  
+
   return (CGEN_CPU_DESC) cd;
 }
 
@@ -1460,7 +1460,7 @@ xstormy16_cgen_cpu_close (CGEN_CPU_DESC cd)
       for (i = 0; i < cd->insn_table.num_init_entries; ++i, ++insns)
 	if (CGEN_INSN_RX (insns))
 	  regfree (CGEN_INSN_RX (insns));
-    }  
+    }
 
   if (cd->macro_insn_table.init_entries)
     free ((CGEN_INSN *) cd->macro_insn_table.init_entries);
--- a/opcodes/xstormy16-dis.c
+++ b/opcodes/xstormy16-dis.c
@@ -170,7 +170,7 @@ xstormy16_cgen_print_operand (CGEN_CPU_DESC cd,
   }
 }
 
-cgen_print_fn * const xstormy16_cgen_print_handlers[] = 
+cgen_print_fn * const xstormy16_cgen_print_handlers[] =
 {
   print_insn_normal,
 };
@@ -360,7 +360,7 @@ print_insn (CGEN_CPU_DESC cd,
       int length;
       unsigned long insn_value_cropped;
 
-#ifdef CGEN_VALIDATE_INSN_SUPPORTED 
+#ifdef CGEN_VALIDATE_INSN_SUPPORTED
       /* Not needed as insn shouldn't be in hash lists if not supported.  */
       /* Supported by this cpu?  */
       if (! xstormy16_cgen_insn_supported (cd, insn))
@@ -378,7 +378,7 @@ print_insn (CGEN_CPU_DESC cd,
          relevant part from the buffer. */
       if ((unsigned) (CGEN_INSN_BITSIZE (insn) / 8) < buflen &&
 	  (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
-	insn_value_cropped = bfd_get_bits (buf, CGEN_INSN_BITSIZE (insn), 
+	insn_value_cropped = bfd_get_bits (buf, CGEN_INSN_BITSIZE (insn),
 					   info->endian == BFD_ENDIAN_BIG);
       else
 	insn_value_cropped = insn_value;
@@ -497,7 +497,7 @@ print_insn_xstormy16 (bfd_vma pc, disassemble_info *info)
   arch = info->arch;
   if (arch == bfd_arch_unknown)
     arch = CGEN_BFD_ARCH;
-   
+
   /* There's no standard way to compute the machine or isa number
      so we leave it to the target.  */
 #ifdef CGEN_COMPUTE_MACH
@@ -538,7 +538,7 @@ print_insn_xstormy16 (bfd_vma pc, disassemble_info *info)
 	      break;
 	    }
 	}
-    } 
+    }
 
   /* If we haven't initialized yet, initialize the opcode table.  */
   if (! cd)
--- a/opcodes/xstormy16-ibld.c
+++ b/opcodes/xstormy16-ibld.c
@@ -154,7 +154,7 @@ insert_normal (CGEN_CPU_DESC cd,
     {
       long minval = - (1L << (length - 1));
       unsigned long maxval = mask;
-      
+
       if ((value > 0 && (unsigned long) value > maxval)
 	  || value < minval)
 	{
@@ -192,7 +192,7 @@ insert_normal (CGEN_CPU_DESC cd,
 	{
 	  long minval = - (1L << (length - 1));
 	  long maxval =   (1L << (length - 1)) - 1;
-	  
+
 	  if (value < minval || value > maxval)
 	    {
 	      sprintf
@@ -825,12 +825,12 @@ xstormy16_cgen_extract_operand (CGEN_CPU_DESC cd,
   return length;
 }
 
-cgen_insert_fn * const xstormy16_cgen_insert_handlers[] = 
+cgen_insert_fn * const xstormy16_cgen_insert_handlers[] =
 {
   insert_insn_normal,
 };
 
-cgen_extract_fn * const xstormy16_cgen_extract_handlers[] = 
+cgen_extract_fn * const xstormy16_cgen_extract_handlers[] =
 {
   extract_insn_normal,
 };
--- a/opcodes/xtensa-dis.c
+++ b/opcodes/xtensa-dis.c
@@ -80,7 +80,7 @@ print_xtensa_operand (bfd_vma memaddr,
 {
   xtensa_isa isa = xtensa_default_isa;
   int signed_operand_val;
-    
+
   if (show_raw_fields)
     {
       if (operand_val < 0xa)
@@ -124,7 +124,7 @@ print_xtensa_operand (bfd_vma memaddr,
 				 xtensa_regfile_shortname (isa, opnd_rf),
 				 operand_val);
 	  i++;
-	} 
+	}
     }
 }
 
--- a/opcodes/z80-dis.c
+++ b/opcodes/z80-dis.c
@@ -130,7 +130,7 @@ prt_rr_nn (struct buffer *buf, disassemble_info * info, char *txt)
   char mytxt[TXTSIZ];
   int rr;
 
-  rr = (buf->data[buf->n_fetch - 1] >> 4) & 3; 
+  rr = (buf->data[buf->n_fetch - 1] >> 4) & 3;
   snprintf (mytxt, TXTSIZ, txt, rr_str[rr]);
   return prt_nn (buf, info, mytxt);
 }
@@ -314,7 +314,7 @@ struct tab_elt opc_ed[] =
 };
 
 static int
-pref_ed (struct buffer * buf, disassemble_info * info, 
+pref_ed (struct buffer * buf, disassemble_info * info,
 	 char* txt ATTRIBUTE_UNUSED)
 {
   struct tab_elt *p;
