http://sourceware.org/ml/gdb-patches/2015-02/msg00727.html
Subject: [PATCH 6/8] gdbserver: Support the "swbreak"/"hwbreak" stop reasons

This patch teaches the core of gdbserver about the new "swbreak" and
"hwbreak" stop reasons, and adds the necessary hooks a backend needs
to implement to support the feature.

gdb/gdbserver/ChangeLog:
2015-02-25  Pedro Alves  <palves@redhat.com>

	* remote-utils.c (prepare_resume_reply): Report swbreak/hbreak.
	* server.c (swbreak_feature, hwbreak_feature): New globals.
	(handle_query) <qSupported>: Handle "swbreak+" and "hwbreak+".
	(captured_main): Clear swbreak_feature and hwbreak_feature.
	* server.h (swbreak_feature, hwbreak_feature): Declare.
	* target.h (struct target_ops) <stopped_by_sw_breakpoint,
	supports_stopped_by_sw_breakpoint, stopped_by_hw_breakpoint,
	supports_stopped_by_hw_breakpoint>: New fields.
	(target_supports_stopped_by_sw_breakpoint)
	(target_stopped_by_sw_breakpoint)
	(target_supports_stopped_by_hw_breakpoint)
	(target_stopped_by_hw_breakpoint): Declare.
---
 gdb/gdbserver/remote-utils.c | 10 ++++++++++
 gdb/gdbserver/server.c       | 25 +++++++++++++++++++++++++
 gdb/gdbserver/server.h       | 11 +++++++++++
 gdb/gdbserver/target.h       | 31 +++++++++++++++++++++++++++++++
 4 files changed, 77 insertions(+)

Index: gdb-7.6.1/gdb/gdbserver/remote-utils.c
===================================================================
--- gdb-7.6.1.orig/gdb/gdbserver/remote-utils.c	2016-03-13 19:45:54.182550173 +0100
+++ gdb-7.6.1/gdb/gdbserver/remote-utils.c	2016-03-13 19:45:59.518589318 +0100
@@ -1355,6 +1355,11 @@
 	      *buf++ = tohex ((addr >> (i - 1) * 4) & 0xf);
 	    *buf++ = ';';
 	  }
+	else if (hwbreak_feature && target_stopped_by_hw_breakpoint ())
+	  {
+	    sprintf (buf, "hwbreak:;");
+	    buf += strlen (buf);
+	  }
 
 	while (*regp)
 	  {
Index: gdb-7.6.1/gdb/gdbserver/server.c
===================================================================
--- gdb-7.6.1.orig/gdb/gdbserver/server.c	2016-03-13 19:45:54.184550187 +0100
+++ gdb-7.6.1/gdb/gdbserver/server.c	2016-03-13 19:46:24.182770265 +0100
@@ -56,6 +56,7 @@
 
 int multi_process;
 int non_stop;
+int hwbreak_feature;
 
 /* Whether we should attempt to disable the operating system's address
    space randomization feature before starting an inferior.  */
@@ -1728,6 +1729,13 @@
 		  /* GDB supports relocate instruction requests.  */
 		  gdb_supports_qRelocInsn = 1;
 		}
+	      else if (strcmp (p, "hwbreak+") == 0)
+		{
+		  /* GDB wants us to report whether a trap is caused
+		     by a hardware breakpoint.  */
+		  if (target_supports_stopped_by_hw_breakpoint ())
+		    hwbreak_feature = 1;
+		}
 	      else
 		target_process_qsupported (p);
 
@@ -1817,6 +1825,9 @@
 	  strcat (own_buf, ";qXfer:btrace:read+");
 	}
 
+      if (target_supports_stopped_by_hw_breakpoint ())
+	strcat (own_buf, ";hwbreak+");
+
       return;
     }
 
@@ -2933,6 +2944,7 @@
       multi_process = 0;
       /* Be sure we're out of tfind mode.  */
       current_traceframe = -1;
+      hwbreak_feature = 0;
 
       remote_open (port);
 
Index: gdb-7.6.1/gdb/gdbserver/server.h
===================================================================
--- gdb-7.6.1.orig/gdb/gdbserver/server.h	2016-03-13 19:45:54.184550187 +0100
+++ gdb-7.6.1/gdb/gdbserver/server.h	2016-03-13 19:45:59.520589333 +0100
@@ -237,6 +237,11 @@
 extern int multi_process;
 extern int non_stop;
 
+/* True if the "hwbreak+" feature is active.  In that case, GDB wants
+   us to report whether a trap is explained by a hardware breakpoint.
+   Only enabled if the target supports it.  */
+extern int hwbreak_feature;
+
 extern int disable_randomization;
 
 #if USE_WIN32API
Index: gdb-7.6.1/gdb/gdbserver/target.h
===================================================================
--- gdb-7.6.1.orig/gdb/gdbserver/target.h	2016-03-13 19:45:54.185550195 +0100
+++ gdb-7.6.1/gdb/gdbserver/target.h	2016-03-13 19:45:59.520589333 +0100
@@ -250,6 +250,13 @@
   int (*insert_point) (char type, CORE_ADDR addr, int len);
   int (*remove_point) (char type, CORE_ADDR addr, int len);
 
+  /* Returns 1 if the target stopped for a hardware breakpoint.  */
+  int (*stopped_by_hw_breakpoint) (void);
+
+  /* Returns true if the target knows whether a trap was caused by a
+     HW breakpoint triggering.  */
+  int (*supports_stopped_by_hw_breakpoint) (void);
+
   /* Returns 1 if target was stopped due to a watchpoint hit, 0 otherwise.  */
 
   int (*stopped_by_watchpoint) (void);
@@ -549,6 +556,14 @@
 #define target_read_btrace(tinfo, buffer, type)	\
   (*the_target->read_btrace) (tinfo, buffer, type)
 
+#define target_supports_stopped_by_hw_breakpoint() \
+  (the_target->supports_stopped_by_hw_breakpoint ? \
+   (*the_target->supports_stopped_by_hw_breakpoint) () : 0)
+
+#define target_stopped_by_hw_breakpoint() \
+  (the_target->stopped_by_hw_breakpoint ? \
+   (*the_target->stopped_by_hw_breakpoint) () : 0)
+
 /* Start non-stop mode, returns 0 on success, -1 on failure.   */
 
 int start_non_stop (int nonstop);
