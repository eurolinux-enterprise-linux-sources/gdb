commit 4f69f4c267a21e787685116945fb40729a7297a5
Author: Jan Kratochvil <jan.kratochvil@redhat.com>
Date:   Tue Aug 7 13:26:33 2012 +0000

    gdb/
    	PR 11804
    	* defs.h (find_memory_region_ftype): New comment.  New arg modified.
    	* fbsd-nat.c (fbsd_find_memory_regions): Add the passed modified value.
    	* gcore.c (gcore_create_callback): New function comment.  Add modified
    	parameter.  Only write modified regions.  Set SEC_READONLY exactly
    	according to MODIFIED.
    	(objfile_find_memory_regions): Ignore separate debug info files.  Ass
    	the passed modified value to FUNC.
    	* gnu-nat.c (gnu_find_memory_regions): Add the passed modified value.
    	* linux-tdep.c (linux_find_memory_regions): Try to reads smaps file
    	first.  New variables modified and has_anonymous.  Parse the lines of
    	smaps file.  Add the passed MODIFIED value to FUNC.
    	* procfs.c (find_memory_regions_callback): Add the passed modified
    	value.
    
    gdb/testsuite/
    	PR 11804
    	* gdb.base/gcore-relro.exp: New file.
    	* gdb.base/gcore-relro-main.c: New file.
    	* gdb.base/gcore-relro-lib.c: New file.

diff -dup -rup gdb-7.2-orig6/gdb/defs.h gdb-7.2/gdb/defs.h
--- gdb-7.2-orig6/gdb/defs.h	2015-09-29 23:40:06.391180766 +0200
+++ gdb-7.2/gdb/defs.h	2015-09-30 00:30:35.559017845 +0200
@@ -652,7 +652,7 @@ extern void init_source_path (void);
 /* Take over the 'find_mapped_memory' vector from exec.c. */
 extern void exec_set_find_memory_regions (int (*) (int (*) (CORE_ADDR, 
 							    unsigned long, 
-							    int, int, int, 
+							    int, int, int, int,
 							    void *),
 						   void *));
 
diff -dup -rup gdb-7.2-orig6/gdb/exec.c gdb-7.2/gdb/exec.c
--- gdb-7.2-orig6/gdb/exec.c	2015-09-29 23:40:02.278154808 +0200
+++ gdb-7.2/gdb/exec.c	2015-09-30 00:30:35.560017851 +0200
@@ -853,7 +853,7 @@ exec_has_memory (struct target_ops *ops)
 extern void
 exec_set_find_memory_regions (int (*func) (int (*) (CORE_ADDR, 
 						    unsigned long, 
-						    int, int, int, 
+						    int, int, int, int,
 						    void *),
 					   void *))
 {
diff -dup -rup gdb-7.2-orig6/gdb/gcore.c gdb-7.2/gdb/gcore.c
--- gdb-7.2-orig6/gdb/gcore.c	2015-09-29 23:40:02.362155338 +0200
+++ gdb-7.2/gdb/gcore.c	2015-09-30 00:36:50.258306671 +0200
@@ -377,9 +377,12 @@ make_output_phdrs (bfd *obfd, asection *
   bfd_record_phdr (obfd, p_type, 1, p_flags, 0, 0, 0, 0, 1, &osec);
 }
 
+/* find_memory_region_ftype implementation.  DATA is 'bfd *' for the core file
+   GDB is creating.  */
+
 static int
-gcore_create_callback (CORE_ADDR vaddr, unsigned long size,
-		       int read, int write, int exec, void *data)
+gcore_create_callback (CORE_ADDR vaddr, unsigned long size, int read,
+		       int write, int exec, int modified, void *data)
 {
   bfd *obfd = data;
   asection *osec;
@@ -388,7 +391,7 @@ gcore_create_callback (CORE_ADDR vaddr, 
   /* If the memory segment has no permissions set, ignore it, otherwise
      when we later try to access it for read/write, we'll get an error
      or jam the kernel.  */
-  if (read == 0 && write == 0 && exec == 0)
+  if (read == 0 && write == 0 && exec == 0 && modified == 0)
     {
       if (info_verbose)
         {
@@ -401,7 +404,7 @@ gcore_create_callback (CORE_ADDR vaddr, unsigned long size,
       return 0;
     }
 
-  if (write == 0 && !solib_keep_data_in_core (vaddr, size))
+  if (write == 0 && modified == 0 && !solib_keep_data_in_core (vaddr, size))
     {
       /* See if this region of memory lies inside a known file on disk.
 	 If so, we can avoid copying its contents by clearing SEC_LOAD.  */
@@ -433,10 +436,12 @@ gcore_create_callback (CORE_ADDR vaddr, unsigned long size,
 	    }
 	}
 
-    keep:
-      flags |= SEC_READONLY;
+    keep:;
     }
 
+  if (write == 0)
+    flags |= SEC_READONLY;
+
   if (exec)
     flags |= SEC_CODE;
   else
@@ -465,7 +470,7 @@ gcore_create_callback (CORE_ADDR vaddr, 
 
 static int
 objfile_find_memory_regions (int (*func) (CORE_ADDR, unsigned long,
-					  int, int, int, void *),
+					  int, int, int, int, void *),
 			     void *obfd)
 {
   /* Use objfile data to create memory sections.  */
@@ -480,6 +485,10 @@ objfile_find_memory_regions (int (*func)
       asection *isec = objsec->the_bfd_section;
       flagword flags = bfd_get_section_flags (ibfd, isec);
 
+      /* Separate debug info files are irrelevant for gcore.  */
+      if (objfile->separate_debug_objfile_backlink != NULL)
+	continue;
+
       if ((flags & SEC_ALLOC) || (flags & SEC_LOAD))
 	{
 	  int size = bfd_section_size (ibfd, isec);
@@ -489,6 +498,7 @@ objfile_find_memory_regions (int (*func)
 			 1, /* All sections will be readable.  */
 			 (flags & SEC_READONLY) == 0, /* Writable.  */
 			 (flags & SEC_CODE) != 0, /* Executable.  */
+			 1, /* MODIFIED is unknown, pass it as true.  */
 			 obfd);
 	  if (ret != 0)
 	    return ret;
@@ -501,6 +511,7 @@ objfile_find_memory_regions (int (*func)
 	     1, /* Stack section will be readable.  */
 	     1, /* Stack section will be writable.  */
 	     0, /* Stack section will not be executable.  */
+	     1, /* Stack section will be modified.  */
 	     obfd);
 
   /* Make a heap segment. */
@@ -509,6 +520,7 @@ objfile_find_memory_regions (int (*func)
 	     1, /* Heap section will be readable.  */
 	     1, /* Heap section will be writable.  */
 	     0, /* Heap section will not be executable.  */
+	     1, /* Heap section will be modified.  */
 	     obfd);
 
   return 0;
diff -dup -rup gdb-7.2-orig6/gdb/gnu-nat.c gdb-7.2/gdb/gnu-nat.c
--- gdb-7.2-orig6/gdb/gnu-nat.c	2010-05-14 22:17:37.000000000 +0200
+++ gdb-7.2/gdb/gnu-nat.c	2015-09-30 00:30:35.602018107 +0200
@@ -2548,6 +2548,7 @@ gnu_find_memory_regions (int (*func) (CO
 		     last_protection & VM_PROT_READ,
 		     last_protection & VM_PROT_WRITE,
 		     last_protection & VM_PROT_EXECUTE,
+		     1, /* MODIFIED is unknown, pass it as true.  */
 		     data);
 	  last_region_address = region_address;
 	  last_region_end = region_address += region_length;
@@ -2561,6 +2562,7 @@ gnu_find_memory_regions (int (*func) (CO
 	     last_protection & VM_PROT_READ,
 	     last_protection & VM_PROT_WRITE,
 	     last_protection & VM_PROT_EXECUTE,
+	     1, /* MODIFIED is unknown, pass it as true.  */
 	     data);
 
   return 0;
diff -dup -rup gdb-7.2-orig6/gdb/linux-nat.c gdb-7.2/gdb/linux-nat.c
--- gdb-7.2-orig6/gdb/linux-nat.c	2015-09-29 23:40:06.616182186 +0200
+++ gdb-7.2/gdb/linux-nat.c	2015-09-30 00:37:03.476387413 +0200
@@ -4102,7 +4102,7 @@ read_mapping (FILE *mapfile,
 static int
 linux_nat_find_memory_regions (int (*func) (CORE_ADDR,
 					    unsigned long,
-					    int, int, int, void *), void *obfd)
+					    int, int, int, int, void *), void *obfd)
 {
   int pid = PIDGET (inferior_ptid);
   char mapsfilename[MAXPATHLEN];
@@ -4113,9 +4113,14 @@ linux_nat_find_memory_regions (int (*fun
   struct cleanup *cleanup;
 
   /* Compose the filename for the /proc memory map, and open it.  */
-  sprintf (mapsfilename, "/proc/%d/maps", pid);
+  sprintf (mapsfilename, "/proc/%d/smaps", pid);
   if ((mapsfile = fopen (mapsfilename, "r")) == NULL)
-    error (_("Could not open %s."), mapsfilename);
+    {
+      /* Older Linux kernels did not support /proc/PID/smaps.  */
+      sprintf (mapsfilename, "/proc/%d/maps", pid);
+      if ((mapsfile = fopen (mapsfilename, "r")) == NULL)
+	error (_("Could not open %s."), mapsfilename);
+    }
   cleanup = make_cleanup_fclose (mapsfile);
 
   if (info_verbose)
@@ -4126,6 +4131,8 @@ linux_nat_find_memory_regions (int (*fun
   while (read_mapping (mapsfile, &addr, &endaddr, &permissions[0],
 		       &offset, &device[0], &inode, &filename[0]))
     {
+      int modified = 0, has_anonymous = 0;
+
       size = endaddr - addr;
 
       /* Get the segment's permissions.  */
@@ -4133,6 +4140,37 @@ linux_nat_find_memory_regions (int (*fun
       write = (strchr (permissions, 'w') != 0);
       exec = (strchr (permissions, 'x') != 0);
 
+      for (;;)
+	{
+	  int i;
+	  char keyword[64 + 1];
+	  unsigned long number;
+
+	  i = fgetc (mapsfile);
+	  if (i != EOF)
+	    ungetc (i, mapsfile);
+	  if (i < 'A' || i > 'Z')
+	    break;
+
+	  if (fscanf (mapsfile, "%64s%lu kB\n", keyword, &number) != 2)
+	    {
+	      warning (_("Error parsing {s,}maps file '%s'"), mapsfilename);
+	      break;
+	    }
+	  if (strcmp (keyword, "Anonymous:") == 0)
+	    has_anonymous = 1;
+	  if (number != 0 && (strcmp (keyword, "Shared_Dirty:") == 0
+			      || strcmp (keyword, "Private_Dirty:") == 0
+			      || strcmp (keyword, "Swap:") == 0
+			      || strcmp (keyword, "Anonymous:") == 0))
+	    modified = 1;
+	}
+
+      /* Older Linux kernels did not support the "Anonymous:" counter.
+	 If it is missing, we can't be sure - dump all the pages.  */
+      if (!has_anonymous)
+	modified = 1;
+
       if (info_verbose)
 	{
 	  fprintf_filtered (gdb_stdout,
@@ -4147,7 +4185,7 @@ linux_nat_find_memory_regions (int (*fun
 
       /* Invoke the callback function to create the corefile
 	 segment.  */
-      func (addr, size, read, write, exec, obfd);
+      func (addr, size, read, write, exec, modified, obfd);
     }
   do_cleanups (cleanup);
   return 0;
diff -dup -rup gdb-7.2-orig6/gdb/procfs.c gdb-7.2/gdb/procfs.c
--- gdb-7.2-orig6/gdb/procfs.c	2015-09-29 23:40:05.654176115 +0200
+++ gdb-7.2/gdb/procfs.c	2015-09-30 00:30:35.609018150 +0200
@@ -5305,6 +5305,7 @@ find_memory_regions_callback (struct prm
 		  (map->pr_mflags & MA_READ) != 0,
 		  (map->pr_mflags & MA_WRITE) != 0,
 		  (map->pr_mflags & MA_EXEC) != 0,
+		  1, /* MODIFIED is unknown, pass it as true.  */
 		  data);
 }
 
diff -dup -rup gdb-7.2-orig6/gdb/target.h gdb-7.2/gdb/target.h
--- gdb-7.2-orig6/gdb/target.h	2015-09-29 23:40:06.438181063 +0200
+++ gdb-7.2/gdb/target.h	2015-09-30 00:30:35.598018083 +0200
@@ -495,7 +495,7 @@ struct target_ops
     /* find_memory_regions support method for gcore */
     int (*to_find_memory_regions) (int (*) (CORE_ADDR,
 					    unsigned long,
-					    int, int, int,
+					    int, int, int, int,
 					    void *),
 				   void *);
     /* make_corefile_notes support method for gcore */
