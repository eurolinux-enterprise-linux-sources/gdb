Implement vFile:setfs in gdbserver

From: Gary Benson <gbenson@redhat.com>

This commit implements the "vFile:setfs" packet in gdbserver.

gdb/gdbserver/ChangeLog:

	* target.h (struct target_ops) <multifs_open>: New field.
	<multifs_unlink>: Likewise.
	<multifs_readlink>: Likewise.
	* linux-low.c (nat/linux-namespaces.h): New include.
	(linux_target_ops): Initialize the_target->multifs_open,
	the_target->multifs_unlink and the_target->multifs_readlink.
	* hostio.h (hostio_handle_new_gdb_connection): New declaration.
	* hostio.c (hostio_fs_pid): New static variable.
	(hostio_handle_new_gdb_connection): New function.
	(handle_setfs): Likewise.
	(handle_open): Use the_target->multifs_open as appropriate.
	(handle_unlink): Use the_target->multifs_unlink as appropriate.
	(handle_readlink): Use the_target->multifs_readlink as
	appropriate.
	(handle_vFile): Handle vFile:setfs packets.
	* server.c (handle_query): Call hostio_handle_new_gdb_connection
	after target_handle_new_gdb_connection.
---
 gdb/gdbserver/ChangeLog   |   20 +++++++++++++
 gdb/gdbserver/hostio.c    |   70 +++++++++++++++++++++++++++++++++++++++++++--
 gdb/gdbserver/linux-low.c |    4 +++
 gdb/gdbserver/server.c    |    2 +
 gdb/gdbserver/target.h    |   21 ++++++++++++++
 5 files changed, 114 insertions(+), 3 deletions(-)

Index: gdb-7.2/gdb/gdbserver/hostio.c
===================================================================
--- gdb-7.2.orig/gdb/gdbserver/hostio.c	2010-01-01 08:31:49.000000000 +0100
+++ gdb-7.2/gdb/gdbserver/hostio.c	2016-08-04 22:19:57.533030885 +0200
@@ -260,6 +260,55 @@
   return 0;
 }
 
+/* Process ID of inferior whose filesystem hostio functions
+   that take FILENAME arguments will use.  Zero means to use
+   our own filesystem.  */
+
+static int hostio_fs_pid;
+
+/* See hostio.h.  */
+
+void
+hostio_handle_new_gdb_connection (void)
+{
+  hostio_fs_pid = 0;
+}
+
+/* Handle a "vFile:setfs:" packet.  */
+
+static void
+handle_setfs (char *own_buf)
+{
+  char *p;
+  int pid;
+
+  /* If the target doesn't have any of the in-filesystem-of methods
+     then there's no point in GDB sending "vFile:setfs:" packets.  We
+     reply with an empty packet (i.e. we pretend we don't understand
+     "vFile:setfs:") and that should stop GDB sending any more.  */
+  if (the_target->multifs_open == NULL
+      && the_target->multifs_unlink == NULL
+      && the_target->multifs_readlink == NULL)
+    {
+      own_buf[0] = '\0';
+      return;
+    }
+
+  p = own_buf + strlen ("vFile:setfs:");
+
+  if (require_int (&p, &pid)
+      || pid < 0
+      || require_end (p))
+    {
+      hostio_packet_error (own_buf);
+      return;
+    }
+
+  hostio_fs_pid = pid;
+
+  hostio_reply (own_buf, 0);
+}
+
 static void
 handle_open (char *own_buf)
 {
@@ -284,7 +333,11 @@
 
   /* We do not need to convert MODE, since the fileio protocol
      uses the standard values.  */
-  fd = open (filename, flags, mode);
+  if (hostio_fs_pid != 0 && the_target->multifs_open != NULL)
+    fd = the_target->multifs_open (hostio_fs_pid, filename,
+				   flags, mode);
+  else
+    fd = open (filename, flags, mode);
 
   if (fd == -1)
     {
@@ -441,7 +494,10 @@
       return;
     }
 
-  ret = unlink (filename);
+  if (hostio_fs_pid != 0 && the_target->multifs_unlink != NULL)
+    ret = the_target->multifs_unlink (hostio_fs_pid, filename);
+  else
+    ret = unlink (filename);
 
   if (ret == -1)
     {
@@ -467,6 +523,8 @@
     handle_close (own_buf);
   else if (strncmp (own_buf, "vFile:unlink:", 13) == 0)
     handle_unlink (own_buf);
+  else if (strncmp (own_buf, "vFile:setfs:", 12) == 0)
+    handle_setfs (own_buf);
   else
     return 0;
 
Index: gdb-7.2/gdb/gdbserver/linux-low.c
===================================================================
--- gdb-7.2.orig/gdb/gdbserver/linux-low.c	2016-08-04 22:18:21.000000000 +0200
+++ gdb-7.2/gdb/gdbserver/linux-low.c	2016-08-04 22:19:17.817674693 +0200
@@ -47,6 +47,7 @@
    definition of elf_fpregset_t.  */
 #include <elf.h>
 #endif
+#include "../nat/linux-namespaces.h"
 
 #ifndef SPUFS_MAGIC
 #define SPUFS_MAGIC 0x23c9b64e
@@ -5166,6 +5167,9 @@
   linux_install_fast_tracepoint_jump_pad,
   linux_emit_ops,
   linux_proc_pid_to_exec_file,
+  linux_mntns_open_cloexec,
+  linux_mntns_unlink,
+  linux_mntns_readlink,
 };
 
 static void
Index: gdb-7.2/gdb/gdbserver/server.c
===================================================================
--- gdb-7.2.orig/gdb/gdbserver/server.c	2016-08-04 22:18:21.000000000 +0200
+++ gdb-7.2/gdb/gdbserver/server.c	2016-08-04 22:19:17.863675105 +0200
@@ -1498,6 +1498,11 @@
       if (the_target->pid_to_exec_file != NULL)
 	strcat (own_buf, ";qXfer:exec-file:read+");
 
+      /* Reinitialize components as needed for the new connection.  */
+{
+extern void hostio_handle_new_gdb_connection (void);
+      hostio_handle_new_gdb_connection ();
+}
       return;
     }
 
Index: gdb-7.2/gdb/gdbserver/target.h
===================================================================
--- gdb-7.2.orig/gdb/gdbserver/target.h	2016-08-04 22:18:21.000000000 +0200
+++ gdb-7.2/gdb/gdbserver/target.h	2016-08-04 22:19:17.875675213 +0200
@@ -363,6 +363,27 @@
      string should be copied into a buffer by the client if the string
      will not be immediately used, or if it must persist.  */
   char *(*pid_to_exec_file) (int pid);
+
+  /* Multiple-filesystem-aware open.  Like open(2), but operating in
+     the filesystem as it appears to process PID.  Systems where all
+     processes share a common filesystem should set this to NULL.
+     If NULL, the caller should fall back to open(2).  */
+  int (*multifs_open) (int pid, const char *filename,
+		       int flags, mode_t mode);
+
+  /* Multiple-filesystem-aware unlink.  Like unlink(2), but operates
+     in the filesystem as it appears to process PID.  Systems where
+     all processes share a common filesystem should set this to NULL.
+     If NULL, the caller should fall back to unlink(2).  */
+  int (*multifs_unlink) (int pid, const char *filename);
+
+  /* Multiple-filesystem-aware readlink.  Like readlink(2), but
+     operating in the filesystem as it appears to process PID.
+     Systems where all processes share a common filesystem should
+     set this to NULL.  If NULL, the caller should fall back to
+     readlink(2).  */
+  ssize_t (*multifs_readlink) (int pid, const char *filename,
+			       char *buf, size_t bufsiz);
 };
 
 extern struct target_ops *the_target;
