http://sourceware.org/ml/gdb-cvs/2011-01/msg00022.html

### src/gdb/ChangeLog	2011/01/05 05:09:44	1.12429
### src/gdb/ChangeLog	2011/01/05 22:22:44	1.12430
## -1,3 +1,156 @@
+2011-01-05  Michael Snyder  <msnyder@vmware.com>
+
+	* addrmap.c: Shorten lines of >= 80 columns.
+	* arch-utils.c: Ditto.
+	* arch-utils.h: Ditto.
+	* ax-gdb.c: Ditto.
+	* ax-general.c: Ditto.
+	* bcache.c: Ditto.
+	* blockframe.c: Ditto.
+	* breakpoint.c: Ditto.
+	* buildsym.c: Ditto.
+	* c-lang.c: Ditto.
+	* c-typeprint.c: Ditto.
+	* charset.c: Ditto.
+	* coffread.c: Ditto.
+	* command.h: Ditto.
+	* corelow.c: Ditto.
+	* cp-abi.c: Ditto.
+	* cp-namespace.c: Ditto.
+	* cp-support.c: Ditto.
+	* dbug-rom.c: Ditto.
+	* dbxread.c: Ditto.
+	* defs.h: Ditto.
+	* dfp.c: Ditto.
+	* dfp.h: Ditto.
+	* dictionary.c: Ditto.
+	* disasm.c: Ditto.
+	* doublest.c: Ditto.
+	* dwarf2-frame.c: Ditto.
+	* dwarf2expr.c: Ditto.
+	* dwarf2loc.c: Ditto.
+	* dwarf2read.c: Ditto.
+	* elfread.c: Ditto.
+	* eval.c: Ditto.
+	* event-loop.c: Ditto.
+	* event-loop.h: Ditto.
+	* exceptions.h: Ditto.
+	* exec.c: Ditto.
+	* expprint.c: Ditto.
+	* expression.h: Ditto.
+	* f-lang.c: Ditto.
+	* f-valprint.c: Ditto.
+	* findcmd.c: Ditto.
+	* frame-base.c: Ditto.
+	* frame-unwind.c: Ditto.
+	* frame-unwind.h: Ditto.
+	* frame.c: Ditto.
+	* frame.h: Ditto.
+	* gcore.c: Ditto.
+	* gdb-stabs.h: Ditto.
+	* gdb_assert.h: Ditto.
+	* gdb_dirent.h: Ditto.
+	* gdb_obstack.h: Ditto.
+	* gdbcore.h: Ditto.
+	* gdbtypes.c: Ditto.
+	* gdbtypes.h: Ditto.
+	* inf-ttrace.c: Ditto.
+	* infcall.c: Ditto.
+	* infcmd.c: Ditto.
+	* inflow.c: Ditto.
+	* infrun.c: Ditto.
+	* inline-frame.h: Ditto.
+	* language.c: Ditto.
+	* language.h: Ditto.
+	* libunwind-frame.c: Ditto.
+	* libunwind-frame.h: Ditto.
+	* linespec.c: Ditto.
+	* linux-nat.c: Ditto.
+	* linux-nat.h: Ditto.
+	* linux-thread-db.c: Ditto.
+	* machoread.c: Ditto.
+	* macroexp.c: Ditto.
+	* macrotab.c: Ditto.
+	* main.c: Ditto.
+	* maint.c: Ditto.
+	* mdebugread.c: Ditto.
+	* memattr.c: Ditto.
+	* minsyms.c: Ditto.
+	* monitor.c: Ditto.
+	* monitor.h: Ditto.
+	* objfiles.c: Ditto.
+	* objfiles.h: Ditto.
+	* osabi.c: Ditto.
+	* p-typeprint.c: Ditto.
+	* p-valprint.c: Ditto.
+	* parse.c: Ditto.
+	* printcmd.c: Ditto.
+	* proc-events.c: Ditto.
+	* procfs.c: Ditto.
+	* progspace.c: Ditto.
+	* progspace.h: Ditto.
+	* psympriv.h: Ditto.
+	* psymtab.c: Ditto.
+	* record.c: Ditto.
+	* regcache.c: Ditto.
+	* regcache.h: Ditto.
+	* remote-fileio.c: Ditto.
+	* remote.c: Ditto.
+	* ser-mingw.c: Ditto.
+	* ser-tcp.c: Ditto.
+	* ser-unix.c: Ditto.
+	* serial.c: Ditto.
+	* serial.h: Ditto.
+	* solib-frv.c: Ditto.
+	* solib-irix.c: Ditto.
+	* solib-osf.c: Ditto.
+	* solib-pa64.c: Ditto.
+	* solib-som.c: Ditto.
+	* solib-sunos.c: Ditto.
+	* solib-svr4.c: Ditto.
+	* solib-target.c: Ditto.
+	* solib.c: Ditto.
+	* somread.c: Ditto.
+	* source.c: Ditto.
+	* stabsread.c: Ditto.
+	* stabsread.c: Ditto.
+	* stack.c: Ditto.
+	* stack.h: Ditto.
+	* symfile-mem.c: Ditto.
+	* symfile.c: Ditto.
+	* symfile.h: Ditto.
+	* symmisc.c: Ditto.
+	* symtab.c: Ditto.
+	* symtab.h: Ditto.
+	* target-descriptions.c: Ditto.
+	* target-memory.c: Ditto.
+	* target.c: Ditto.
+	* target.h: Ditto.
+	* terminal.h: Ditto.
+	* thread.c: Ditto.
+	* top.c: Ditto.
+	* tracepoint.c: Ditto.
+	* tracepoint.h: Ditto.
+	* ui-file.c: Ditto.
+	* ui-file.h: Ditto.
+	* ui-out.h: Ditto.
+	* user-regs.c: Ditto.
+	* user-regs.h: Ditto.
+	* utils.c: Ditto.
+	* valarith.c: Ditto.
+	* valops.c: Ditto.
+	* valprint.c: Ditto.
+	* valprint.h: Ditto.
+	* value.c: Ditto.
+	* varobj.c: Ditto.
+	* varobj.h: Ditto.
+	* vec.h: Ditto.
+	* xcoffread.c: Ditto.
+	* xcoffsolib.c: Ditto.
+	* xcoffsolib.h: Ditto.
+	* xml-syscall.c: Ditto.
+	* xml-tdesc.c: Ditto.
+
 2011-01-05  Joel Brobecker  <brobecker@adacore.com>
 
 	* configure.ac, gdb.1: Copyright year update.
Index: gdb-7.2/gdb/dwarf2read.c
===================================================================
--- gdb-7.2.orig/gdb/dwarf2read.c	2011-07-26 23:05:56.000000000 +0200
+++ gdb-7.2/gdb/dwarf2read.c	2011-07-26 23:06:13.000000000 +0200
@@ -786,8 +786,8 @@ static void
 show_dwarf2_max_cache_age (struct ui_file *file, int from_tty,
 			   struct cmd_list_element *c, const char *value)
 {
-  fprintf_filtered (file, _("\
-The upper bound on the age of cached dwarf2 compilation units is %s.\n"),
+  fprintf_filtered (file, _("The upper bound on the age of cached "
+			    "dwarf2 compilation units is %s.\n"),
 		    value);
 }
 
@@ -812,7 +812,8 @@ static void
 dwarf2_debug_line_missing_end_sequence_complaint (void)
 {
   complaint (&symfile_complaints,
-	     _(".debug_line section has line program sequence without an end"));
+	     _(".debug_line section has line "
+	       "program sequence without an end"));
 }
 
 static void
@@ -826,8 +827,8 @@ dwarf2_const_value_length_mismatch_compl
 					      int arg3)
 {
   complaint (&symfile_complaints,
-	     _("const value length mismatch for '%s', got %d, expected %d"), arg1,
-	     arg2, arg3);
+	     _("const value length mismatch for '%s', got %d, expected %d"),
+	     arg1, arg2, arg3);
 }
 
 static void
@@ -841,7 +842,8 @@ static void
 dwarf2_macro_malformed_definition_complaint (const char *arg1)
 {
   complaint (&symfile_complaints,
-	     _("macro debug info contains a malformed macro definition:\n`%s'"),
+	     _("macro debug info contains a "
+	       "malformed macro definition:\n`%s'"),
 	     arg1);
 }
 
@@ -849,7 +851,8 @@ static void
 dwarf2_invalid_attrib_class_complaint (const char *arg1, const char *arg2)
 {
   complaint (&symfile_complaints,
-	     _("invalid attribute class or form for '%s' in '%s'"), arg1, arg2);
+	     _("invalid attribute class or form for '%s' in '%s'"),
+	     arg1, arg2);
 }
 
 /* local function prototypes */
@@ -1013,7 +1016,8 @@ static struct type *die_type (struct die
 
 static int need_gnat_info (struct dwarf2_cu *);
 
-static struct type *die_descriptive_type (struct die_info *, struct dwarf2_cu *);
+static struct type *die_descriptive_type (struct die_info *,
+					  struct dwarf2_cu *);
 
 static void set_descriptive_type (struct type *, struct die_info *,
 				  struct dwarf2_cu *);
@@ -1067,7 +1071,8 @@ static void dwarf2_add_member_fn (struct
 				  struct dwarf2_cu *);
 
 static void dwarf2_attach_fn_fields_to_type (struct field_info *,
-					     struct type *, struct dwarf2_cu *);
+					     struct type *,
+					     struct dwarf2_cu *);
 
 static void process_structure_scope (struct die_info *, struct dwarf2_cu *);
 
@@ -1450,7 +1455,8 @@ zlib_decompress_section (struct objfile 
   int header_size = 12;
 
   if (bfd_seek (abfd, sectp->filepos, SEEK_SET) != 0
-      || bfd_bread (compressed_buffer, compressed_size, abfd) != compressed_size)
+      || bfd_bread (compressed_buffer,
+		    compressed_size, abfd) != compressed_size)
     error (_("Dwarf Error: Can't read DWARF data from '%s'"),
            bfd_get_filename (abfd));
 
@@ -2840,7 +2846,8 @@ create_debug_types_hash_table (struct ob
   if (dwarf2_die_debug)
     fprintf_unfiltered (gdb_stdlog, "Signatured types:\n");
 
-  while (info_ptr < dwarf2_per_objfile->types.buffer + dwarf2_per_objfile->types.size)
+  while (info_ptr < dwarf2_per_objfile->types.buffer
+	 + dwarf2_per_objfile->types.size)
     {
       unsigned int offset;
       unsigned int offset_size;
@@ -2863,7 +2870,8 @@ create_debug_types_hash_table (struct ob
 	  > dwarf2_per_objfile->types.buffer + dwarf2_per_objfile->types.size)
 	{
 	  complaint (&symfile_complaints,
-		     _("debug type entry runs off end of `.debug_types' section, ignored"));
+		     _("debug type entry runs off end "
+		       "of `.debug_types' section, ignored"));
 	  break;
 	}
 
@@ -3267,7 +3275,8 @@ dwarf2_build_psymtabs_hard (struct objfi
     {
       struct dwarf2_per_cu_data *this_cu;
 
-      this_cu = dwarf2_find_comp_unit (info_ptr - dwarf2_per_objfile->info.buffer,
+      this_cu = dwarf2_find_comp_unit (info_ptr
+				       - dwarf2_per_objfile->info.buffer,
 				       objfile);
 
       info_ptr = process_psymtab_comp_unit (objfile, this_cu,
@@ -3367,7 +3376,8 @@ create_all_comp_units (struct objfile *o
   all_comp_units = xmalloc (n_allocated
 			    * sizeof (struct dwarf2_per_cu_data *));
 
-  while (info_ptr < dwarf2_per_objfile->info.buffer + dwarf2_per_objfile->info.size)
+  while (info_ptr < dwarf2_per_objfile->info.buffer
+	 + dwarf2_per_objfile->info.size)
     {
       unsigned int length, initial_length_size;
       struct dwarf2_per_cu_data *this_cu;
@@ -3561,7 +3571,8 @@ partial_die_parent_scope (struct partial
       if (grandparent_scope == NULL)
 	parent->scope = parent->name;
       else
-	parent->scope = typename_concat (&cu->comp_unit_obstack, grandparent_scope,
+	parent->scope = typename_concat (&cu->comp_unit_obstack,
+					 grandparent_scope,
 					 parent->name, 0, cu);
     }
   else if (parent->tag == DW_TAG_enumerator)
@@ -3925,8 +3936,8 @@ peek_die_abbrev (gdb_byte *info_ptr, uns
   abbrev = dwarf2_lookup_abbrev (abbrev_number, cu);
   if (!abbrev)
     {
-      error (_("Dwarf Error: Could not find abbrev number %d [in module %s]"), abbrev_number,
-		      bfd_get_filename (abfd));
+      error (_("Dwarf Error: Could not find abbrev number %d [in module %s]"),
+	     abbrev_number, bfd_get_filename (abfd));
     }
 
   return abbrev;
@@ -3975,7 +3986,8 @@ skip_one_die (gdb_byte *buffer, gdb_byte
 	  read_attribute (&attr, &abbrev->attrs[i],
 			  abfd, info_ptr, cu);
 	  if (attr.form == DW_FORM_ref_addr)
-	    complaint (&symfile_complaints, _("ignoring absolute DW_AT_sibling"));
+	    complaint (&symfile_complaints,
+		       _("ignoring absolute DW_AT_sibling"));
 	  else
 	    return buffer + dwarf2_get_ref_die_offset (&attr);
 	}
@@ -4051,7 +4063,8 @@ skip_one_die (gdb_byte *buffer, gdb_byte
 	  goto skip_attribute;
 
 	default:
-	  error (_("Dwarf Error: Cannot handle %s in DWARF reader [in module %s]"),
+	  error (_("Dwarf Error: Cannot handle %s "
+		   "in DWARF reader [in module %s]"),
 		 dwarf_form_name (form),
 		 bfd_get_filename (abfd));
 	}
@@ -4096,13 +4109,15 @@ dwarf2_psymtab_to_symtab (struct partial
     {
       if (pst->readin)
 	{
-	  warning (_("bug: psymtab for %s is already read in."), pst->filename);
+	  warning (_("bug: psymtab for %s is already read in."),
+		   pst->filename);
 	}
       else
 	{
 	  if (info_verbose)
 	    {
-	      printf_filtered (_("Reading in symbols for %s..."), pst->filename);
+	      printf_filtered (_("Reading in symbols for %s..."),
+			       pst->filename);
 	      gdb_flush (gdb_stdout);
 	    }
 
@@ -4249,7 +4264,8 @@ psymtab_to_symtab_1 (struct partial_symt
 /* Load the DIEs associated with PER_CU into memory.  */
 
 static void
-load_full_comp_unit (struct dwarf2_per_cu_data *per_cu, struct objfile *objfile)
+load_full_comp_unit (struct dwarf2_per_cu_data *per_cu,
+		     struct objfile *objfile)
 {
   bfd *abfd = objfile->obfd;
   struct dwarf2_cu *cu;
@@ -5061,8 +5077,9 @@ unsigned_int_compar (const void *ap, con
 }
 
 /* DW_AT_abstract_origin inherits whole DIEs (not just their attributes).
-   Inherit only the children of the DW_AT_abstract_origin DIE not being already
-   referenced by DW_AT_abstract_origin from the children of the current DIE.  */
+   Inherit only the children of the DW_AT_abstract_origin DIE not being
+   already referenced by DW_AT_abstract_origin from the children of the
+   current DIE.  */
 
 static void
 inherit_abstract_dies (struct die_info *die, struct dwarf2_cu *cu)
@@ -5148,8 +5165,9 @@ inherit_abstract_dies (struct die_info *
 	 unsigned_int_compar);
   for (offsetp = offsets + 1; offsetp < offsets_end; offsetp++)
     if (offsetp[-1] == *offsetp)
-      complaint (&symfile_complaints, _("Multiple children of DIE 0x%x refer "
-					"to DIE 0x%x as their abstract origin"),
+      complaint (&symfile_complaints,
+		 _("Multiple children of DIE 0x%x refer "
+		   "to DIE 0x%x as their abstract origin"),
 		 die->offset, *offsetp);
 
   offsetp = offsets;
@@ -5219,7 +5237,8 @@ read_func_scope (struct die_info *die, s
       attr = dwarf2_attr (die, DW_AT_external, cu);
       if (!attr || !DW_UNSND (attr))
 	complaint (&symfile_complaints,
-		   _("cannot get low and high bounds for subprogram DIE at %d"),
+		   _("cannot get low and high bounds "
+		     "for subprogram DIE at %d"),
 		   die->offset);
       return;
     }
@@ -5508,7 +5527,8 @@ dwarf2_ranges_read (unsigned offset, COR
 
       if (ranges_pst != NULL && range_beginning < range_end)
 	addrmap_set_empty (objfile->psymtabs_addrmap,
-			   range_beginning + baseaddr, range_end - 1 + baseaddr,
+			   range_beginning + baseaddr,
+			   range_end - 1 + baseaddr,
 			   ranges_pst);
 
       /* FIXME: This is recording everything as a low-high
@@ -5783,7 +5803,8 @@ dwarf2_record_block_ranges (struct die_i
               if (!base_known)
                 {
                   complaint (&symfile_complaints,
-                             _("Invalid .debug_ranges data (no base address)"));
+			     _("Invalid .debug_ranges data "
+			       "(no base address)"));
                   return;
                 }
 
@@ -6088,9 +6109,9 @@ dwarf2_attach_fields_to_type (struct fie
       TYPE_N_BASECLASSES (type) = fip->nbaseclasses;
     }
 
-  /* Copy the saved-up fields into the field vector.  Start from the head
-     of the list, adding to the tail of the field array, so that they end
-     up in the same order in the array in which they were added to the list.  */
+  /* Copy the saved-up fields into the field vector.  Start from the head of
+     the list, adding to the tail of the field array, so that they end up in
+     the same order in the array in which they were added to the list.  */
   while (nfields-- > 0)
     {
       struct nextfield *fieldp;
@@ -6251,8 +6272,8 @@ dwarf2_add_member_fn (struct field_info 
   if (dwarf2_attr (die, DW_AT_containing_type, cu) != NULL)
     fnp->fcontext = die_containing_type (die, cu);
 
-  /* dwarf2 doesn't have stubbed physical names, so the setting of is_const
-     and is_volatile is irrelevant, as it is needed by gdb_mangle_name only.  */
+  /* dwarf2 doesn't have stubbed physical names, so the setting of is_const and
+     is_volatile is irrelevant, as it is needed by gdb_mangle_name only.  */
 
   /* Get accessibility.  */
   attr = dwarf2_attr (die, DW_AT_accessibility, cu);
@@ -6332,7 +6353,8 @@ dwarf2_add_member_fn (struct field_info 
 	{
 	  /* GCC does this, as of 2008-08-25; PR debug/37237.  */
 	  complaint (&symfile_complaints,
-		     _("Member function \"%s\" (offset %d) is virtual but the vtable offset is not specified"),
+		     _("Member function \"%s\" (offset %d) is virtual "
+		       "but the vtable offset is not specified"),
 		     fieldname, die->offset);
 	  ALLOCATE_CPLUS_STRUCT_TYPE (type);
 	  TYPE_CPLUS_DYNAMIC (type) = 1;
@@ -6653,7 +6675,8 @@ read_structure_type (struct die_info *di
 		  /* Complain if virtual function table field not found.  */
 		  if (i < TYPE_N_BASECLASSES (t))
 		    complaint (&symfile_complaints,
-			       _("virtual function table pointer not found when defining class '%s'"),
+			       _("virtual function table pointer "
+				 "not found when defining class '%s'"),
 			       TYPE_TAG_NAME (type) ? TYPE_TAG_NAME (type) :
 			       "");
 		}
@@ -7302,7 +7325,8 @@ read_module_type (struct die_info *die, 
 
   module_name = dwarf2_name (die, cu);
   if (!module_name)
-    complaint (&symfile_complaints, _("DW_TAG_module has no name, offset 0x%x"),
+    complaint (&symfile_complaints,
+	       _("DW_TAG_module has no name, offset 0x%x"),
                die->offset);
   type = init_type (TYPE_CODE_MODULE, 0, 0, module_name, objfile);
 
@@ -7408,7 +7432,8 @@ read_tag_pointer_type (struct die_info *
 	}
       else if (TYPE_LENGTH (type) != byte_size)
 	{
-	  complaint (&symfile_complaints, _("invalid pointer size %d"), byte_size);
+	  complaint (&symfile_complaints,
+		     _("invalid pointer size %d"), byte_size);
 	}
       else
 	{
@@ -8598,7 +8623,8 @@ load_partial_dies (bfd *abfd, gdb_byte *
 	  && parent_die->has_specification == 0)
 	{
 	  if (part_die->name == NULL)
-	    complaint (&symfile_complaints, _("malformed enumerator DIE ignored"));
+	    complaint (&symfile_complaints,
+		       _("malformed enumerator DIE ignored"));
 	  else if (building_psymtab)
 	    add_psymbol_to_list (part_die->name, strlen (part_die->name), 0,
 				 VAR_DOMAIN, LOC_CONST,
@@ -8807,7 +8833,8 @@ read_partial_die (struct partial_die_inf
 	  /* Ignore absolute siblings, they might point outside of
 	     the current compile unit.  */
 	  if (attr.form == DW_FORM_ref_addr)
-	    complaint (&symfile_complaints, _("ignoring absolute DW_AT_sibling"));
+	    complaint (&symfile_complaints,
+		       _("ignoring absolute DW_AT_sibling"));
 	  else
 	    part_die->sibling = buffer + dwarf2_get_ref_die_offset (&attr);
 	  break;
@@ -8945,7 +8972,8 @@ find_partial_die (unsigned int offset, s
 
   if (pd == NULL)
     internal_error (__FILE__, __LINE__,
-		    _("could not find partial DIE 0x%x in cache [from module %s]\n"),
+		    _("could not find partial DIE 0x%x "
+		      "in cache [from module %s]\n"),
 		    offset, bfd_get_filename (cu->objfile->obfd));
   return pd;
 }
@@ -9012,7 +9040,8 @@ read_attribute_value (struct attribute *
       if (cu->header.version == 2)
 	DW_ADDR (attr) = read_address (abfd, info_ptr, cu, &bytes_read);
       else
-	DW_ADDR (attr) = read_offset (abfd, info_ptr, &cu->header, &bytes_read);
+	DW_ADDR (attr) = read_offset (abfd, info_ptr,
+				      &cu->header, &bytes_read);
       info_ptr += bytes_read;
       break;
     case DW_FORM_addr:
@@ -9431,8 +9460,9 @@ read_indirect_string (bfd *abfd, gdb_byt
     }
   if (str_offset >= dwarf2_per_objfile->str.size)
     {
-      error (_("DW_FORM_strp pointing outside of .debug_str section [in module %s]"),
-		      bfd_get_filename (abfd));
+      error (_("DW_FORM_strp pointing outside of "
+	       ".debug_str section [in module %s]"),
+	     bfd_get_filename (abfd));
       return NULL;
     }
   gdb_assert (HOST_CHAR_BIT == 8);
@@ -9811,7 +9841,8 @@ dwarf_decode_line_header (unsigned int o
     {
       lh->maximum_ops_per_instruction = 1;
       complaint (&symfile_complaints,
-		 _("invalid maximum_ops_per_instruction in `.debug_line' section"));
+		 _("invalid maximum_ops_per_instruction "
+		   "in `.debug_line' section"));
     }
 
   lh->default_is_stmt = read_1_byte (abfd, line_ptr);
@@ -9861,7 +9892,8 @@ dwarf_decode_line_header (unsigned int o
   if (line_ptr > (dwarf2_per_objfile->line.buffer
 		  + dwarf2_per_objfile->line.size))
     complaint (&symfile_complaints,
-	       _("line number info header doesn't fit in `.debug_line' section"));
+	       _("line number info header doesn't "
+		 "fit in `.debug_line' section"));
 
   discard_cleanups (back_to);
   return lh;
@@ -10027,7 +10059,8 @@ dwarf_decode_lines (struct line_header *
 	  else switch (op_code)
 	    {
 	    case DW_LNS_extended_op:
-	      extended_len = read_unsigned_leb128 (abfd, line_ptr, &bytes_read);
+	      extended_len = read_unsigned_leb128 (abfd, line_ptr,
+						   &bytes_read);
 	      line_ptr += bytes_read;
 	      extended_end = line_ptr + extended_len;
 	      extended_op = read_1_byte (abfd, line_ptr);
@@ -11159,7 +11192,8 @@ read_type_die_1 (struct die_info *die, s
       this_type = read_module_type (die, cu);
       break;
     default:
-      complaint (&symfile_complaints, _("unexpected tag in read_type_die: '%s'"),
+      complaint (&symfile_complaints,
+		 _("unexpected tag in read_type_die: '%s'"),
 		 dwarf_tag_name (die->tag));
       break;
     }
@@ -11259,11 +11293,11 @@ determine_prefix (struct die_info *die, 
       }
 }
 
-/* Return a newly-allocated string formed by concatenating PREFIX and
-   SUFFIX with appropriate separator.  If PREFIX or SUFFIX is NULL or empty, then
-   simply copy the SUFFIX or PREFIX, respectively.  If OBS is non-null,
-   perform an obconcat, otherwise allocate storage for the result.  The CU argument
-   is used to determine the language and hence, the appropriate separator.  */
+/* Return a newly-allocated string formed by concatenating PREFIX and SUFFIX
+   with appropriate separator.  If PREFIX or SUFFIX is NULL or empty, then
+   simply copy the SUFFIX or PREFIX, respectively.  If OBS is non-null, perform
+   an obconcat, otherwise allocate storage for the result.  The CU argument is
+   used to determine the language and hence, the appropriate separator.  */
 
 #define MAX_SEP_LEN 7  /* strlen ("__") + strlen ("_MOD_")  */
 
@@ -11274,7 +11308,8 @@ typename_concat (struct obstack *obs, co
   const char *lead = "";
   const char *sep;
 
-  if (suffix == NULL || suffix[0] == '\0' || prefix == NULL || prefix[0] == '\0')
+  if (suffix == NULL || suffix[0] == '\0'
+      || prefix == NULL || prefix[0] == '\0')
     sep = "";
   else if (cu->language == language_java)
     sep = ".";
@@ -11296,7 +11331,8 @@ typename_concat (struct obstack *obs, co
 
   if (obs == NULL)
     {
-      char *retval = xmalloc (strlen (prefix) + MAX_SEP_LEN + strlen (suffix) + 1);
+      char *retval
+	= xmalloc (strlen (prefix) + MAX_SEP_LEN + strlen (suffix) + 1);
 
       strcpy (retval, lead);
       strcat (retval, prefix);
@@ -12452,7 +12488,8 @@ dump_die_shallow (struct ui_file *f, int
 	case DW_FORM_block4:
 	case DW_FORM_block:
 	case DW_FORM_block1:
-	  fprintf_unfiltered (f, "block: size %d", DW_BLOCK (&die->attrs[i])->size);
+	  fprintf_unfiltered (f, "block: size %d",
+			      DW_BLOCK (&die->attrs[i])->size);
 	  break;
 	case DW_FORM_exprloc:
 	  fprintf_unfiltered (f, "expression: size %u",
@@ -12503,7 +12540,8 @@ dump_die_shallow (struct ui_file *f, int
 	case DW_FORM_indirect:
 	  /* the reader will have reduced the indirect form to
 	     the "base form" so this form should not occur */
-	  fprintf_unfiltered (f, "unexpected attribute form: DW_FORM_indirect");
+	  fprintf_unfiltered (f, 
+			      "unexpected attribute form: DW_FORM_indirect");
 	  break;
 	default:
 	  fprintf_unfiltered (f, "unsupported attribute form: %d.",
@@ -12543,7 +12581,8 @@ dump_die_1 (struct ui_file *f, int level
 	}
       else
 	{
-	  fprintf_unfiltered (f, " [not printed, max nesting level reached]\n");
+	  fprintf_unfiltered (f,
+			      " [not printed, max nesting level reached]\n");
 	}
     }
 
@@ -12617,7 +12656,8 @@ dwarf2_get_attr_constant_value (struct a
     return DW_UNSND (attr);
   else
     {
-      complaint (&symfile_complaints, _("Attribute value is not a constant (%s)"),
+      complaint (&symfile_complaints,
+		 _("Attribute value is not a constant (%s)"),
                  dwarf_form_name (attr->form));
       return default_value;
     }
@@ -12817,8 +12857,8 @@ follow_die_sig (struct die_info *src_die
       return die;
     }
 
-  error (_("Dwarf Error: Cannot find signatured DIE at 0x%x referenced from DIE "
-	 "at 0x%x [in module %s]"),
+  error (_("Dwarf Error: Cannot find signatured DIE at 0x%x referenced "
+	 "from DIE at 0x%x [in module %s]"),
 	 sig_type->type_offset, src_die->offset, objfile->name);
 }
 
@@ -13118,7 +13158,8 @@ decode_locdesc (struct dwarf_block *blk,
 	  break;
 
 	case DW_OP_plus_uconst:
-	  stack[stacki] += read_unsigned_leb128 (NULL, (data + i), &bytes_read);
+	  stack[stacki] += read_unsigned_leb128 (NULL, (data + i),
+						 &bytes_read);
 	  i += bytes_read;
 	  break;
 
@@ -13314,7 +13355,8 @@ consume_improper_spaces (const char *p, 
   if (*p == ' ')
     {
       complaint (&symfile_complaints,
-		 _("macro definition contains spaces in formal argument list:\n`%s'"),
+		 _("macro definition contains spaces "
+		   "in formal argument list:\n`%s'"),
 		 body);
 
       while (*p == ' ')
@@ -13505,7 +13547,8 @@ dwarf_decode_macros (struct line_header 
       if (mac_ptr >= mac_end)
         {
 	  /* Complaint is printed during the second pass as GDB will probably
-	     stop the first pass earlier upon finding DW_MACINFO_start_file.  */
+	     stop the first pass earlier upon finding
+	     DW_MACINFO_start_file.  */
 	  break;
         }
 
@@ -13542,8 +13585,8 @@ dwarf_decode_macros (struct line_header 
 	    file = read_unsigned_leb128 (abfd, mac_ptr, &bytes_read);
 	    mac_ptr += bytes_read;
 
-	    current_file = macro_start_file (file, line, current_file, comp_dir,
-					     lh, cu->objfile);
+	    current_file = macro_start_file (file, line, current_file,
+					     comp_dir, lh, cu->objfile);
 	  }
 	  break;
 
@@ -13629,7 +13672,8 @@ dwarf_decode_macros (struct line_header 
 				 _("something-or-other"), line, body);
 		break;
 	      }
-	    if ((line == 0 && !at_commandline) || (line != 0 && at_commandline))
+	    if ((line == 0 && !at_commandline)
+		|| (line != 0 && at_commandline))
 	      complaint (&symfile_complaints,
 			 _("debug info gives %s macro %s with %s line %d: %s"),
 			 at_commandline ? _("command-line") : _("in-file"),
@@ -13657,7 +13701,8 @@ dwarf_decode_macros (struct line_header 
             file = read_unsigned_leb128 (abfd, mac_ptr, &bytes_read);
             mac_ptr += bytes_read;
 
-	    if ((line == 0 && !at_commandline) || (line != 0 && at_commandline))
+	    if ((line == 0 && !at_commandline)
+		|| (line != 0 && at_commandline))
 	      complaint (&symfile_complaints,
 			 _("debug info gives source %d included "
 			   "from %s at %s line %d"),
@@ -13679,7 +13724,8 @@ dwarf_decode_macros (struct line_header 
         case DW_MACINFO_end_file:
           if (! current_file)
 	    complaint (&symfile_complaints,
-		       _("macro debug info has an unmatched `close_file' directive"));
+		       _("macro debug info has an unmatched "
+			 "`close_file' directive"));
           else
             {
               current_file = current_file->included_by;
@@ -13704,7 +13750,8 @@ dwarf_decode_macros (struct line_header 
                   next_type = read_1_byte (abfd, mac_ptr);
                   if (next_type != 0)
 		    complaint (&symfile_complaints,
-			       _("no terminating 0-type entry for macros in `.debug_macinfo' section"));
+			       _("no terminating 0-type entry for "
+				 "macros in `.debug_macinfo' section"));
 
                   return;
                 }
@@ -15004,12 +15051,14 @@ write_one_signatured_type (void **slot, 
 
   write_psymbols (info->symtab,
 		  info->psyms_seen,
-		  info->objfile->global_psymbols.list + psymtab->globals_offset,
+		  info->objfile->global_psymbols.list
+		  + psymtab->globals_offset,
 		  psymtab->n_global_syms, info->cu_index,
 		  0);
   write_psymbols (info->symtab,
 		  info->psyms_seen,
-		  info->objfile->static_psymbols.list + psymtab->statics_offset,
+		  info->objfile->static_psymbols.list
+		  + psymtab->statics_offset,
 		  psymtab->n_static_syms, info->cu_index,
 		  1);
 
@@ -15320,8 +15369,9 @@ static void
 show_dwarf2_always_disassemble (struct ui_file *file, int from_tty,
 				struct cmd_list_element *c, const char *value)
 {
-  fprintf_filtered (file, _("\
-Whether to always disassemble DWARF expressions is %s.\n"),
+  fprintf_filtered (file,
+		    _("Whether to always disassemble "
+		      "DWARF expressions is %s.\n"),
 		    value);
 }
 
