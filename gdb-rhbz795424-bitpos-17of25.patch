From 9cc9d25ec1e90f30c80c00434e614a0b9bd065f0 Mon Sep 17 00:00:00 2001
From: siddhesh <siddhesh>
Date: Tue, 25 Sep 2012 12:48:52 +0000
Subject: [PATCH] 	* ada-valprint.c (ada_val_print_1): Eliminate single-use
 	variable LEN.
 	* alpha-tdep.c (alpha_extract_return_value): Use TYPE_LENGTH
 	directly.
 	(alpha_store_return_value): Likewise.
 	* amd64-tdep.c (amd64_classify_aggregate): Likewise.
 	(amd64_push_arguments): Likewise.
 	* ax-gdb.c (gen_trace_static_fields): Likewise.
 	(gen_traced_pop): Likewise.
 	* bfin-tdep.c (bfin_push_dummy_call): Likewise.
 	* breakpoint.c (update_watchpoint): Likewise.
 	* findcmd.c (parse_find_args): Use local variable for type
 	instead of length.
 	* findvar.c (default_read_var_value): Use TYPE_LENGTH directly.
 	* h8300-tdep.c (h8300h_extract_return_value): Likewise.
 	(h8300_store_return_value): Likewise.
 	* i386-darwin-tdep.c (i386_darwin_push_dummy_call): Likewise.
 	Use i386_darwin_arg_type_alignment directly.
 	* infcall.c (call_function_by_hand): Use TYPE_LENGTH directly.
 	* lm32-tdep.c (lm32_push_dummy_call): Likewise.
 	* m68hc11-tdep.c (m68hc11_push_dummy_call): Likewise.
 	(m68hc11_extract_return_value): Likewise.
 	* mep-tdep.c (mep_push_dummy_call): Likewise.
 	* printcmd.c (float_type_from_length): Likewise.
 	* s390-tdep.c (s390_value_from_register): Likewise.
 	* stack.c (read_frame_arg): Likewise.
 	* tracepoint.c (encode_actions_1): Likewise.
 	* valops.c (value_fetch_lazy): Use local variable for type
 	instead of length.  Use TYPE_LENGTH directly.
 	* value.c (value_contents_equal): Use TYPE_LENGTH directly.

---
 gdb/ChangeLog          |   33 +++++++++++++++++++++++++++++++++
 gdb/ada-valprint.c     |    3 +--
 gdb/alpha-tdep.c       |   14 ++++++--------
 gdb/amd64-tdep.c       |   11 ++++-------
 gdb/ax-gdb.c           |   13 +++++++------
 gdb/bfin-tdep.c        |    6 ++----
 gdb/breakpoint.c       |    5 ++---
 gdb/findcmd.c          |   10 +++++-----
 gdb/findvar.c          |    8 +++-----
 gdb/h8300-tdep.c       |   19 ++++++++-----------
 gdb/i386-darwin-tdep.c |   11 +++++------
 gdb/infcall.c          |    6 ++----
 gdb/lm32-tdep.c        |    7 +++----
 gdb/m68hc11-tdep.c     |   18 +++++++-----------
 gdb/mep-tdep.c         |    3 +--
 gdb/printcmd.c         |    7 +++----
 gdb/s390-tdep.c        |    6 ++++--
 gdb/stack.c            |   11 ++++++-----
 gdb/tracepoint.c       |    8 +++++---
 gdb/valops.c           |   12 ++++++------
 gdb/value.c            |    7 +++----
 21 files changed, 116 insertions(+), 102 deletions(-)

Index: gdb-7.2/gdb/ada-valprint.c
===================================================================
--- gdb-7.2.orig/gdb/ada-valprint.c
+++ gdb-7.2/gdb/ada-valprint.c
@@ -730,9 +730,8 @@ ada_val_print_1 (struct type *type, cons
       if (ada_is_fixed_point_type (type))
 	{
 	  LONGEST v = unpack_long (type, valaddr);
-	  int len = TYPE_LENGTH (type);
 
-	  fprintf_filtered (stream, len < 4 ? "%.11g" : "%.17g",
+	  fprintf_filtered (stream, TYPE_LENGTH (type) < 4 ? "%.11g" : "%.17g",
 			    (double) ada_fixed_to_float (type, v));
 	  return 0;
 	}
Index: gdb-7.2/gdb/alpha-tdep.c
===================================================================
--- gdb-7.2.orig/gdb/alpha-tdep.c
+++ gdb-7.2/gdb/alpha-tdep.c
@@ -468,14 +468,13 @@ alpha_extract_return_value (struct type 
 {
   struct gdbarch *gdbarch = get_regcache_arch (regcache);
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
-  int length = TYPE_LENGTH (valtype);
   gdb_byte raw_buffer[ALPHA_REGISTER_SIZE];
   ULONGEST l;
 
   switch (TYPE_CODE (valtype))
     {
     case TYPE_CODE_FLT:
-      switch (length)
+      switch (TYPE_LENGTH (valtype))
 	{
 	case 4:
 	  regcache_cooked_read (regcache, ALPHA_FP0_REGNUM, raw_buffer);
@@ -497,7 +496,7 @@ alpha_extract_return_value (struct type 
       break;
 
     case TYPE_CODE_COMPLEX:
-      switch (length)
+      switch (TYPE_LENGTH (valtype))
 	{
 	case 8:
 	  /* ??? This isn't correct wrt the ABI, but it's what GCC does.  */
@@ -522,7 +521,7 @@ alpha_extract_return_value (struct type 
     default:
       /* Assume everything else degenerates to an integer.  */
       regcache_cooked_read_unsigned (regcache, ALPHA_V0_REGNUM, &l);
-      store_unsigned_integer (valbuf, length, byte_order, l);
+      store_unsigned_integer (valbuf, TYPE_LENGTH (valtype), byte_order, l);
       break;
     }
 }
@@ -535,14 +534,13 @@ alpha_store_return_value (struct type *v
 			  const gdb_byte *valbuf)
 {
   struct gdbarch *gdbarch = get_regcache_arch (regcache);
-  int length = TYPE_LENGTH (valtype);
   gdb_byte raw_buffer[ALPHA_REGISTER_SIZE];
   ULONGEST l;
 
   switch (TYPE_CODE (valtype))
     {
     case TYPE_CODE_FLT:
-      switch (length)
+      switch (TYPE_LENGTH (valtype))
 	{
 	case 4:
 	  alpha_lds (gdbarch, raw_buffer, valbuf);
@@ -565,7 +563,7 @@ alpha_store_return_value (struct type *v
       break;
 
     case TYPE_CODE_COMPLEX:
-      switch (length)
+      switch (TYPE_LENGTH (valtype))
 	{
 	case 8:
 	  /* ??? This isn't correct wrt the ABI, but it's what GCC does.  */
@@ -592,7 +590,7 @@ alpha_store_return_value (struct type *v
       /* Assume everything else degenerates to an integer.  */
       /* 32-bit values must be sign-extended to 64 bits
 	 even if the base data type is unsigned.  */
-      if (length == 4)
+      if (TYPE_LENGTH (valtype) == 4)
 	valtype = builtin_type (gdbarch)->builtin_int32;
       l = unpack_long (valtype, valbuf);
       regcache_cooked_write_unsigned (regcache, ALPHA_V0_REGNUM, l);
Index: gdb-7.2/gdb/amd64-tdep.c
===================================================================
--- gdb-7.2.orig/gdb/amd64-tdep.c
+++ gdb-7.2/gdb/amd64-tdep.c
@@ -430,12 +430,10 @@ amd64_non_pod_p (struct type *type)
 static void
 amd64_classify_aggregate (struct type *type, enum amd64_reg_class class[2])
 {
-  int len = TYPE_LENGTH (type);
-
   /* 1. If the size of an object is larger than two eightbytes, or in
         C++, is a non-POD structure or union type, or contains
         unaligned fields, it has class memory.  */
-  if (len > 16 || amd64_non_pod_p (type))
+  if (TYPE_LENGTH (type) > 16 || amd64_non_pod_p (type))
     {
       class[0] = class[1] = AMD64_MEMORY;
       return;
@@ -455,7 +453,7 @@ amd64_classify_aggregate (struct type *t
 
       /* All fields in an array have the same type.  */
       amd64_classify (subtype, class);
-      if (len > 8 && class[1] == AMD64_NO_CLASS)
+      if (TYPE_LENGTH (type) > 8 && class[1] == AMD64_NO_CLASS)
 	class[1] = class[0];
     }
   else
@@ -823,10 +821,9 @@ amd64_push_arguments (struct regcache *r
     {
       struct type *type = value_type (stack_args[i]);
       const gdb_byte *valbuf = value_contents (stack_args[i]);
-      int len = TYPE_LENGTH (type);
       CORE_ADDR arg_addr = sp + element * 8;
 
-      write_memory (arg_addr, valbuf, len);
+      write_memory (arg_addr, valbuf, TYPE_LENGTH (type));
       if (arg_addr_regno[i] >= 0)
         {
           /* We also need to store the address of that argument in
@@ -837,7 +834,7 @@ amd64_push_arguments (struct regcache *r
           store_unsigned_integer (buf, 8, byte_order, arg_addr);
           regcache_cooked_write (regcache, arg_addr_regno[i], buf);
         }
-      element += ((len + 7) / 8);
+      element += ((TYPE_LENGTH (type) + 7) / 8);
     }
 
   /* The psABI says that "For calls that may call functions that use
Index: gdb-7.2/gdb/ax-gdb.c
===================================================================
--- gdb-7.2.orig/gdb/ax-gdb.c
+++ gdb-7.2/gdb/ax-gdb.c
@@ -357,9 +357,9 @@ gen_trace_static_fields (struct gdbarch 
 	    {
 	    case axs_lvalue_memory:
 	      {
-		int length = TYPE_LENGTH (check_typedef (value.type));
-
-		ax_const_l (ax, length);
+	        /* Initialize the TYPE_LENGTH if it is a typedef.  */
+	        check_typedef (value.type);
+		ax_const_l (ax, TYPE_LENGTH (value.type));
 		ax_simple (ax, aop_trace);
 	      }
 	      break;
@@ -404,12 +404,15 @@ gen_traced_pop (struct gdbarch *gdbarch,
 	{
 	  int length = TYPE_LENGTH (check_typedef (value->type));
 
+	  /* Initialize the TYPE_LENGTH if it is a typedef.  */
+	  check_typedef (value->type);
+
 	  /* There's no point in trying to use a trace_quick bytecode
 	     here, since "trace_quick SIZE pop" is three bytes, whereas
 	     "const8 SIZE trace" is also three bytes, does the same
 	     thing, and the simplest code which generates that will also
 	     work correctly for objects with large sizes.  */
-	  ax_const_l (ax, length);
+	  ax_const_l (ax, TYPE_LENGTH (value->type));
 	  ax_simple (ax, aop_trace);
 	}
 	break;
Index: gdb-7.2/gdb/breakpoint.c
===================================================================
--- gdb-7.2.orig/gdb/breakpoint.c
+++ gdb-7.2/gdb/breakpoint.c
@@ -1492,11 +1492,10 @@ update_watchpoint (struct breakpoint *b,
 		      && TYPE_CODE (vtype) != TYPE_CODE_ARRAY))
 		{
 		  CORE_ADDR addr;
-		  int len, type;
+		  int type;
 		  struct bp_location *loc, **tmp;
 
 		  addr = value_address (v);
-		  len = TYPE_LENGTH (value_type (v));
 		  type = hw_write;
 		  if (b->type == bp_read_watchpoint)
 		    type = hw_read;
@@ -1511,7 +1510,7 @@ update_watchpoint (struct breakpoint *b,
 
 		  loc->pspace = frame_pspace;
 		  loc->address = addr;
-		  loc->length = len;
+		  loc->length = TYPE_LENGTH (value_type (v));
 		  loc->watchpoint_type = type;
 		}
 	    }
Index: gdb-7.2/gdb/findcmd.c
===================================================================
--- gdb-7.2.orig/gdb/findcmd.c
+++ gdb-7.2/gdb/findcmd.c
@@ -200,16 +200,16 @@ parse_find_args (char *args, ULONGEST *m
   while (*s != '\0')
     {
       LONGEST x;
-      int val_bytes;
+      struct type *t;
 
       while (isspace (*s))
 	++s;
 
       v = parse_to_comma_and_eval (&s);
-      val_bytes = TYPE_LENGTH (value_type (v));
+      t = value_type (v);
 
       increase_pattern_buffer (&pattern_buf, &pattern_buf_end,
-			       &pattern_buf_size, val_bytes);
+			       &pattern_buf_size, TYPE_LENGTH (t));
 
 
       if (size != '\0')
@@ -236,8 +236,8 @@ parse_find_args (char *args, ULONGEST *m
 	}
       else
 	{
-	  memcpy (pattern_buf_end, value_contents (v), val_bytes);
-	  pattern_buf_end += val_bytes;
+	  memcpy (pattern_buf_end, value_contents (v), TYPE_LENGTH (t));
+	  pattern_buf_end += TYPE_LENGTH (t);
 	}
 
       if (*s == ',')
Index: gdb-7.2/gdb/h8300-tdep.c
===================================================================
--- gdb-7.2.orig/gdb/h8300-tdep.c
+++ gdb-7.2/gdb/h8300-tdep.c
@@ -787,16 +787,15 @@ h8300h_extract_return_value (struct type
 {
   struct gdbarch *gdbarch = get_regcache_arch (regcache);
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
-  int len = TYPE_LENGTH (type);
   ULONGEST c, addr;
 
-  switch (len)
+  switch (TYPE_LENGTH (type))
     {
     case 1:
     case 2:
     case 4:
       regcache_cooked_read_unsigned (regcache, E_RET0_REGNUM, &c);
-      store_unsigned_integer (valbuf, len, byte_order, c);
+      store_unsigned_integer (valbuf, TYPE_LENGTH (type), byte_order, c);
       break;
     case 8:			/* long long is now 8 bytes.  */
       if (TYPE_CODE (type) == TYPE_CODE_INT)
@@ -854,18 +853,17 @@ h8300_store_return_value (struct type *t
 {
   struct gdbarch *gdbarch = get_regcache_arch (regcache);
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
-  int len = TYPE_LENGTH (type);
   ULONGEST val;
 
-  switch (len)
+  switch (TYPE_LENGTH (type))
     {
     case 1:
     case 2:			/* short... */
-      val = extract_unsigned_integer (valbuf, len, byte_order);
+      val = extract_unsigned_integer (valbuf, TYPE_LENGTH (type), byte_order);
       regcache_cooked_write_unsigned (regcache, E_RET0_REGNUM, val);
       break;
     case 4:			/* long, float */
-      val = extract_unsigned_integer (valbuf, len, byte_order);
+      val = extract_unsigned_integer (valbuf, TYPE_LENGTH (type), byte_order);
       regcache_cooked_write_unsigned (regcache, E_RET0_REGNUM,
 				      (val >> 16) & 0xffff);
       regcache_cooked_write_unsigned (regcache, E_RET1_REGNUM, val & 0xffff);
@@ -883,19 +881,18 @@ h8300h_store_return_value (struct type *
 {
   struct gdbarch *gdbarch = get_regcache_arch (regcache);
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
-  int len = TYPE_LENGTH (type);
   ULONGEST val;
 
-  switch (len)
+  switch (TYPE_LENGTH (type))
     {
     case 1:
     case 2:
     case 4:			/* long, float */
-      val = extract_unsigned_integer (valbuf, len, byte_order);
+      val = extract_unsigned_integer (valbuf, TYPE_LENGTH (type), byte_order);
       regcache_cooked_write_unsigned (regcache, E_RET0_REGNUM, val);
       break;
     case 8:
-      val = extract_unsigned_integer (valbuf, len, byte_order);
+      val = extract_unsigned_integer (valbuf, TYPE_LENGTH (type), byte_order);
       regcache_cooked_write_unsigned (regcache, E_RET0_REGNUM,
 				      (val >> 32) & 0xffffffff);
       regcache_cooked_write_unsigned (regcache, E_RET1_REGNUM,
Index: gdb-7.2/gdb/i386-darwin-tdep.c
===================================================================
--- gdb-7.2.orig/gdb/i386-darwin-tdep.c
+++ gdb-7.2/gdb/i386-darwin-tdep.c
@@ -197,13 +197,12 @@ i386_darwin_push_dummy_call (struct gdba
             }
           else
             {
-              int len = TYPE_LENGTH (arg_type);
-              int align = i386_darwin_arg_type_alignment (arg_type);
-
-              args_space = align_up (args_space, align);
+              args_space = align_up (args_space,
+				     i386_darwin_arg_type_alignment (arg_type));
               if (write_pass)
                 write_memory (sp + args_space,
-                              value_contents_all (args[i]), len);
+                              value_contents_all (args[i]),
+			      TYPE_LENGTH (arg_type));
 
               /* The System V ABI says that:
                  
@@ -212,7 +211,7 @@ i386_darwin_push_dummy_call (struct gdba
                  depending on the size of the argument."
                  
                  This makes sure the stack stays word-aligned.  */
-              args_space += align_up (len, 4);
+              args_space += align_up (TYPE_LENGTH (arg_type), 4);
             }
         }
 
Index: gdb-7.2/gdb/infcall.c
===================================================================
--- gdb-7.2.orig/gdb/infcall.c
+++ gdb-7.2/gdb/infcall.c
@@ -741,13 +741,11 @@ call_function_by_hand (struct value *fun
 
   if (struct_return || lang_struct_return)
     {
-      int len = TYPE_LENGTH (values_type);
-
       if (gdbarch_inner_than (gdbarch, 1, 2))
 	{
 	  /* Stack grows downward.  Align STRUCT_ADDR and SP after
              making space for the return value.  */
-	  sp -= len;
+	  sp -= TYPE_LENGTH (values_type);
 	  if (gdbarch_frame_align_p (gdbarch))
 	    sp = gdbarch_frame_align (gdbarch, sp);
 	  struct_addr = sp;
@@ -759,7 +757,7 @@ call_function_by_hand (struct value *fun
 	  if (gdbarch_frame_align_p (gdbarch))
 	    sp = gdbarch_frame_align (gdbarch, sp);
 	  struct_addr = sp;
-	  sp += len;
+	  sp += TYPE_LENGTH (values_type);
 	  if (gdbarch_frame_align_p (gdbarch))
 	    sp = gdbarch_frame_align (gdbarch, sp);
 	}
Index: gdb-7.2/gdb/lm32-tdep.c
===================================================================
--- gdb-7.2.orig/gdb/lm32-tdep.c
+++ gdb-7.2/gdb/lm32-tdep.c
@@ -261,7 +261,6 @@ lm32_push_dummy_call (struct gdbarch *gd
       struct value *arg = args[i];
       struct type *arg_type = check_typedef (value_type (arg));
       gdb_byte *contents;
-      int len;
       int j;
       int reg;
       ULONGEST val;
@@ -285,8 +284,8 @@ lm32_push_dummy_call (struct gdbarch *gd
       /* FIXME: Handle structures.  */
 
       contents = (gdb_byte *) value_contents (arg);
-      len = TYPE_LENGTH (arg_type);
-      val = extract_unsigned_integer (contents, len, byte_order);
+      val = extract_unsigned_integer (contents, TYPE_LENGTH (arg_type),
+				      byte_order);
 
       /* First num_arg_regs parameters are passed by registers, 
          and the rest are passed on the stack.  */
@@ -294,7 +293,7 @@ lm32_push_dummy_call (struct gdbarch *gd
 	regcache_cooked_write_unsigned (regcache, first_arg_reg + i, val);
       else
 	{
-	  write_memory (sp, (void *) &val, len);
+	  write_memory (sp, (void *) &val, TYPE_LENGTH (arg_type));
 	  sp -= 4;
 	}
     }
Index: gdb-7.2/gdb/m68hc11-tdep.c
===================================================================
--- gdb-7.2.orig/gdb/m68hc11-tdep.c
+++ gdb-7.2/gdb/m68hc11-tdep.c
@@ -1169,7 +1169,6 @@ m68hc11_push_dummy_call (struct gdbarch 
   int first_stack_argnum;
   struct type *type;
   char *val;
-  int len;
   char buf[2];
   
   first_stack_argnum = 0;
@@ -1180,19 +1179,18 @@ m68hc11_push_dummy_call (struct gdbarch 
   else if (nargs > 0)
     {
       type = value_type (args[0]);
-      len = TYPE_LENGTH (type);
 
       /* First argument is passed in D and X registers.  */
-      if (len <= 4)
+      if (TYPE_LENGTH (type) <= 4)
         {
           ULONGEST v;
 
           v = extract_unsigned_integer (value_contents (args[0]),
-					len, byte_order);
+					TYPE_LENGTH (type), byte_order);
           first_stack_argnum = 1;
 
           regcache_cooked_write_unsigned (regcache, HARD_D_REGNUM, v);
-          if (len > 2)
+          if (TYPE_LENGTH (type) > 2)
             {
               v >>= 16;
               regcache_cooked_write_unsigned (regcache, HARD_X_REGNUM, v);
@@ -1203,9 +1201,8 @@ m68hc11_push_dummy_call (struct gdbarch 
   for (argnum = nargs - 1; argnum >= first_stack_argnum; argnum--)
     {
       type = value_type (args[argnum]);
-      len = TYPE_LENGTH (type);
 
-      if (len & 1)
+      if (TYPE_LENGTH (type) & 1)
         {
           static char zero = 0;
 
@@ -1213,8 +1210,8 @@ m68hc11_push_dummy_call (struct gdbarch 
           write_memory (sp, &zero, 1);
         }
       val = (char*) value_contents (args[argnum]);
-      sp -= len;
-      write_memory (sp, val, len);
+      sp -= TYPE_LENGTH (type);
+      write_memory (sp, val, TYPE_LENGTH (type));
     }
 
   /* Store return address.  */
@@ -1286,11 +1283,10 @@ static void
 m68hc11_extract_return_value (struct type *type, struct regcache *regcache,
                               void *valbuf)
 {
-  int len = TYPE_LENGTH (type);
   char buf[M68HC11_REG_SIZE];
 
   regcache_raw_read (regcache, HARD_D_REGNUM, buf);
-  switch (len)
+  switch (TYPE_LENGTH (type))
     {
     case 1:
       memcpy (valbuf, buf + 1, 1);
Index: gdb-7.2/gdb/mep-tdep.c
===================================================================
--- gdb-7.2.orig/gdb/mep-tdep.c
+++ gdb-7.2/gdb/mep-tdep.c
@@ -2335,11 +2335,10 @@ mep_push_dummy_call (struct gdbarch *gdb
 
   for (i = 0; i < argc; i++)
     {
-      unsigned arg_size = TYPE_LENGTH (value_type (argv[i]));
       ULONGEST value;
 
       /* Arguments that fit in a GPR get expanded to fill the GPR.  */
-      if (arg_size <= MEP_GPR_SIZE)
+      if (TYPE_LENGTH (value_type (argv[i])) <= MEP_GPR_SIZE)
         value = extract_unsigned_integer (value_contents (argv[i]),
                                           TYPE_LENGTH (value_type (argv[i])),
 					  byte_order);
Index: gdb-7.2/gdb/printcmd.c
===================================================================
--- gdb-7.2.orig/gdb/printcmd.c
+++ gdb-7.2/gdb/printcmd.c
@@ -337,13 +337,12 @@ float_type_from_length (struct type *typ
 {
   struct gdbarch *gdbarch = get_type_arch (type);
   const struct builtin_type *builtin = builtin_type (gdbarch);
-  unsigned int len = TYPE_LENGTH (type);
 
-  if (len == TYPE_LENGTH (builtin->builtin_float))
+  if (TYPE_LENGTH (type) == TYPE_LENGTH (builtin->builtin_float))
     type = builtin->builtin_float;
-  else if (len == TYPE_LENGTH (builtin->builtin_double))
+  else if (TYPE_LENGTH (type) == TYPE_LENGTH (builtin->builtin_double))
     type = builtin->builtin_double;
-  else if (len == TYPE_LENGTH (builtin->builtin_long_double))
+  else if (TYPE_LENGTH (type) == TYPE_LENGTH (builtin->builtin_long_double))
     type = builtin->builtin_long_double;
 
   return type;
Index: gdb-7.2/gdb/s390-tdep.c
===================================================================
--- gdb-7.2.orig/gdb/s390-tdep.c
+++ gdb-7.2/gdb/s390-tdep.c
@@ -320,9 +320,10 @@ s390_value_from_register (struct type *t
 			  struct frame_info *frame)
 {
   struct value *value = default_value_from_register (type, regnum, frame);
-  int len = TYPE_LENGTH (type);
+  check_typedef (type);
 
-  if (regnum >= S390_F0_REGNUM && regnum <= S390_F15_REGNUM && len < 8)
+  if (regnum >= S390_F0_REGNUM && regnum <= S390_F15_REGNUM
+      && TYPE_LENGTH (type) < 8)
     set_value_offset (value, 0);
 
   return value;
Index: gdb-7.2/gdb/tracepoint.c
===================================================================
--- gdb-7.2.orig/gdb/tracepoint.c
+++ gdb-7.2/gdb/tracepoint.c
@@ -1306,7 +1306,7 @@ encode_actions_1 (struct command_line *a
 		}
 	      else
 		{
-		  unsigned long addr, len;
+		  unsigned long addr;
 		  struct cleanup *old_chain = NULL;
 		  struct cleanup *old_chain1 = NULL;
 
@@ -1336,8 +1336,10 @@ encode_actions_1 (struct command_line *a
 		      /* safe because we know it's a simple expression */
 		      tempval = evaluate_expression (exp);
 		      addr = value_address (tempval);
-		      len = TYPE_LENGTH (check_typedef (exp->elts[1].type));
-		      add_memrange (collect, memrange_absolute, addr, len);
+		      /* Initialize the TYPE_LENGTH if it is a typedef.  */
+		      check_typedef (exp->elts[1].type);
+		      add_memrange (collect, memrange_absolute, addr,
+				    TYPE_LENGTH (exp->elts[1].type));
 		      break;
 
 		    case OP_VAR_VALUE:
Index: gdb-7.2/gdb/valops.c
===================================================================
--- gdb-7.2.orig/gdb/valops.c
+++ gdb-7.2/gdb/valops.c
@@ -1005,14 +1005,14 @@ value_fetch_lazy (struct value *val)
 					  + offset),
 					 value_bitpos (val),
 					 value_bitsize (val));
-      int length = TYPE_LENGTH (type);
 
       if (!value_bits_valid (val,
 			     TARGET_CHAR_BIT * offset + value_bitpos (val),
 			     value_bitsize (val)))
 	error (_("value has been optimized out"));
 
-      store_signed_integer (value_contents_raw (val), length, byte_order, num);
+      store_signed_integer (value_contents_raw (val), TYPE_LENGTH (type),
+			    byte_order, num);
     }
   else if (VALUE_LVAL (val) == lval_memory)
     {
@@ -1021,15 +1021,17 @@ value_fetch_lazy (struct value *val)
       if (object_address_get_data (value_type (val), &addr))
 	{
 	  struct type *type = value_enclosing_type (val);
-	  int length = TYPE_LENGTH (check_typedef (type));
+	  check_typedef (type);
 
-	  if (length)
+	  if (TYPE_LENGTH (type))
 	    {
 	      addr += value_offset (val);
 	      if (value_stack (val))
-		read_stack (addr, value_contents_all_raw (val), length);
+		read_stack (addr, value_contents_all_raw (val),
+			    TYPE_LENGTH (type));
 	      else
-		read_memory (addr, value_contents_all_raw (val), length);
+		read_memory (addr, value_contents_all_raw (val),
+			     TYPE_LENGTH (type));
 	    }
 	}
     }
Index: gdb-7.2/gdb/value.c
===================================================================
--- gdb-7.2.orig/gdb/value.c
+++ gdb-7.2/gdb/value.c
@@ -492,15 +492,14 @@ value_contents_equal (struct value *val1
 {
   struct type *type1;
   struct type *type2;
-  int len;
 
   type1 = check_typedef (value_type (val1));
   type2 = check_typedef (value_type (val2));
-  len = TYPE_LENGTH (type1);
-  if (len != TYPE_LENGTH (type2))
+  if (TYPE_LENGTH (type1) != TYPE_LENGTH (type2))
     return 0;
 
-  return (memcmp (value_contents (val1), value_contents (val2), len) == 0);
+  return (memcmp (value_contents (val1), value_contents (val2),
+		  TYPE_LENGTH (type1)) == 0);
 }
 
 int
