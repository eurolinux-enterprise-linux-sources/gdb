commit 03f2bd594285c4077619f9039748ac7389cffaef
Author: Jan Kratochvil <jan.kratochvil@redhat.com>
Date:   Sun Apr 24 08:02:21 2011 +0000

    gdb/
    	* NEWS: Document the new gdbserver --once option.
    
    gdb/doc/
    	* gdb.texinfo (Starting and Stopping Trace Experiments): New anchor
    	for disconnected tracing.
    	(Multi-Process Mode for @code{gdbserver}): Mention --multi and
    	extended-remote relationship.  Mention --once.
    	(TCP port allocation lifecycle of @code{gdbserver}): New.
    
    gdb/gdbserver/
    	* remote-utils.c (handle_accept_event): Close LISTEN_DESC only if
    	RUN_ONCE.  Comment for the LISTEN_DESC delete_file_handler call.
    	(remote_prepare): New function with most of the TCP code from ...
    	(remote_open): ... here.  Detect PORT here unconditionally.  Move also
    	setting transport_is_reliable.
    	* server.c (run_once): New variable.
    	(gdbserver_usage): Document it.
    	(main): Set run_once for `--once'.  Call remote_prepare.  Exit after
    	the first run if RUN_ONCE.
    	* server.h (run_once, remote_prepare): New declarations.
    
    gdb/testsuite/
    	* gdb.base/solib-disc.exp: Set gdbserver_reconnect_p.
    	* lib/gdb.exp (gdb_init): Clear gdbserver_reconnect_p.
    	* lib/gdbserver-support.exp (gdbserver_start): Add `--once' if
    	!gdbserver_reconnect_p..
    	(gdbserver_reconnect): Call error if !gdbserver_reconnect_p..

Index: gdb-7.2/gdb/gdbserver/remote-utils.c
===================================================================
--- gdb-7.2.orig/gdb/gdbserver/remote-utils.c	2010-07-01 12:36:11.000000000 +0200
+++ gdb-7.2/gdb/gdbserver/remote-utils.c	2015-10-05 22:19:40.001905554 +0200
@@ -170,14 +170,12 @@ handle_accept_event (int err, gdb_client
 	      (char *) &tmp, sizeof (tmp));
 
 #ifndef USE_WIN32API
-  close (listen_desc);		/* No longer need this */
-
   signal (SIGPIPE, SIG_IGN);	/* If we don't do this, then gdbserver simply
 				   exits when the remote side dies.  */
-#else
-  closesocket (listen_desc);	/* No longer need this */
 #endif
 
+  /* Even if !RUN_ONCE no longer notice new connections.  Still keep the
+     descriptor open for add_file_handler to wait for a new connection.  */
   delete_file_handler (listen_desc);
 
   /* Convert IP address to string.  */
@@ -200,6 +198,62 @@ handle_accept_event (int err, gdb_client
   return 0;
 }
 
+/* Prepare for a later connection to a remote debugger.
+   NAME is the filename used for communication.  */
+
+void
+remote_prepare (char *name)
+{
+  char *port_str;
+#ifdef USE_WIN32API
+  static int winsock_initialized;
+#endif
+  int port;
+  struct sockaddr_in sockaddr;
+  socklen_t tmp;
+  char *port_end;
+
+  port_str = strchr (name, ':');
+  if (port_str == NULL)
+    {
+      transport_is_reliable = 0;
+      return;
+    }
+
+  port = strtoul (port_str + 1, &port_end, 10);
+  if (port_str[1] == '\0' || *port_end != '\0')
+    fatal ("Bad port argument: %s", name);
+
+#ifdef USE_WIN32API
+  if (!winsock_initialized)
+    {
+      WSADATA wsad;
+
+      WSAStartup (MAKEWORD (1, 0), &wsad);
+      winsock_initialized = 1;
+    }
+#endif
+
+  listen_desc = socket (PF_INET, SOCK_STREAM, IPPROTO_TCP);
+  if (listen_desc == -1)
+    perror_with_name ("Can't open socket");
+
+  /* Allow rapid reuse of this port. */
+  tmp = 1;
+  setsockopt (listen_desc, SOL_SOCKET, SO_REUSEADDR, (char *) &tmp,
+	      sizeof (tmp));
+
+  sockaddr.sin_family = PF_INET;
+  sockaddr.sin_port = htons (port);
+  sockaddr.sin_addr.s_addr = INADDR_ANY;
+
+  if (bind (listen_desc, (struct sockaddr *) &sockaddr, sizeof (sockaddr))
+      || listen (listen_desc, 1))
+    perror_with_name ("Can't bind address");
+
+  transport_is_reliable = 1;
+}
+
 /* Open a connection to a remote debugger.
    NAME is the filename used for communication.  */
 
@@ -274,8 +328,6 @@ remote_open (char *name)
 
       fprintf (stderr, "Remote debugging using %s\n", name);
 
-      transport_is_reliable = 0;
-
       enable_async_notification (remote_desc);
 
       /* Register the event loop handler.  */
@@ -284,63 +336,21 @@ remote_open (char *name)
     }
   else
     {
-#ifdef USE_WIN32API
-      static int winsock_initialized;
-#endif
       int port;
+      socklen_t len;
       struct sockaddr_in sockaddr;
-      socklen_t tmp;
-      char *port_end;
 
-      port = strtoul (port_str + 1, &port_end, 10);
-      if (port_str[1] == '\0' || *port_end != '\0')
-	fatal ("Bad port argument: %s", name);
-
-#ifdef USE_WIN32API
-      if (!winsock_initialized)
-	{
-	  WSADATA wsad;
-
-	  WSAStartup (MAKEWORD (1, 0), &wsad);
-	  winsock_initialized = 1;
-	}
-#endif
-
-      listen_desc = socket (PF_INET, SOCK_STREAM, IPPROTO_TCP);
-      if (listen_desc == -1)
-	perror_with_name ("Can't open socket");
-
-      /* Allow rapid reuse of this port. */
-      tmp = 1;
-      setsockopt (listen_desc, SOL_SOCKET, SO_REUSEADDR, (char *) &tmp,
-		  sizeof (tmp));
-
-      sockaddr.sin_family = PF_INET;
-      sockaddr.sin_port = htons (port);
-      sockaddr.sin_addr.s_addr = INADDR_ANY;
-
-      if (bind (listen_desc, (struct sockaddr *) &sockaddr, sizeof (sockaddr))
-	  || listen (listen_desc, 1))
-	perror_with_name ("Can't bind address");
-
-      /* If port is zero, a random port will be selected, and the
-	 fprintf below needs to know what port was selected.  */
-      if (port == 0)
-	{
-	  socklen_t len = sizeof (sockaddr);
-	  if (getsockname (listen_desc, (struct sockaddr *) &sockaddr, &len) < 0
-	      || len < sizeof (sockaddr))
-	    perror_with_name ("Can't determine port");
-	  port = ntohs (sockaddr.sin_port);
-	}
+      len = sizeof (sockaddr);
+      if (getsockname (listen_desc, (struct sockaddr *) &sockaddr, &len) < 0
+	  || len < sizeof (sockaddr))
+	perror_with_name ("Can't determine port");
+      port = ntohs (sockaddr.sin_port);
 
       fprintf (stderr, "Listening on port %d\n", port);
       fflush (stderr);
 
       /* Register the event loop handler.  */
       add_file_handler (listen_desc, handle_accept_event, NULL);
-
-      transport_is_reliable = 1;
     }
 }
 
Index: gdb-7.2/gdb/gdbserver/server.c
===================================================================
--- gdb-7.2.orig/gdb/gdbserver/server.c	2010-07-21 22:01:09.000000000 +0200
+++ gdb-7.2/gdb/gdbserver/server.c	2015-10-05 22:17:35.106061996 +0200
@@ -2565,6 +2565,8 @@ main (int argc, char *argv[])
       exit (1);
     }
 
+  remote_prepare (port);
+
   while (1)
     {
       noack_mode = 0;
Index: gdb-7.2/gdb/gdbserver/server.h
===================================================================
--- gdb-7.2.orig/gdb/gdbserver/server.h	2010-07-01 12:36:11.000000000 +0200
+++ gdb-7.2/gdb/gdbserver/server.h	2015-10-05 22:17:35.129062151 +0200
@@ -375,6 +375,7 @@ int putpkt (char *buf);
 int putpkt_binary (char *buf, int len);
 int putpkt_notif (char *buf);
 int getpkt (char *buf);
+void remote_prepare (char *name);
 void remote_open (char *name);
 void remote_close (void);
 void write_ok (char *buf);
