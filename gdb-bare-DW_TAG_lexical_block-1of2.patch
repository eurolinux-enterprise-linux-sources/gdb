From 3a2b436ae9958a1029545c03201b7223ff33c150 Mon Sep 17 00:00:00 2001
From: Jan Kratochvil <jan.kratochvil@redhat.com>
Date: Mon, 30 May 2016 14:11:43 +0200
Subject: [PATCH 1/2] Code cleanup: dwarf2_get_pc_bounds: -1/0/+1 -> enum

Make the code (maybe) more readable + primarily prepare it for [patch 2/2]
enum extension.

This change should have no code change impact.

gdb/ChangeLog
2016-05-30  Jan Kratochvil  <jan.kratochvil@redhat.com>

	Code cleanup: dwarf2_get_pc_bounds: -1/0/+1 -> enum
	* dwarf2read.c (enum pc_bounds_kind) New.
	(dwarf2_get_pc_bounds): Use it in the declaration.
	(process_psymtab_comp_unit_reader): Adjust caller.  Rename has_pc_info
	to cu_bounds_kind.
	(read_func_scope, read_lexical_block_scope, read_call_site_scope):
	Adjust callers.
	(dwarf2_get_pc_bounds): Use enum pc_bounds_kind in the definition.
	(dwarf2_get_subprogram_pc_bounds, get_scope_pc_bounds): Adjust callers.
---
 gdb/ChangeLog    | 12 ++++++++++
 gdb/dwarf2read.c | 71 ++++++++++++++++++++++++++++++++++++--------------------
 2 files changed, 58 insertions(+), 25 deletions(-)

### a/gdb/ChangeLog
### b/gdb/ChangeLog
## -1,3 +1,15 @@
+2016-05-30  Jan Kratochvil  <jan.kratochvil@redhat.com>
+
+	Code cleanup: dwarf2_get_pc_bounds: -1/0/+1 -> enum
+	* dwarf2read.c (enum pc_bounds_kind) New.
+	(dwarf2_get_pc_bounds): Use it in the declaration.
+	(process_psymtab_comp_unit_reader): Adjust caller.  Rename has_pc_info
+	to cu_bounds_kind.
+	(read_func_scope, read_lexical_block_scope, read_call_site_scope):
+	Adjust callers.
+	(dwarf2_get_pc_bounds): Use enum pc_bounds_kind in the definition.
+	(dwarf2_get_subprogram_pc_bounds, get_scope_pc_bounds): Adjust callers.
+
 2016-05-29  Jan Kratochvil  <jan.kratochvil@redhat.com>
 
 	* NEWS (QCatchSyscalls): Remove the parameter.  Include ...
Index: gdb-7.6.1/gdb/dwarf2read.c
===================================================================
--- gdb-7.6.1.orig/gdb/dwarf2read.c	2016-05-30 15:06:34.709331070 +0200
+++ gdb-7.6.1/gdb/dwarf2read.c	2016-05-30 15:06:39.950377045 +0200
@@ -1485,9 +1485,25 @@
 static int dwarf2_ranges_read (unsigned, CORE_ADDR *, CORE_ADDR *,
 			       struct dwarf2_cu *, struct partial_symtab *);
 
-static int dwarf2_get_pc_bounds (struct die_info *,
-				 CORE_ADDR *, CORE_ADDR *, struct dwarf2_cu *,
-				 struct partial_symtab *);
+/* How dwarf2_get_pc_bounds constructed its *LOWPC and *HIGHPC return
+   values.  */
+enum pc_bounds_kind
+{
+  /* No valid combination of DW_AT_low_pc, DW_AT_high_pc or DW_AT_ranges
+     was found.  */
+  PC_BOUNDS_NOT_PRESENT,
+
+  /* Discontiguous range was found - that is DW_AT_ranges was found.  */
+  PC_BOUNDS_RANGES,
+
+  /* Contiguous range was found - DW_AT_low_pc and DW_AT_high_pc were found.  */
+  PC_BOUNDS_HIGH_LOW,
+};
+
+static enum pc_bounds_kind dwarf2_get_pc_bounds (struct die_info *,
+						 CORE_ADDR *, CORE_ADDR *,
+						 struct dwarf2_cu *,
+						 struct partial_symtab *);
 
 static void get_scope_pc_bounds (struct die_info *,
 				 CORE_ADDR *, CORE_ADDR *,
@@ -4953,7 +4969,7 @@
   CORE_ADDR baseaddr;
   CORE_ADDR best_lowpc = 0, best_highpc = 0;
   struct partial_symtab *pst;
-  int has_pc_info;
+  enum pc_bounds_kind cu_bounds_kind;
   const char *filename;
   int *want_partial_unit_ptr = data;
 
@@ -4988,9 +5004,9 @@
 
   /* Possibly set the default values of LOWPC and HIGHPC from
      `DW_AT_ranges'.  */
-  has_pc_info = dwarf2_get_pc_bounds (comp_unit_die, &best_lowpc,
-				      &best_highpc, cu, pst);
-  if (has_pc_info == 1 && best_lowpc < best_highpc)
+  cu_bounds_kind = dwarf2_get_pc_bounds (comp_unit_die, &best_lowpc,
+					 &best_highpc, cu, pst);
+  if (cu_bounds_kind == PC_BOUNDS_HIGH_LOW && best_lowpc < best_highpc)
     /* Store the contiguous range if it is not empty; it can be empty for
        CUs with no code.  */
     addrmap_set_empty (objfile->psymtabs_addrmap,
@@ -5011,7 +5027,7 @@
       first_die = load_partial_dies (reader, info_ptr, 1);
 
       scan_partial_symbols (first_die, &lowpc, &highpc,
-			    ! has_pc_info, cu);
+			    cu_bounds_kind == PC_BOUNDS_NOT_PRESENT, cu);
 
       /* If we didn't find a lowpc, set it to highpc to avoid
 	 complaints from `maint check'.	 */
@@ -5020,7 +5036,7 @@
 
       /* If the compilation unit didn't have an explicit address range,
 	 then use the information extracted from its child dies.  */
-      if (! has_pc_info)
+      if (cu_bounds_kind == PC_BOUNDS_NOT_PRESENT)
 	{
 	  best_lowpc = lowpc;
 	  best_highpc = highpc;
@@ -9589,7 +9605,8 @@
     }
 
   /* Ignore functions with missing or invalid low and high pc attributes.  */
-  if (!dwarf2_get_pc_bounds (die, &lowpc, &highpc, cu, NULL))
+  if (dwarf2_get_pc_bounds (die, &lowpc, &highpc, cu, NULL)
+      == PC_BOUNDS_NOT_PRESENT)
     {
       attr = dwarf2_attr (die, DW_AT_external, cu);
       if (!attr || !DW_UNSND (attr))
@@ -9746,7 +9763,8 @@
      as multiple lexical blocks?  Handling children in a sane way would
      be nasty.  Might be easier to properly extend generic blocks to
      describe ranges.  */
-  if (!dwarf2_get_pc_bounds (die, &lowpc, &highpc, cu, NULL))
+  if (dwarf2_get_pc_bounds (die, &lowpc, &highpc, cu, NULL)
+      == PC_BOUNDS_NOT_PRESENT)
     return;
   lowpc += baseaddr;
   highpc += baseaddr;
@@ -9951,7 +9969,8 @@
 	  CORE_ADDR lowpc;
 
 	  /* DW_AT_entry_pc should be preferred.  */
-	  if (!dwarf2_get_pc_bounds (target_die, &lowpc, NULL, target_cu, NULL))
+	  if (dwarf2_get_pc_bounds (target_die, &lowpc, NULL, target_cu, NULL)
+	      == PC_BOUNDS_NOT_PRESENT)
 	    complaint (&symfile_complaints,
 		       _("DW_AT_GNU_call_site_target target DIE has invalid "
 		         "low pc, for referencing DIE 0x%x [in module %s]"),
@@ -10228,11 +10247,11 @@
   return 1;
 }
 
-/* Get low and high pc attributes from a die.  Return 1 if the attributes
-   are present and valid, otherwise, return 0.  Return -1 if the range is
-   discontinuous, i.e. derived from DW_AT_ranges information.  */
+/* Get low and high pc attributes from a die.  See enum pc_bounds_kind
+   definition for the return value.  *LOWPC and *HIGHPC are set iff
+   PC_BOUNDS_NOT_PRESENT is not returned.  */
 
-static int
+static enum pc_bounds_kind
 dwarf2_get_pc_bounds (struct die_info *die, CORE_ADDR *lowpc,
 		      CORE_ADDR *highpc, struct dwarf2_cu *cu,
 		      struct partial_symtab *pst)
@@ -10241,7 +10260,7 @@
   struct attribute *attr_high;
   CORE_ADDR low = 0;
   CORE_ADDR high = 0;
-  int ret = 0;
+  enum pc_bounds_kind ret = PC_BOUNDS_NOT_PRESENT;
 
   attr_high = dwarf2_attr (die, DW_AT_high_pc, cu);
   if (attr_high)
@@ -10258,10 +10277,10 @@
 	}
       else
 	/* Found high w/o low attribute.  */
-	return 0;
+	return PC_BOUNDS_NOT_PRESENT;
 
       /* Found consecutive range of addresses.  */
-      ret = 1;
+      ret = PC_BOUNDS_HIGH_LOW;
     }
   else
     {
@@ -10280,15 +10299,15 @@
 	  /* Value of the DW_AT_ranges attribute is the offset in the
 	     .debug_ranges section.  */
 	  if (!dwarf2_ranges_read (ranges_offset, &low, &high, cu, pst))
-	    return 0;
+	    return PC_BOUNDS_NOT_PRESENT;
 	  /* Found discontinuous range of addresses.  */
-	  ret = -1;
+	  ret = PC_BOUNDS_RANGES;
 	}
     }
 
   /* read_partial_die has also the strict LOW < HIGH requirement.  */
   if (high <= low)
-    return 0;
+    return PC_BOUNDS_NOT_PRESENT;
 
   /* When using the GNU linker, .gnu.linkonce. sections are used to
      eliminate duplicate copies of functions and vtables and such.
@@ -10299,7 +10318,7 @@
      If this is a discarded function, mark the pc bounds as invalid,
      so that GDB will ignore it.  */
   if (low == 0 && !dwarf2_per_objfile->has_section_at_zero)
-    return 0;
+    return PC_BOUNDS_NOT_PRESENT;
 
   *lowpc = low;
   if (highpc)
@@ -10320,7 +10339,8 @@
   CORE_ADDR low, high;
   struct die_info *child = die->child;
 
-  if (dwarf2_get_pc_bounds (die, &low, &high, cu, NULL))
+  if (dwarf2_get_pc_bounds (die, &low, &high, cu, NULL)
+      != PC_BOUNDS_NOT_PRESENT)
     {
       *lowpc = min (*lowpc, low);
       *highpc = max (*highpc, high);
@@ -10357,7 +10377,8 @@
   CORE_ADDR best_high = (CORE_ADDR) 0;
   CORE_ADDR current_low, current_high;
 
-  if (dwarf2_get_pc_bounds (die, &current_low, &current_high, cu, NULL))
+  if (dwarf2_get_pc_bounds (die, &current_low, &current_high, cu, NULL)
+      != PC_BOUNDS_NOT_PRESENT)
     {
       best_low = current_low;
       best_high = current_high;
