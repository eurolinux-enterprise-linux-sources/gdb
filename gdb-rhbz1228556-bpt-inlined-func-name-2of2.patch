commit 4a27f119f59a44395e0a34b1526cee709e1d3fce
Author: Keith Seitz <keiths@redhat.com>
Date:   Fri Oct 27 10:57:23 2017 -0700

    Use SaL symbol name when reporting breakpoint locations
    
    Currently, "info break" can show some (perhaps) unexpected results when
    setting a breakpoint on an inlined function:
    
    (gdb) list
    1       #include <stdio.h>
    2
    3       static inline void foo()
    4       {
    5               printf("Hello world\n");
    6       }
    7
    8       int main()
    9       {
    10              foo();
    11              return 0;
    12      }
    13
    (gdb) b foo
    Breakpoint 1 at 0x400434: file foo.c, line 5.
    (gdb) i b
    Num     Type           Disp Enb Address            What
    1       breakpoint     keep y   0x0000000000400434 in main at foo.c:5
    
    GDB reported that we understood what "foo" was, but we then report that the
    breakpoint is actually set in main. While that is literally true, we can
    do a little better.
    
    This is accomplished by copying the symbol for which the breakpoint was set
    into the bp_location.  From there, print_breakpoint_location can use this
    information to print out symbol information (if available) instead of calling
    find_pc_sect_function.
    
    With the patch installed,
    
    (gdb) i b
    Num     Type           Disp Enb Address            What
    1       breakpoint     keep y   0x0000000000400434 in foo at foo.c:5
    
    gdb/ChangeLog:
    
            * breakpoint.c (print_breakpoint_location): Use the symbol saved
            in the bp_location, falling back to find_pc_sect_function when
            needed.
            (add_location_to_breakpoint): Save sal->symbol.
            * breakpoint.h (struct bp_location) <symbol>: New field.
            * symtab.c (find_function_start_sal): Save the symbol into the SaL.
            * symtab.h (struct symtab_and_line) <symbol>: New field.
    
    gdb/testsuite/ChangeLog:
    
            * gdb.opt/inline-break.exp (break_info_1): New procedure.
            Test "info break" for every inlined function breakpoint.

### a/gdb/ChangeLog
### b/gdb/ChangeLog
## -1,3 +1,13 @@
+2017-10-27  Keith Seitz  <keiths@redhat.com>
+
+	* breakpoint.c (print_breakpoint_location): Use the symbol saved
+	in the bp_location, falling back to find_pc_sect_function when
+	needed.
+	(add_location_to_breakpoint): Save sal->symbol.
+	* breakpoint.h (struct bp_location) <symbol>: New field.
+	* symtab.c (find_function_start_sal): Save the symbol into the SaL.
+	* symtab.h (struct symtab_and_line) <symbol>: New field.
+
 2017-10-26  Patrick Frants  <osscontribute@gmail.com>
 
 	PR gdb/13669
Index: gdb-7.6.1/gdb/breakpoint.c
===================================================================
--- gdb-7.6.1.orig/gdb/breakpoint.c	2017-10-27 21:38:34.569392186 +0200
+++ gdb-7.6.1/gdb/breakpoint.c	2017-10-27 21:38:37.699416969 +0200
@@ -5703,8 +5703,11 @@
     ui_out_field_string (uiout, "what", b->addr_string);
   else if (loc && loc->symtab)
     {
-      struct symbol *sym 
-	= find_pc_sect_function (loc->address, loc->section);
+      const struct symbol *sym = loc->symbol;
+
+      if (sym == NULL)
+	sym = find_pc_sect_function (loc->address, loc->section);
+
       if (sym)
 	{
 	  ui_out_text (uiout, "in ");
@@ -8851,6 +8854,7 @@
   loc->gdbarch = loc_gdbarch;
   loc->line_number = sal->line;
   loc->symtab = sal->symtab;
+  loc->symbol = sal->symbol;
 
   set_breakpoint_location_function (loc,
 				    sal->explicit_pc || sal->explicit_line);
Index: gdb-7.6.1/gdb/breakpoint.h
===================================================================
--- gdb-7.6.1.orig/gdb/breakpoint.h	2017-10-27 21:38:33.271381909 +0200
+++ gdb-7.6.1/gdb/breakpoint.h	2017-10-27 21:38:37.700416977 +0200
@@ -476,6 +476,11 @@
      to find the corresponding source file name.  */
 
   struct symtab *symtab;
+
+  /* The symbol found by the location parser, if any.  This may be used to
+     ascertain when an event location was set at a different location than
+     the one originally selected by parsing, e.g., inlined symbols.  */
+  const struct symbol *symbol;
 };
 
 /* Return values for bpstat_explains_signal.  Note that the order of
Index: gdb-7.6.1/gdb/testsuite/gdb.opt/inline-break.exp
===================================================================
--- gdb-7.6.1.orig/gdb/testsuite/gdb.opt/inline-break.exp	2013-01-01 07:41:25.000000000 +0100
+++ gdb-7.6.1/gdb/testsuite/gdb.opt/inline-break.exp	2017-10-27 21:41:42.869884103 +0200
@@ -24,6 +24,100 @@
     return -1
 }
 
+# RHEL-7:
+proc parse_args { argset } {
+    upvar args args
+
+    foreach argument $argset {
+        if {[llength $argument] == 1} {
+            # No default specified, so we assume that we should set
+            # the value to 1 if the arg is present and 0 if it's not.
+            # It is assumed that no value is given with the argument.
+            set result [lsearch -exact $args "-$argument"]
+            if {$result != -1} then {
+                uplevel 1 [list set $argument 1]
+                set args [lreplace $args $result $result]
+            } else {
+                uplevel 1 [list set $argument 0]
+            }
+        } elseif {[llength $argument] == 2} {
+            # There are two items in the argument.  The second is a
+            # default value to use if the item is not present.
+            # Otherwise, the variable is set to whatever is provided
+            # after the item in the args.
+            set arg [lindex $argument 0]
+            set result [lsearch -exact $args "-[lindex $arg 0]"]
+            if {$result != -1} then {
+                uplevel 1 [list set $arg [lindex $args [expr $result+1]]]
+                set args [lreplace $args $result [expr $result+1]]
+            } else {
+                uplevel 1 [list set $arg [lindex $argument 1]]
+            }
+        } else {
+            error "Badly formatted argument \"$argument\" in argument set"
+        }
+    }
+
+    # The remaining args should be checked to see that they match the
+    # number of items expected to be passed into the procedure...
+}
+
+# Return a string that may be used to match the output of "info break NUM".
+#
+# Optional arguments:
+#
+# source    - the name of the source file
+# func      - the name of the function
+# disp      - the event disposition
+# enabled   - enable state
+# locs      - number of locations
+# line      - source line number (ignored without -source)
+
+proc break_info_1 {num args} {
+    global decimal
+
+    # Column delimiter
+    set c {[\t ]+}
+
+    # Row delimiter
+    set end {[\r\n \t]+}
+
+    # Table header
+    set header "[join [list Num Type Disp Enb Address What] ${c}]"
+
+    # Get/configure any optional parameters.
+    parse_args [list {source ""} {func ".*"} {disp "keep"} \
+		    {enabled "y"} {locs 1} [list line $decimal] \
+		    {type "breakpoint"}]
+
+    if {$source != ""} {
+	set source "$source:$line"
+    }
+
+    # Result starts with the standard header.
+    set result "$header${end}"
+
+    # Set up for multi-location breakpoint marker.
+    if {$locs == 1} {
+	set multi ".*"
+    } else {
+	set multi "<MULTIPLE>${end}"
+    }
+    append result "[join [list $num $type $disp $enabled $multi] $c]"
+
+    # Add location info.
+    for {set i 1} {$i <= $locs} {incr i} {
+	if {$locs > 1} {
+	    append result "[join [list $num.$i $enabled] $c].*"
+	}
+
+	#  Add function/source file info.
+	append result "in $func at .*$source${end}"
+    }
+
+    return $result
+}
+
 #
 # func1 is a static inlined function that is called once.
 # The result should be a single-location breakpoint.
@@ -111,3 +205,22 @@
 #
 gdb_test "print func2" \
     "\\\$.* = {int \\(int\\)} .* <func2>"
+
+# Test that "info break" reports the location of the breakpoints "inside"
+# the inlined functions
+
+set results(1) [break_info_1 1 -source $srcfile -func "func1"]
+set results(2) [break_info_1 2 -locs 2 -source $srcfile -func "func2"]
+set results(3) [break_info_1 3 -source $srcfile -func "func3b"]
+set results(4) [break_info_1 4 -locs 2 -source $srcfile -func "func4b"]
+set results(5) [break_info_1 5 -locs 2 -source $srcfile -func "func5b"]
+set results(6) [break_info_1 6 -locs 3 -source $srcfile -func "func6b"]
+set results(7) [break_info_1 7 -locs 2 -source $srcfile -func "func7b"]
+set results(8) [break_info_1 8 -locs 3 -source $srcfile -func "func8b"]
+
+for {set i 1} {$i <= [array size results]} {incr i} {
+    send_log "Expecting: $results($i)\n"
+    gdb_test "info break $i" $results($i)
+}
+
+unset -nocomplain results
