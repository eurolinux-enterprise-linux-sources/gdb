From 433a06cdf9c6a386b86560ec776ce1439a8f93e9 Mon Sep 17 00:00:00 2001
From: siddhesh <siddhesh>
Date: Wed, 26 Sep 2012 07:52:44 +0000
Subject: [PATCH]         * amd64-tdep.c (amd64_return_value): Use TYPE_LENGTH directly.
         * bfin-tdep.c (bfin_extract_return_value): Likewise.
         (bfin_store_return_value): Likewise.
         * cris-tdep.c (cris_store_return_value): Likewise.
         (cris_extract_return_value): Likewise.
         * h8300-tdep.c (h8300_extract_return_value): Likewise.
         * hppa-tdep.c (hppa64_return_value): Likewise.
         * lm32-tdep.c (lm32_store_return_value): Likewise.
         * microblaze-tdep.c (microblaze_store_return_value): Likewise.
         * spu-tdep.c (spu_value_from_register): Likewise.
         * vax-tdep.c (vax_return_value): Likewise.

---
 gdb/ChangeLog         |   14 ++++++++++++++
 gdb/amd64-tdep.c      |    2 +-
 gdb/bfin-tdep.c       |    4 ++--
 gdb/cris-tdep.c       |   20 ++++++++++----------
 gdb/h8300-tdep.c      |    9 +++++----
 gdb/hppa-tdep.c       |    2 +-
 gdb/lm32-tdep.c       |   10 +++++-----
 gdb/microblaze-tdep.c |    7 +++----
 gdb/spu-tdep.c        |    5 ++---
 gdb/vax-tdep.c        |   11 +++++------
 10 files changed, 48 insertions(+), 36 deletions(-)

Index: gdb-7.2/gdb/amd64-tdep.c
===================================================================
--- gdb-7.2.orig/gdb/amd64-tdep.c
+++ gdb-7.2/gdb/amd64-tdep.c
@@ -621,7 +621,7 @@ amd64_return_value (struct gdbarch *gdba
     }
 
   gdb_assert (class[1] != AMD64_MEMORY);
-  gdb_assert (len <= 16);
+  gdb_assert (TYPE_LENGTH (type) <= 16);
 
   for (i = 0; len > 0; i++, len -= 8)
     {
Index: gdb-7.2/gdb/cris-tdep.c
===================================================================
--- gdb-7.2.orig/gdb/cris-tdep.c
+++ gdb-7.2/gdb/cris-tdep.c
@@ -1711,20 +1711,20 @@ cris_store_return_value (struct type *ty
   struct gdbarch *gdbarch = get_regcache_arch (regcache);
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
   ULONGEST val;
-  int len = TYPE_LENGTH (type);
   
-  if (len <= 4)
+  if (TYPE_LENGTH (type) <= 4)
     {
       /* Put the return value in R10.  */
-      val = extract_unsigned_integer (valbuf, len, byte_order);
+      val = extract_unsigned_integer (valbuf, TYPE_LENGTH (type), byte_order);
       regcache_cooked_write_unsigned (regcache, ARG1_REGNUM, val);
     }
-  else if (len <= 8)
+  else if (TYPE_LENGTH (type) <= 8)
     {
       /* Put the return value in R10 and R11.  */
       val = extract_unsigned_integer (valbuf, 4, byte_order);
       regcache_cooked_write_unsigned (regcache, ARG1_REGNUM, val);
-      val = extract_unsigned_integer ((char *)valbuf + 4, len - 4, byte_order);
+      val = extract_unsigned_integer ((char *)valbuf + 4,
+				      TYPE_LENGTH (type) - 4, byte_order);
       regcache_cooked_write_unsigned (regcache, ARG2_REGNUM, val);
     }
   else
@@ -1882,21 +1882,21 @@ cris_extract_return_value (struct type *
   struct gdbarch *gdbarch = get_regcache_arch (regcache);
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
   ULONGEST val;
-  int len = TYPE_LENGTH (type);
   
-  if (len <= 4)
+  if (TYPE_LENGTH (type) <= 4)
     {
       /* Get the return value from R10.  */
       regcache_cooked_read_unsigned (regcache, ARG1_REGNUM, &val);
-      store_unsigned_integer (valbuf, len, byte_order, val);
+      store_unsigned_integer (valbuf, TYPE_LENGTH (type), byte_order, val);
     }
-  else if (len <= 8)
+  else if (TYPE_LENGTH (type) <= 8)
     {
       /* Get the return value from R10 and R11.  */
       regcache_cooked_read_unsigned (regcache, ARG1_REGNUM, &val);
       store_unsigned_integer (valbuf, 4, byte_order, val);
       regcache_cooked_read_unsigned (regcache, ARG2_REGNUM, &val);
-      store_unsigned_integer ((char *)valbuf + 4, len - 4, byte_order, val);
+      store_unsigned_integer ((char *)valbuf + 4, TYPE_LENGTH (type) - 4,
+			      byte_order, val);
     }
   else
     error (_("cris_extract_return_value: type length too large"));
Index: gdb-7.2/gdb/h8300-tdep.c
===================================================================
--- gdb-7.2.orig/gdb/h8300-tdep.c
+++ gdb-7.2/gdb/h8300-tdep.c
@@ -753,12 +753,12 @@ h8300_extract_return_value (struct type 
   int len = TYPE_LENGTH (type);
   ULONGEST c, addr;
 
-  switch (len)
+  switch (TYPE_LENGTH (type))
     {
     case 1:
     case 2:
       regcache_cooked_read_unsigned (regcache, E_RET0_REGNUM, &c);
-      store_unsigned_integer (valbuf, len, byte_order, c);
+      store_unsigned_integer (valbuf, TYPE_LENGTH (type), byte_order, c);
       break;
     case 4:			/* Needs two registers on plain H8/300 */
       regcache_cooked_read_unsigned (regcache, E_RET0_REGNUM, &c);
@@ -770,8 +770,9 @@ h8300_extract_return_value (struct type 
       if (TYPE_CODE (type) == TYPE_CODE_INT)
 	{
 	  regcache_cooked_read_unsigned (regcache, E_RET0_REGNUM, &addr);
-	  c = read_memory_unsigned_integer ((CORE_ADDR) addr, len, byte_order);
-	  store_unsigned_integer (valbuf, len, byte_order, c);
+	  c = read_memory_unsigned_integer ((CORE_ADDR) addr,
+					    TYPE_LENGTH (type), byte_order);
+	  store_unsigned_integer (valbuf, TYPE_LENGTH (type), byte_order, c);
 	}
       else
 	{
Index: gdb-7.2/gdb/hppa-tdep.c
===================================================================
--- gdb-7.2.orig/gdb/hppa-tdep.c
+++ gdb-7.2/gdb/hppa-tdep.c
@@ -1162,7 +1162,7 @@ hppa64_return_value (struct gdbarch *gdb
   int len = TYPE_LENGTH (type);
   int regnum, offset;
 
-  if (len > 16)
+  if (TYPE_LENGTH (type) > 16)
     {
       /* All return values larget than 128 bits must be aggregate
          return values.  */
Index: gdb-7.2/gdb/lm32-tdep.c
===================================================================
--- gdb-7.2.orig/gdb/lm32-tdep.c
+++ gdb-7.2/gdb/lm32-tdep.c
@@ -352,18 +352,18 @@ lm32_store_return_value (struct type *ty
   struct gdbarch *gdbarch = get_regcache_arch (regcache);
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
   ULONGEST val;
-  int len = TYPE_LENGTH (type);
 
-  if (len <= 4)
+  if (TYPE_LENGTH (type) <= 4)
     {
-      val = extract_unsigned_integer (valbuf, len, byte_order);
+      val = extract_unsigned_integer (valbuf, TYPE_LENGTH (type), byte_order);
       regcache_cooked_write_unsigned (regcache, SIM_LM32_R1_REGNUM, val);
     }
-  else if (len <= 8)
+  else if (TYPE_LENGTH (type) <= 8)
     {
       val = extract_unsigned_integer (valbuf, 4, byte_order);
       regcache_cooked_write_unsigned (regcache, SIM_LM32_R1_REGNUM, val);
-      val = extract_unsigned_integer (valbuf + 4, len - 4, byte_order);
+      val = extract_unsigned_integer (valbuf + 4, TYPE_LENGTH (type) - 4,
+				      byte_order);
       regcache_cooked_write_unsigned (regcache, SIM_LM32_R2_REGNUM, val);
     }
   else
Index: gdb-7.2/gdb/microblaze-tdep.c
===================================================================
--- gdb-7.2.orig/gdb/microblaze-tdep.c
+++ gdb-7.2/gdb/microblaze-tdep.c
@@ -588,22 +588,21 @@ static void
 microblaze_store_return_value (struct type *type, struct regcache *regcache,
 			       const gdb_byte *valbuf)
 {
-  int len = TYPE_LENGTH (type);
   gdb_byte buf[8];
 
   memset (buf, 0, sizeof(buf));
 
   /* Integral and pointer return values.  */
 
-  if (len > 4)
+  if (TYPE_LENGTH (type) > 4)
     {
-       gdb_assert (len == 8);
+       gdb_assert (TYPE_LENGTH (type) == 8);
        memcpy (buf, valbuf, 8);
        regcache_cooked_write (regcache, MICROBLAZE_RETVAL_REGNUM+1, buf + 4);
     }
   else
     /* ??? Do we need to do any sign-extension here?  */
-    memcpy (buf + 4 - len, valbuf, len);
+    memcpy (buf + 4 - TYPE_LENGTH (type), valbuf, TYPE_LENGTH (type));
 
   regcache_cooked_write (regcache, MICROBLAZE_RETVAL_REGNUM, buf);
 }
Index: gdb-7.2/gdb/spu-tdep.c
===================================================================
--- gdb-7.2.orig/gdb/spu-tdep.c
+++ gdb-7.2/gdb/spu-tdep.c
@@ -310,11 +310,10 @@ spu_value_from_register (struct type *ty
 			 struct frame_info *frame)
 {
   struct value *value = default_value_from_register (type, regnum, frame);
-  int len = TYPE_LENGTH (type);
 
-  if (regnum < SPU_NUM_GPRS && len < 16)
+  if (regnum < SPU_NUM_GPRS && TYPE_LENGTH (type) < 16)
     {
-      int preferred_slot = len < 4 ? 4 - len : 0;
+      int preferred_slot = TYPE_LENGTH (type) < 4 ? 4 - TYPE_LENGTH (type) : 0;
       set_value_offset (value, preferred_slot);
     }
 
Index: gdb-7.2/gdb/vax-tdep.c
===================================================================
--- gdb-7.2.orig/gdb/vax-tdep.c
+++ gdb-7.2/gdb/vax-tdep.c
@@ -208,7 +208,6 @@ vax_return_value (struct gdbarch *gdbarc
 		  struct type *type, struct regcache *regcache,
 		  gdb_byte *readbuf, const gdb_byte *writebuf)
 {
-  int len = TYPE_LENGTH (type);
   gdb_byte buf[8];
 
   if (TYPE_CODE (type) == TYPE_CODE_STRUCT
@@ -224,7 +223,7 @@ vax_return_value (struct gdbarch *gdbarc
 	  ULONGEST addr;
 
 	  regcache_raw_read_unsigned (regcache, VAX_R0_REGNUM, &addr);
-	  read_memory (addr, readbuf, len);
+	  read_memory (addr, readbuf, TYPE_LENGTH (type));
 	}
 
       return RETURN_VALUE_ABI_RETURNS_ADDRESS;
@@ -234,16 +233,16 @@ vax_return_value (struct gdbarch *gdbarc
     {
       /* Read the contents of R0 and (if necessary) R1.  */
       regcache_cooked_read (regcache, VAX_R0_REGNUM, buf);
-      if (len > 4)
+      if (TYPE_LENGTH (type) > 4)
 	regcache_cooked_read (regcache, VAX_R1_REGNUM, buf + 4);
-      memcpy (readbuf, buf, len);
+      memcpy (readbuf, buf, TYPE_LENGTH (type));
     }
   if (writebuf)
     {
       /* Read the contents to R0 and (if necessary) R1.  */
-      memcpy (buf, writebuf, len);
+      memcpy (buf, writebuf, TYPE_LENGTH (type));
       regcache_cooked_write (regcache, VAX_R0_REGNUM, buf);
-      if (len > 4)
+      if (TYPE_LENGTH (type) > 4)
 	regcache_cooked_write (regcache, VAX_R1_REGNUM, buf + 4);
     }
 
