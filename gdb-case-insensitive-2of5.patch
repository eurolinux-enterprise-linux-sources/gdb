[patch 1/3] case insensitive: Reformat code
http://sourceware.org/ml/gdb-patches/2011-04/msg00124.html
http://sourceware.org/ml/gdb-cvs/2011-04/msg00177.html

### src/gdb/ChangeLog	2011/04/27 17:08:37	1.12959
### src/gdb/ChangeLog	2011/04/27 19:52:19	1.12960
## -1,3 +1,10 @@
+2011-04-27  Jan Kratochvil  <jan.kratochvil@redhat.com>
+
+	Format the code for the next patch.
+	* dwarf2read.c (struct mapped_index): Include delimiting newlines.
+	* utils.c (strcmp_iw_ordered): Reformat the code for the next patch.
+	New variables c1 and c2.
+
 2011-04-27  Ulrich Weigand  <ulrich.weigand@linaro.org>
 
 	* infrun.c (proceed): Do not single-step into signal delivery
Index: gdb-7.2/gdb/dwarf2read.c
===================================================================
--- gdb-7.2.orig/gdb/dwarf2read.c	2011-07-28 00:14:44.000000000 +0200
+++ gdb-7.2/gdb/dwarf2read.c	2011-07-28 00:20:50.000000000 +0200
@@ -152,14 +152,19 @@ struct mapped_index
 {
   /* The total length of the buffer.  */
   off_t total_size;
+
   /* A pointer to the address table data.  */
   const gdb_byte *address_table;
+
   /* Size of the address table data in bytes.  */
   offset_type address_table_size;
+
   /* The hash table.  */
   const offset_type *index_table;
+
   /* Size in slots, each slot is 2 offset_types.  */
   offset_type index_table_slots;
+
   /* A pointer to the constant pool.  */
   const char *constant_pool;
 };
Index: gdb-7.2/gdb/utils.c
===================================================================
--- gdb-7.2.orig/gdb/utils.c	2011-07-28 00:14:44.000000000 +0200
+++ gdb-7.2/gdb/utils.c	2011-07-28 00:20:22.000000000 +0200
@@ -2987,48 +2987,55 @@ strcmp_iw (const char *string1, const ch
 int
 strcmp_iw_ordered (const char *string1, const char *string2)
 {
-  while ((*string1 != '\0') && (*string2 != '\0'))
+  /* Formatting stub.  */
+  if (1)
     {
-      while (isspace (*string1))
-	{
-	  string1++;
-	}
-      while (isspace (*string2))
+      /* C1 and C2 are valid only if *string1 != '\0' && *string2 != '\0'.
+	 Provide stub characters if we are already at the end of one of the
+	 strings.  */
+      char c1 = 'X', c2 = 'X';
+
+      while (*string1 != '\0' && *string2 != '\0')
 	{
-	  string2++;
+	  while (isspace (*string1))
+	    string1++;
+	  while (isspace (*string2))
+	    string2++;
+
+	      c1 = *string1;
+	      c2 = *string2;
+	  if (c1 != c2)
+	    break;
+
+	  if (*string1 != '\0')
+	    {
+	      string1++;
+	      string2++;
+	    }
 	}
-      if (*string1 != *string2)
-	{
-	  break;
-	}
-      if (*string1 != '\0')
+
+      switch (*string1)
 	{
-	  string1++;
-	  string2++;
+	  /* Characters are non-equal unless they're both '\0'; we want to
+	     make sure we get the comparison right according to our
+	     comparison in the cases where one of them is '\0' or '('.  */
+	case '\0':
+	  if (*string2 == '\0')
+	    return 0;
+	  else
+	    return -1;
+	case '(':
+	  if (*string2 == '\0')
+	    return 1;
+	  else
+	    return -1;
+	default:
+	  if (*string2 == '\0' || *string2 == '(')
+	    return 1;
+	  else
+	    return c1 - c2;
 	}
     }
-
-  switch (*string1)
-    {
-      /* Characters are non-equal unless they're both '\0'; we want to
-	 make sure we get the comparison right according to our
-	 comparison in the cases where one of them is '\0' or '('.  */
-    case '\0':
-      if (*string2 == '\0')
-	return 0;
-      else
-	return -1;
-    case '(':
-      if (*string2 == '\0')
-	return 1;
-      else
-	return -1;
-    default:
-      if (*string2 == '(')
-	return 1;
-      else
-	return *string1 - *string2;
-    }
 }
 
 /* A simple comparison function with opposite semantics to strcmp.  */
