commit 416f679e68468ea6dd7384213994ce74201f82e7
Author: Sergio Durigan Junior <sergiodj@redhat.com>
Date:   Tue Mar 31 19:17:23 2015 -0400

    Catch exception on solib_svr4_r_ldsomap
    
    When loading a corefile that has some inaccessible memory region(s),
    GDB complains about it:
    
       (gdb) core /my/corefile
       [New LWP 28468]
       Cannot access memory at address 0x355fc21148
       Cannot access memory at address 0x355fc21140
       (gdb)
    
    However, despite not seeing the message "Core was generated by...", it
    is still possible to inspect the corefile using regular GDB commands.
    The reason for that is because read_memory_unsigned_integer throws an
    exception when it cannot read the memory region, but
    solib_svr4_r_ldsomap was not catching it.  The fix is to catch the
    exception and act accordingly.
    
    Tested on Fedora 20 x86_64, no regressions found.
    
    gdb/ChangeLog:
    2015-03-31  Sergio Durigan Junior  <sergiodj@redhat.com>
    
    	* solib-svr4.c (solib_svr4_r_ldsomap): Catch possible exception by
    	read_memory_unsigned_integer.

### a/gdb/ChangeLog
### b/gdb/ChangeLog
## -1,3 +1,8 @@
+2015-03-31  Sergio Durigan Junior  <sergiodj@redhat.com>
+
+	* solib-svr4.c (solib_svr4_r_ldsomap): Catch possible exception by
+	read_memory_unsigned_integer.
+
 2015-03-31  H.J. Lu  <hongjiu.lu@intel.com>
 
 	* Makefile.in (ZLIB): New.
Index: gdb-7.6.1/gdb/solib-svr4.c
===================================================================
--- gdb-7.6.1.orig/gdb/solib-svr4.c	2015-11-27 22:31:12.059831214 +0100
+++ gdb-7.6.1/gdb/solib-svr4.c	2015-11-27 22:35:17.641182004 +0100
@@ -912,13 +912,22 @@
   struct link_map_offsets *lmo = svr4_fetch_link_map_offsets ();
   struct type *ptr_type = builtin_type (target_gdbarch ())->builtin_data_ptr;
   enum bfd_endian byte_order = gdbarch_byte_order (target_gdbarch ());
-  ULONGEST version;
+  ULONGEST version = 0;
+  volatile struct gdb_exception ex;
+
+  TRY_CATCH (ex, RETURN_MASK_ERROR)
+    {
+      /* Check version, and return zero if `struct r_debug' doesn't have
+	 the r_ldsomap member.  */
+      version
+	= read_memory_unsigned_integer (info->debug_base + lmo->r_version_offset,
+					lmo->r_version_size, byte_order);
+    }
+  if (ex.reason < 0)
+    {
+      exception_print (gdb_stderr, ex);
+    }
 
-  /* Check version, and return zero if `struct r_debug' doesn't have
-     the r_ldsomap member.  */
-  version
-    = read_memory_unsigned_integer (info->debug_base + lmo->r_version_offset,
-				    lmo->r_version_size, byte_order);
   if (version < 2 || lmo->r_ldsomap_offset == -1)
     return 0;
 
