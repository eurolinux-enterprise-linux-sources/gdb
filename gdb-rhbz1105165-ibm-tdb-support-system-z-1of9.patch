From 2ccd146855365598ad2644ef8139f2f2a6747b90 Mon Sep 17 00:00:00 2001
From: Ulrich Weigand <uweigand@de.ibm.com>
Date: Fri, 13 Sep 2013 14:11:15 +0000
Subject: [PATCH 2/3] 2013-09-13  Andreas Arnez  <arnez@linux.vnet.ibm.com>

	* s390-tdep.h (S390_IS_GREGSET_REGNUM): New macro.
	(S390_IS_FPREGSET_REGNUM): New macro.
	* s390-tdep.c (s390_dwarf_regmap): Make const.
	(regnum_is_gpr_full): New function for replacing repeated code.
	(s390_pseudo_register_name): Use it.
	(s390_pseudo_register_type): Likewise.
	(s390_pseudo_register_read): Likewise.
	(s390_pseudo_register_write): Likewise.
	(s390_unwind_pseudo_register): Likewise.
	(s390_regmap_gregset): New format for regmap.
	(s390x_regmap_gregset): Likewise.
	(s390_regmap_fpregset): Likewise.
	(s390_regmap_upper): Likewise.
	(s390_regmap_last_break): Likewise.
	(s390_regmap_system_call): Likewise.
	(s390_supply_regset): Adjust to new regmap format.
	(s390_collect_regset): Likewise.
	* s390-nat.c (s390_native_supply): Adjust to new regmap format.
	(s390_native_collect): Likewise.
	(supply_gregset): Likewise.
	(fill_gregset): Likewise.
	(supply_fpregset): Likewise.
	(fill_fpregset): Likewise.
	(fetch_regset): Likewise.
	(store_regset): Likewise.
	(s390_linux_fetch_inferior_registers): Likewise.
	(s390_linux_fetch_inferior_registers): Likewise.
---
 gdb/ChangeLog   |  30 +++++
 gdb/s390-nat.c  | 233 +++++++++++++++++------------------
 gdb/s390-tdep.c | 369 +++++++++++++++++++++++++++-----------------------------
 gdb/s390-tdep.h |  20 ++-
 4 files changed, 328 insertions(+), 324 deletions(-)

Index: gdb-7.6.1/gdb/s390-nat.c
===================================================================
--- gdb-7.6.1.orig/gdb/s390-nat.c
+++ gdb-7.6.1/gdb/s390-nat.c
@@ -63,139 +63,139 @@ static int have_regset_system_call = 0;
 
 #define regmap_fpregset s390_regmap_fpregset
 
-/* When debugging a 32-bit executable running under a 64-bit kernel,
-   we have to fix up the 64-bit registers we get from the kernel
-   to make them look like 32-bit registers.  */
+/* Fill the regset described by MAP into REGCACHE, using the values
+   from REGP.  The MAP array represents each register as a pair
+   (offset, regno) of short integers and is terminated with -1. */
 
 static void
-s390_native_supply (struct regcache *regcache, int regno,
-		    const gdb_byte *regp, int *regmap)
+s390_native_supply (struct regcache *regcache, const short *map,
+		    const gdb_byte *regp)
 {
-  int offset = regmap[regno];
+  for (; map[0] >= 0; map += 2)
+    regcache_raw_supply (regcache, map[1], regp + map[0]);
+}
+
+/* Collect the register REGNO out of the regset described by MAP from
+   REGCACHE into REGP.  If REGNO == -1, do this for all registers in
+   this regset. */
 
+static void
+s390_native_collect (const struct regcache *regcache, const short *map,
+		     int regno, gdb_byte *regp)
+{
+  for (; map[0] >= 0; map += 2)
+    if (regno == -1 || regno == map[1])
+      regcache_raw_collect (regcache, map[1], regp + map[0]);
+}
+
+/* Fill GDB's register array with the general-purpose register values
+   in *REGP.
+
+   When debugging a 32-bit executable running under a 64-bit kernel,
+   we have to fix up the 64-bit registers we get from the kernel to
+   make them look like 32-bit registers.  */
+
+void
+supply_gregset (struct regcache *regcache, const gregset_t *regp)
+{
 #ifdef __s390x__
   struct gdbarch *gdbarch = get_regcache_arch (regcache);
-  if (offset != -1 && gdbarch_ptr_bit (gdbarch) == 32)
+  if (gdbarch_ptr_bit (gdbarch) == 32)
     {
       enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
+      ULONGEST pswm = 0, pswa = 0;
+      gdb_byte buf[4];
+      const short *map;
 
-      if (regno == S390_PSWM_REGNUM)
-	{
-	  ULONGEST pswm;
-	  gdb_byte buf[4];
-
-	  pswm = extract_unsigned_integer (regp + regmap[S390_PSWM_REGNUM],
-					   8, byte_order);
-
-	  store_unsigned_integer (buf, 4, byte_order, (pswm >> 32) | 0x80000);
-	  regcache_raw_supply (regcache, regno, buf);
-	  return;
-	}
-
-      if (regno == S390_PSWA_REGNUM)
+      for (map = regmap_gregset; map[0] >= 0; map += 2)
 	{
-	  ULONGEST pswm, pswa;
-	  gdb_byte buf[4];
+	  const gdb_byte *p = (const gdb_byte *) regp + map[0];
+	  int regno = map[1];
 
-	  pswa = extract_unsigned_integer (regp + regmap[S390_PSWA_REGNUM],
-					   8, byte_order);
-	  pswm = extract_unsigned_integer (regp + regmap[S390_PSWM_REGNUM],
-					   8, byte_order);
-
-	  store_unsigned_integer (buf, 4, byte_order,
-				  (pswa & 0x7fffffff) | (pswm & 0x80000000));
-	  regcache_raw_supply (regcache, regno, buf);
-	  return;
+	  if (regno == S390_PSWM_REGNUM)
+	    pswm = extract_unsigned_integer (p, 8, byte_order);
+	  else if (regno == S390_PSWA_REGNUM)
+	    pswa = extract_unsigned_integer (p, 8, byte_order);
+	  else
+	    {
+	      if ((regno >= S390_R0_REGNUM && regno <= S390_R15_REGNUM)
+		  || regno == S390_ORIG_R2_REGNUM)
+		p += 4;
+	      regcache_raw_supply (regcache, regno, p);
+	    }
 	}
 
-      if ((regno >= S390_R0_REGNUM && regno <= S390_R15_REGNUM)
-	  || regno == S390_ORIG_R2_REGNUM)
-	offset += 4;
+      store_unsigned_integer (buf, 4, byte_order, (pswm >> 32) | 0x80000);
+      regcache_raw_supply (regcache, S390_PSWM_REGNUM, buf);
+      store_unsigned_integer (buf, 4, byte_order,
+			      (pswa & 0x7fffffff) | (pswm & 0x80000000));
+      regcache_raw_supply (regcache, S390_PSWA_REGNUM, buf);
+      return;
     }
 #endif
 
-  if (offset != -1)
-    regcache_raw_supply (regcache, regno, regp + offset);
+  s390_native_supply (regcache, regmap_gregset, (const gdb_byte *) regp);
 }
 
-static void
-s390_native_collect (const struct regcache *regcache, int regno,
-		     gdb_byte *regp, int *regmap)
-{
-  int offset = regmap[regno];
+/* Fill register REGNO (if it is a general-purpose register) in
+   *REGP with the value in GDB's register array.  If REGNO is -1,
+   do this for all registers.  */
 
+void
+fill_gregset (const struct regcache *regcache, gregset_t *regp, int regno)
+{
 #ifdef __s390x__
   struct gdbarch *gdbarch = get_regcache_arch (regcache);
-  if (offset != -1 && gdbarch_ptr_bit (gdbarch) == 32)
+  if (gdbarch_ptr_bit (gdbarch) == 32)
     {
-      enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
+      gdb_byte *psw_p[2];
+      const short *map;
 
-      if (regno == S390_PSWM_REGNUM)
+      for (map = regmap_gregset; map[0] >= 0; map += 2)
 	{
-	  ULONGEST pswm;
-	  gdb_byte buf[4];
+	  gdb_byte *p = (gdb_byte *) regp + map[0];
+	  int reg = map[1];
 
-	  regcache_raw_collect (regcache, regno, buf);
-	  pswm = extract_unsigned_integer (buf, 4, byte_order);
+	  if (reg >= S390_PSWM_REGNUM && reg <= S390_PSWA_REGNUM)
+	    psw_p[reg - S390_PSWM_REGNUM] = p;
 
-	  /* We don't know the final addressing mode until the PSW address
-	     is known, so leave it as-is.  When the PSW address is collected
-	     (below), the addressing mode will be updated.  */
-	  store_unsigned_integer (regp + regmap[S390_PSWM_REGNUM],
-				  4, byte_order, pswm & 0xfff7ffff);
-	  return;
+	  else if (regno == -1 || regno == reg)
+	    {
+	      if ((reg >= S390_R0_REGNUM && reg <= S390_R15_REGNUM)
+		  || reg == S390_ORIG_R2_REGNUM)
+		{
+		  memset (p, 0, 4);
+		  p += 4;
+		}
+	      regcache_raw_collect (regcache, reg, p + 4);
+	    }
 	}
 
-      if (regno == S390_PSWA_REGNUM)
+      if (regno == -1
+	  || regno == S390_PSWM_REGNUM || regno == S390_PSWA_REGNUM)
 	{
-	  ULONGEST pswa;
+	  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
+	  ULONGEST pswa, pswm;
 	  gdb_byte buf[4];
 
-	  regcache_raw_collect (regcache, regno, buf);
+	  regcache_raw_collect (regcache, S390_PSWM_REGNUM, buf);
+	  pswm = extract_unsigned_integer (buf, 4, byte_order);
+	  regcache_raw_collect (regcache, S390_PSWA_REGNUM, buf);
 	  pswa = extract_unsigned_integer (buf, 4, byte_order);
 
-	  store_unsigned_integer (regp + regmap[S390_PSWA_REGNUM],
-				  8, byte_order, pswa & 0x7fffffff);
-
-	  /* Update basic addressing mode bit in PSW mask, see above.  */
-	  store_unsigned_integer (regp + regmap[S390_PSWM_REGNUM] + 4,
-				  4, byte_order, pswa & 0x80000000);
-	  return;
-	}
-
-      if ((regno >= S390_R0_REGNUM && regno <= S390_R15_REGNUM)
-	  || regno == S390_ORIG_R2_REGNUM)
-	{
-	  memset (regp + offset, 0, 4);
-	  offset += 4;
+	  if (regno == -1 || regno == S390_PSWM_REGNUM)
+	    store_unsigned_integer (psw_p[0], 8, byte_order,
+				    ((pswm & 0xfff7ffff) << 32) |
+				    (pswa & 0x80000000));
+	  if (regno == -1 || regno == S390_PSWA_REGNUM)
+	    store_unsigned_integer (psw_p[1], 8, byte_order,
+				    pswa & 0x7fffffff);
 	}
+      return;
     }
 #endif
 
-  if (offset != -1)
-    regcache_raw_collect (regcache, regno, regp + offset);
-}
-
-/* Fill GDB's register array with the general-purpose register values
-   in *REGP.  */
-void
-supply_gregset (struct regcache *regcache, const gregset_t *regp)
-{
-  int i;
-  for (i = 0; i < S390_NUM_REGS; i++)
-    s390_native_supply (regcache, i, (const gdb_byte *) regp, regmap_gregset);
-}
-
-/* Fill register REGNO (if it is a general-purpose register) in
-   *REGP with the value in GDB's register array.  If REGNO is -1,
-   do this for all registers.  */
-void
-fill_gregset (const struct regcache *regcache, gregset_t *regp, int regno)
-{
-  int i;
-  for (i = 0; i < S390_NUM_REGS; i++)
-    if (regno == -1 || regno == i)
-      s390_native_collect (regcache, i, (gdb_byte *) regp, regmap_gregset);
+  s390_native_collect (regcache, regmap_gregset, regno, (gdb_byte *) regp);
 }
 
 /* Fill GDB's register array with the floating-point register values
@@ -203,9 +203,7 @@ fill_gregset (const struct regcache *reg
 void
 supply_fpregset (struct regcache *regcache, const fpregset_t *regp)
 {
-  int i;
-  for (i = 0; i < S390_NUM_REGS; i++)
-    s390_native_supply (regcache, i, (const gdb_byte *) regp, regmap_fpregset);
+  s390_native_supply (regcache, regmap_fpregset, (const gdb_byte *) regp);
 }
 
 /* Fill register REGNO (if it is a general-purpose register) in
@@ -214,10 +212,7 @@ supply_fpregset (struct regcache *regcac
 void
 fill_fpregset (const struct regcache *regcache, fpregset_t *regp, int regno)
 {
-  int i;
-  for (i = 0; i < S390_NUM_REGS; i++)
-    if (regno == -1 || regno == i)
-      s390_native_collect (regcache, i, (gdb_byte *) regp, regmap_fpregset);
+  s390_native_collect (regcache, regmap_fpregset, regno, (gdb_byte *) regp);
 }
 
 /* Find the TID for the current inferior thread to use with ptrace.  */
@@ -311,12 +306,10 @@ store_fpregs (const struct regcache *reg
    process/thread TID and store their values in GDB's register cache.  */
 static void
 fetch_regset (struct regcache *regcache, int tid,
-	      int regset, int regsize, int *regmap)
+	      int regset, int regsize, const short *regmap)
 {
-  struct gdbarch *gdbarch = get_regcache_arch (regcache);
   gdb_byte *buf = alloca (regsize);
   struct iovec iov;
-  int i;
 
   iov.iov_base = buf;
   iov.iov_len = regsize;
@@ -324,8 +317,7 @@ fetch_regset (struct regcache *regcache,
   if (ptrace (PTRACE_GETREGSET, tid, (long) regset, (long) &iov) < 0)
     perror_with_name (_("Couldn't get register set"));
 
-  for (i = 0; i < S390_NUM_REGS; i++)
-    s390_native_supply (regcache, i, buf, regmap);
+  s390_native_supply (regcache, regmap, buf);
 }
 
 /* Store all registers in the kernel's register set whose number is REGSET,
@@ -333,12 +325,10 @@ fetch_regset (struct regcache *regcache,
    GDB's register cache back to process/thread TID.  */
 static void
 store_regset (struct regcache *regcache, int tid,
-	      int regset, int regsize, int *regmap)
+	      int regset, int regsize, const short *regmap)
 {
-  struct gdbarch *gdbarch = get_regcache_arch (regcache);
   gdb_byte *buf = alloca (regsize);
   struct iovec iov;
-  int i;
 
   iov.iov_base = buf;
   iov.iov_len = regsize;
@@ -346,8 +336,7 @@ store_regset (struct regcache *regcache,
   if (ptrace (PTRACE_GETREGSET, tid, (long) regset, (long) &iov) < 0)
     perror_with_name (_("Couldn't get register set"));
 
-  for (i = 0; i < S390_NUM_REGS; i++)
-    s390_native_collect (regcache, i, buf, regmap);
+  s390_native_collect (regcache, regmap, -1, buf);
 
   if (ptrace (PTRACE_SETREGSET, tid, (long) regset, (long) &iov) < 0)
     perror_with_name (_("Couldn't set register set"));
@@ -378,12 +367,10 @@ s390_linux_fetch_inferior_registers (str
 {
   int tid = s390_inferior_tid ();
 
-  if (regnum == -1 
-      || (regnum < S390_NUM_REGS && regmap_gregset[regnum] != -1))
+  if (regnum == -1 || S390_IS_GREGSET_REGNUM (regnum))
     fetch_regs (regcache, tid);
 
-  if (regnum == -1 
-      || (regnum < S390_NUM_REGS && regmap_fpregset[regnum] != -1))
+  if (regnum == -1 || S390_IS_FPREGSET_REGNUM (regnum))
     fetch_fpregs (regcache, tid);
 
   if (have_regset_last_break)
@@ -406,12 +393,10 @@ s390_linux_store_inferior_registers (str
 {
   int tid = s390_inferior_tid ();
 
-  if (regnum == -1 
-      || (regnum < S390_NUM_REGS && regmap_gregset[regnum] != -1))
+  if (regnum == -1 || S390_IS_GREGSET_REGNUM (regnum))
     store_regs (regcache, tid, regnum);
 
-  if (regnum == -1 
-      || (regnum < S390_NUM_REGS && regmap_fpregset[regnum] != -1))
+  if (regnum == -1 || S390_IS_FPREGSET_REGNUM (regnum))
     store_fpregs (regcache, tid, regnum);
 
   /* S390_LAST_BREAK_REGNUM is read-only.  */
Index: gdb-7.6.1/gdb/s390-tdep.c
===================================================================
--- gdb-7.6.1.orig/gdb/s390-tdep.c
+++ gdb-7.6.1/gdb/s390-tdep.c
@@ -141,7 +141,7 @@ s390_write_pc (struct regcache *regcache
 
 /* DWARF Register Mapping.  */
 
-static int s390_dwarf_regmap[] =
+static const short s390_dwarf_regmap[] =
 {
   /* General Purpose Registers.  */
   S390_R0_REGNUM, S390_R1_REGNUM, S390_R2_REGNUM, S390_R3_REGNUM,
@@ -212,6 +212,14 @@ s390_adjust_frame_regnum (struct gdbarch
 
 /* Pseudo registers.  */
 
+static int
+regnum_is_gpr_full (struct gdbarch_tdep *tdep, int regnum)
+{
+  return (tdep->gpr_full_regnum != -1
+	  && regnum >= tdep->gpr_full_regnum
+	  && regnum <= tdep->gpr_full_regnum + 15);
+}
+
 static const char *
 s390_pseudo_register_name (struct gdbarch *gdbarch, int regnum)
 {
@@ -223,9 +231,7 @@ s390_pseudo_register_name (struct gdbarc
   if (regnum == tdep->cc_regnum)
     return "cc";
 
-  if (tdep->gpr_full_regnum != -1
-      && regnum >= tdep->gpr_full_regnum
-      && regnum < tdep->gpr_full_regnum + 16)
+  if (regnum_is_gpr_full (tdep, regnum))
     {
       static const char *full_name[] = {
 	"r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
@@ -248,9 +254,7 @@ s390_pseudo_register_type (struct gdbarc
   if (regnum == tdep->cc_regnum)
     return builtin_type (gdbarch)->builtin_int;
 
-  if (tdep->gpr_full_regnum != -1
-      && regnum >= tdep->gpr_full_regnum
-      && regnum < tdep->gpr_full_regnum + 16)
+  if (regnum_is_gpr_full (tdep, regnum))
     return builtin_type (gdbarch)->builtin_uint64;
 
   internal_error (__FILE__, __LINE__, _("invalid regnum"));
@@ -295,9 +299,7 @@ s390_pseudo_register_read (struct gdbarc
       return status;
     }
 
-  if (tdep->gpr_full_regnum != -1
-      && regnum >= tdep->gpr_full_regnum
-      && regnum < tdep->gpr_full_regnum + 16)
+  if (regnum_is_gpr_full (tdep, regnum))
     {
       enum register_status status;
       ULONGEST val_upper;
@@ -352,9 +354,7 @@ s390_pseudo_register_write (struct gdbar
       return;
     }
 
-  if (tdep->gpr_full_regnum != -1
-      && regnum >= tdep->gpr_full_regnum
-      && regnum < tdep->gpr_full_regnum + 16)
+  if (regnum_is_gpr_full (tdep, regnum))
     {
       regnum -= tdep->gpr_full_regnum;
       val = extract_unsigned_integer (buf, regsize, byte_order);
@@ -409,175 +409,166 @@ s390_pseudo_register_reggroup_p (struct
 }
 
 
-/* Core file register sets.  */
+/* Maps for register sets.  */
 
-int s390_regmap_gregset[S390_NUM_REGS] =
-{
-  /* Program Status Word.  */
-  0x00, 0x04,
-  /* General Purpose Registers.  */
-  0x08, 0x0c, 0x10, 0x14,
-  0x18, 0x1c, 0x20, 0x24,
-  0x28, 0x2c, 0x30, 0x34,
-  0x38, 0x3c, 0x40, 0x44,
-  /* Access Registers.  */
-  0x48, 0x4c, 0x50, 0x54,
-  0x58, 0x5c, 0x60, 0x64,
-  0x68, 0x6c, 0x70, 0x74,
-  0x78, 0x7c, 0x80, 0x84,
-  /* Floating Point Control Word.  */
-  -1,
-  /* Floating Point Registers.  */
-  -1, -1, -1, -1, -1, -1, -1, -1,
-  -1, -1, -1, -1, -1, -1, -1, -1,
-  /* GPR Uppper Halves.  */
-  -1, -1, -1, -1, -1, -1, -1, -1,
-  -1, -1, -1, -1, -1, -1, -1, -1,
-  /* GNU/Linux-specific optional "registers".  */
-  0x88, -1, -1,
-};
+const short s390_regmap_gregset[] =
+  {
+    0x00, S390_PSWM_REGNUM,
+    0x04, S390_PSWA_REGNUM,
+    0x08, S390_R0_REGNUM,
+    0x0c, S390_R1_REGNUM,
+    0x10, S390_R2_REGNUM,
+    0x14, S390_R3_REGNUM,
+    0x18, S390_R4_REGNUM,
+    0x1c, S390_R5_REGNUM,
+    0x20, S390_R6_REGNUM,
+    0x24, S390_R7_REGNUM,
+    0x28, S390_R8_REGNUM,
+    0x2c, S390_R9_REGNUM,
+    0x30, S390_R10_REGNUM,
+    0x34, S390_R11_REGNUM,
+    0x38, S390_R12_REGNUM,
+    0x3c, S390_R13_REGNUM,
+    0x40, S390_R14_REGNUM,
+    0x44, S390_R15_REGNUM,
+    0x48, S390_A0_REGNUM,
+    0x4c, S390_A1_REGNUM,
+    0x50, S390_A2_REGNUM,
+    0x54, S390_A3_REGNUM,
+    0x58, S390_A4_REGNUM,
+    0x5c, S390_A5_REGNUM,
+    0x60, S390_A6_REGNUM,
+    0x64, S390_A7_REGNUM,
+    0x68, S390_A8_REGNUM,
+    0x6c, S390_A9_REGNUM,
+    0x70, S390_A10_REGNUM,
+    0x74, S390_A11_REGNUM,
+    0x78, S390_A12_REGNUM,
+    0x7c, S390_A13_REGNUM,
+    0x80, S390_A14_REGNUM,
+    0x84, S390_A15_REGNUM,
+    0x88, S390_ORIG_R2_REGNUM,
+    -1, -1
+  };
 
-int s390x_regmap_gregset[S390_NUM_REGS] =
-{
-  /* Program Status Word.  */
-  0x00, 0x08,
-  /* General Purpose Registers.  */
-  0x10, 0x18, 0x20, 0x28,
-  0x30, 0x38, 0x40, 0x48,
-  0x50, 0x58, 0x60, 0x68,
-  0x70, 0x78, 0x80, 0x88,
-  /* Access Registers.  */
-  0x90, 0x94, 0x98, 0x9c,
-  0xa0, 0xa4, 0xa8, 0xac,
-  0xb0, 0xb4, 0xb8, 0xbc,
-  0xc0, 0xc4, 0xc8, 0xcc,
-  /* Floating Point Control Word.  */
-  -1,
-  /* Floating Point Registers.  */
-  -1, -1, -1, -1, -1, -1, -1, -1,
-  -1, -1, -1, -1, -1, -1, -1, -1,
-  /* GPR Uppper Halves.  */
-  0x10, 0x18, 0x20, 0x28,
-  0x30, 0x38, 0x40, 0x48,
-  0x50, 0x58, 0x60, 0x68,
-  0x70, 0x78, 0x80, 0x88,
-  /* GNU/Linux-specific optional "registers".  */
-  0xd0, -1, -1,
-};
+const short s390x_regmap_gregset[] =
+  {
+    0x00, S390_PSWM_REGNUM,
+    0x08, S390_PSWA_REGNUM,
+    0x10, S390_R0_REGNUM,
+    0x18, S390_R1_REGNUM,
+    0x20, S390_R2_REGNUM,
+    0x28, S390_R3_REGNUM,
+    0x30, S390_R4_REGNUM,
+    0x38, S390_R5_REGNUM,
+    0x40, S390_R6_REGNUM,
+    0x48, S390_R7_REGNUM,
+    0x50, S390_R8_REGNUM,
+    0x58, S390_R9_REGNUM,
+    0x60, S390_R10_REGNUM,
+    0x68, S390_R11_REGNUM,
+    0x70, S390_R12_REGNUM,
+    0x78, S390_R13_REGNUM,
+    0x80, S390_R14_REGNUM,
+    0x88, S390_R15_REGNUM,
+    0x90, S390_A0_REGNUM,
+    0x94, S390_A1_REGNUM,
+    0x98, S390_A2_REGNUM,
+    0x9c, S390_A3_REGNUM,
+    0xa0, S390_A4_REGNUM,
+    0xa4, S390_A5_REGNUM,
+    0xa8, S390_A6_REGNUM,
+    0xac, S390_A7_REGNUM,
+    0xb0, S390_A8_REGNUM,
+    0xb4, S390_A9_REGNUM,
+    0xb8, S390_A10_REGNUM,
+    0xbc, S390_A11_REGNUM,
+    0xc0, S390_A12_REGNUM,
+    0xc4, S390_A13_REGNUM,
+    0xc8, S390_A14_REGNUM,
+    0xcc, S390_A15_REGNUM,
+    0x10, S390_R0_UPPER_REGNUM,
+    0x18, S390_R1_UPPER_REGNUM,
+    0x20, S390_R2_UPPER_REGNUM,
+    0x28, S390_R3_UPPER_REGNUM,
+    0x30, S390_R4_UPPER_REGNUM,
+    0x38, S390_R5_UPPER_REGNUM,
+    0x40, S390_R6_UPPER_REGNUM,
+    0x48, S390_R7_UPPER_REGNUM,
+    0x50, S390_R8_UPPER_REGNUM,
+    0x58, S390_R9_UPPER_REGNUM,
+    0x60, S390_R10_UPPER_REGNUM,
+    0x68, S390_R11_UPPER_REGNUM,
+    0x70, S390_R12_UPPER_REGNUM,
+    0x78, S390_R13_UPPER_REGNUM,
+    0x80, S390_R14_UPPER_REGNUM,
+    0x88, S390_R15_UPPER_REGNUM,
+    0xd0, S390_ORIG_R2_REGNUM,
+    -1, -1
+  };
 
-int s390_regmap_fpregset[S390_NUM_REGS] =
-{
-  /* Program Status Word.  */
-  -1, -1,
-  /* General Purpose Registers.  */
-  -1, -1, -1, -1, -1, -1, -1, -1,
-  -1, -1, -1, -1, -1, -1, -1, -1,
-  /* Access Registers.  */
-  -1, -1, -1, -1, -1, -1, -1, -1,
-  -1, -1, -1, -1, -1, -1, -1, -1,
-  /* Floating Point Control Word.  */
-  0x00,
-  /* Floating Point Registers.  */
-  0x08, 0x10, 0x18, 0x20,
-  0x28, 0x30, 0x38, 0x40,
-  0x48, 0x50, 0x58, 0x60,
-  0x68, 0x70, 0x78, 0x80,
-  /* GPR Uppper Halves.  */
-  -1, -1, -1, -1, -1, -1, -1, -1,
-  -1, -1, -1, -1, -1, -1, -1, -1,
-  /* GNU/Linux-specific optional "registers".  */
-  -1, -1, -1,
-};
+const short s390_regmap_fpregset[] =
+  {
+    0x00, S390_FPC_REGNUM,
+    0x08, S390_F0_REGNUM,
+    0x10, S390_F1_REGNUM,
+    0x18, S390_F2_REGNUM,
+    0x20, S390_F3_REGNUM,
+    0x28, S390_F4_REGNUM,
+    0x30, S390_F5_REGNUM,
+    0x38, S390_F6_REGNUM,
+    0x40, S390_F7_REGNUM,
+    0x48, S390_F8_REGNUM,
+    0x50, S390_F9_REGNUM,
+    0x58, S390_F10_REGNUM,
+    0x60, S390_F11_REGNUM,
+    0x68, S390_F12_REGNUM,
+    0x70, S390_F13_REGNUM,
+    0x78, S390_F14_REGNUM,
+    0x80, S390_F15_REGNUM,
+    -1, -1
+  };
 
-int s390_regmap_upper[S390_NUM_REGS] =
-{
-  /* Program Status Word.  */
-  -1, -1,
-  /* General Purpose Registers.  */
-  -1, -1, -1, -1, -1, -1, -1, -1,
-  -1, -1, -1, -1, -1, -1, -1, -1,
-  /* Access Registers.  */
-  -1, -1, -1, -1, -1, -1, -1, -1,
-  -1, -1, -1, -1, -1, -1, -1, -1,
-  /* Floating Point Control Word.  */
-  -1,
-  /* Floating Point Registers.  */
-  -1, -1, -1, -1, -1, -1, -1, -1,
-  -1, -1, -1, -1, -1, -1, -1, -1,
-  /* GPR Uppper Halves.  */
-  0x00, 0x04, 0x08, 0x0c,
-  0x10, 0x14, 0x18, 0x1c,
-  0x20, 0x24, 0x28, 0x2c,
-  0x30, 0x34, 0x38, 0x3c,
-  /* GNU/Linux-specific optional "registers".  */
-  -1, -1, -1,
-};
+const short s390_regmap_upper[] =
+  {
+    0x00, S390_R0_UPPER_REGNUM,
+    0x04, S390_R1_UPPER_REGNUM,
+    0x08, S390_R2_UPPER_REGNUM,
+    0x0c, S390_R3_UPPER_REGNUM,
+    0x10, S390_R4_UPPER_REGNUM,
+    0x14, S390_R5_UPPER_REGNUM,
+    0x18, S390_R6_UPPER_REGNUM,
+    0x1c, S390_R7_UPPER_REGNUM,
+    0x20, S390_R8_UPPER_REGNUM,
+    0x24, S390_R9_UPPER_REGNUM,
+    0x28, S390_R10_UPPER_REGNUM,
+    0x2c, S390_R11_UPPER_REGNUM,
+    0x30, S390_R12_UPPER_REGNUM,
+    0x34, S390_R13_UPPER_REGNUM,
+    0x38, S390_R14_UPPER_REGNUM,
+    0x3c, S390_R15_UPPER_REGNUM,
+    -1, -1
+  };
 
-int s390_regmap_last_break[S390_NUM_REGS] =
-{
-  /* Program Status Word.  */
-  -1, -1,
-  /* General Purpose Registers.  */
-  -1, -1, -1, -1, -1, -1, -1, -1,
-  -1, -1, -1, -1, -1, -1, -1, -1,
-  /* Access Registers.  */
-  -1, -1, -1, -1, -1, -1, -1, -1,
-  -1, -1, -1, -1, -1, -1, -1, -1,
-  /* Floating Point Control Word.  */
-  -1,
-  /* Floating Point Registers.  */
-  -1, -1, -1, -1, -1, -1, -1, -1,
-  -1, -1, -1, -1, -1, -1, -1, -1,
-  /* GPR Uppper Halves.  */
-  -1, -1, -1, -1, -1, -1, -1, -1,
-  -1, -1, -1, -1, -1, -1, -1, -1,
-  /* GNU/Linux-specific optional "registers".  */
-  -1, 4, -1,
-};
+const short s390_regmap_last_break[] =
+  {
+    0x04, S390_LAST_BREAK_REGNUM,
+    -1, -1
+  };
+
+const short s390x_regmap_last_break[] =
+  {
+    0x00, S390_LAST_BREAK_REGNUM,
+    -1, -1
+  };
+
+const short s390_regmap_system_call[] =
+  {
+    0x00, S390_SYSTEM_CALL_REGNUM,
+    -1, -1
+  };
 
-int s390x_regmap_last_break[S390_NUM_REGS] =
-{
-  /* Program Status Word.  */
-  -1, -1,
-  /* General Purpose Registers.  */
-  -1, -1, -1, -1, -1, -1, -1, -1,
-  -1, -1, -1, -1, -1, -1, -1, -1,
-  /* Access Registers.  */
-  -1, -1, -1, -1, -1, -1, -1, -1,
-  -1, -1, -1, -1, -1, -1, -1, -1,
-  /* Floating Point Control Word.  */
-  -1,
-  /* Floating Point Registers.  */
-  -1, -1, -1, -1, -1, -1, -1, -1,
-  -1, -1, -1, -1, -1, -1, -1, -1,
-  /* GPR Uppper Halves.  */
-  -1, -1, -1, -1, -1, -1, -1, -1,
-  -1, -1, -1, -1, -1, -1, -1, -1,
-  /* GNU/Linux-specific optional "registers".  */
-  -1, 0, -1,
-};
 
-int s390_regmap_system_call[S390_NUM_REGS] =
-{
-  /* Program Status Word.  */
-  -1, -1,
-  /* General Purpose Registers.  */
-  -1, -1, -1, -1, -1, -1, -1, -1,
-  -1, -1, -1, -1, -1, -1, -1, -1,
-  /* Access Registers.  */
-  -1, -1, -1, -1, -1, -1, -1, -1,
-  -1, -1, -1, -1, -1, -1, -1, -1,
-  /* Floating Point Control Word.  */
-  -1,
-  /* Floating Point Registers.  */
-  -1, -1, -1, -1, -1, -1, -1, -1,
-  -1, -1, -1, -1, -1, -1, -1, -1,
-  /* GPR Uppper Halves.  */
-  -1, -1, -1, -1, -1, -1, -1, -1,
-  -1, -1, -1, -1, -1, -1, -1, -1,
-  /* GNU/Linux-specific optional "registers".  */
-  -1, -1, 0,
-};
 
 /* Supply register REGNUM from the register set REGSET to register cache 
    REGCACHE.  If REGNUM is -1, do this for all registers in REGSET.  */
@@ -585,14 +576,10 @@ static void
 s390_supply_regset (const struct regset *regset, struct regcache *regcache,
 		    int regnum, const void *regs, size_t len)
 {
-  const int *offset = regset->descr;
-  int i;
-
-  for (i = 0; i < S390_NUM_REGS; i++)
-    {
-      if ((regnum == i || regnum == -1) && offset[i] != -1)
-	regcache_raw_supply (regcache, i, (const char *)regs + offset[i]);
-    }
+  const short *map;
+  for (map = regset->descr; map[0] >= 0; map += 2)
+    if (regnum == -1 || regnum == map[1])
+      regcache_raw_supply (regcache, map[1], (const char *)regs + map[0]);
 }
 
 /* Collect register REGNUM from the register cache REGCACHE and store
@@ -604,14 +591,10 @@ s390_collect_regset (const struct regset
 		     const struct regcache *regcache,
 		     int regnum, void *regs, size_t len)
 {
-  const int *offset = regset->descr;
-  int i;
-
-  for (i = 0; i < S390_NUM_REGS; i++)
-    {
-      if ((regnum == i || regnum == -1) && offset[i] != -1)
-	regcache_raw_collect (regcache, i, (char *)regs + offset[i]);
-    }
+  const short *map;
+  for (map = regset->descr; map[0] >= 0; map += 2)
+    if (regnum == -1 || regnum == map[1])
+      regcache_raw_collect (regcache, map[1], (char *)regs + map[0]);
 }
 
 static const struct regset s390_gregset = {
@@ -1718,9 +1701,7 @@ s390_unwind_pseudo_register (struct fram
 
   /* Unwind full GPRs to show at least the lower halves (as the
      upper halves are undefined).  */
-  if (tdep->gpr_full_regnum != -1
-      && regnum >= tdep->gpr_full_regnum
-      && regnum < tdep->gpr_full_regnum + 16)
+  if (regnum_is_gpr_full (tdep, regnum))
     {
       int reg = regnum - tdep->gpr_full_regnum;
       struct value *val;
Index: gdb-7.6.1/gdb/s390-tdep.h
===================================================================
--- gdb-7.6.1.orig/gdb/s390-tdep.h
+++ gdb-7.6.1/gdb/s390-tdep.h
@@ -106,16 +106,24 @@
 #define S390_RETADDR_REGNUM S390_R14_REGNUM
 #define S390_FRAME_REGNUM S390_R11_REGNUM
 
+#define S390_IS_GREGSET_REGNUM(i)					\
+  (((i) >= S390_PSWM_REGNUM && (i) <= S390_A15_REGNUM)			\
+   || ((i) >= S390_R0_UPPER_REGNUM && (i) <= S390_R15_UPPER_REGNUM)	\
+   || (i) == S390_ORIG_R2_REGNUM)
+
+#define S390_IS_FPREGSET_REGNUM(i)			\
+  ((i) >= S390_FPC_REGNUM && (i) <= S390_F15_REGNUM)
+
 /* Core file register sets, defined in s390-tdep.c.  */
 #define s390_sizeof_gregset 0x90
-extern int s390_regmap_gregset[S390_NUM_REGS];
+extern const short s390_regmap_gregset[];
 #define s390x_sizeof_gregset 0xd8
-extern int s390x_regmap_gregset[S390_NUM_REGS];
+extern const short s390x_regmap_gregset[];
 #define s390_sizeof_fpregset 0x88
-extern int s390_regmap_fpregset[S390_NUM_REGS];
-extern int s390_regmap_last_break[S390_NUM_REGS];
-extern int s390x_regmap_last_break[S390_NUM_REGS];
-extern int s390_regmap_system_call[S390_NUM_REGS];
+extern const short s390_regmap_fpregset[];
+extern const short s390_regmap_last_break[];
+extern const short s390x_regmap_last_break[];
+extern const short s390_regmap_system_call[];
 
 /* GNU/Linux target descriptions.  */
 extern struct target_desc *tdesc_s390_linux32;
