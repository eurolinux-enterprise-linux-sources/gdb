Re: RFC: fix `gdb -write' case
http://sourceware.org/ml/gdb-patches/2011-05/msg00294.html
http://sourceware.org/ml/gdb-cvs/2011-05/msg00184.html

### src/gdb/ChangeLog	2011/05/23 17:38:05	1.13038
### src/gdb/ChangeLog	2011/05/23 20:27:23	1.13039
## -1,3 +1,8 @@
+2011-05-23  Tom Tromey  <tromey@redhat.com>
+
+	* c-lang.c (evaluate_subexp_c): Use expect_type if it is not
+	NULL.
+
 2011-05-23  Doug Evans  <dje@google.com>
 
 	* python/lib/gdb/printing.py (register_pretty_printer): Add missing
--- src/gdb/c-lang.c	2011/01/11 15:10:00	1.92
+++ src/gdb/c-lang.c	2011/05/23 20:27:23	1.93
@@ -978,6 +978,7 @@
 	struct value *result;
 	enum c_string_type dest_type;
 	const char *dest_charset;
+	int satisfy_expected = 0;
 
 	obstack_init (&output);
 	cleanup = make_cleanup_obstack_free (&output);
@@ -1014,6 +1015,22 @@
 	/* Ensure TYPE_LENGTH is valid for TYPE.  */
 	check_typedef (type);
 
+	/* If the caller expects an array of some integral type,
+	   satisfy them.  If something odder is expected, rely on the
+	   caller to cast.  */
+	if (expect_type && TYPE_CODE (expect_type) == TYPE_CODE_ARRAY)
+	  {
+	    struct type *element_type
+	      = check_typedef (TYPE_TARGET_TYPE (expect_type));
+
+	    if (TYPE_CODE (element_type) == TYPE_CODE_INT
+		|| TYPE_CODE (element_type) == TYPE_CODE_CHAR)
+	      {
+		type = element_type;
+		satisfy_expected = 1;
+	      }
+	  }
+
 	dest_charset = charset_for_string_type (dest_type, exp->gdbarch);
 
 	++*pos;
@@ -1036,7 +1053,9 @@
 	if (noside == EVAL_SKIP)
 	  {
 	    /* Return a dummy value of the appropriate type.  */
-	    if ((dest_type & C_CHAR) != 0)
+	    if (expect_type != NULL)
+	      result = allocate_value (expect_type);
+	    else if ((dest_type & C_CHAR) != 0)
 	      result = allocate_value (type);
 	    else
 	      result = value_cstring ("", 0, type);
@@ -1061,9 +1080,30 @@
 	    /* Write the terminating character.  */
 	    for (i = 0; i < TYPE_LENGTH (type); ++i)
 	      obstack_1grow (&output, 0);
-	    result = value_cstring (obstack_base (&output),
-				    obstack_object_size (&output),
-				    type);
+
+	    if (satisfy_expected)
+	      {
+		LONGEST low_bound, high_bound;
+		int element_size = TYPE_LENGTH (type);
+
+		if (get_discrete_bounds (TYPE_INDEX_TYPE (expect_type),
+					 &low_bound, &high_bound) < 0)
+		  {
+		    low_bound = 0;
+		    high_bound = (TYPE_LENGTH (expect_type) / element_size) - 1;
+		  }
+		if (obstack_object_size (&output) / element_size
+		    > (high_bound - low_bound + 1))
+		  error (_("Too many array elements"));
+
+		result = allocate_value (expect_type);
+		memcpy (value_contents_raw (result), obstack_base (&output),
+			obstack_object_size (&output));
+	      }
+	    else
+	      result = value_cstring (obstack_base (&output),
+				      obstack_object_size (&output),
+				      type);
 	  }
 	do_cleanups (cleanup);
 	return result;
### src/gdb/testsuite/ChangeLog	2011/05/20 17:52:54	1.2719
### src/gdb/testsuite/ChangeLog	2011/05/23 20:27:23	1.2720
## -1,3 +1,9 @@
+2011-05-23  Tom Tromey  <tromey@redhat.com>
+
+	* gdb.base/charset.exp (string_display): Add tests to assign to
+	arrays.
+	* gdb.base/charset.c (short_array, int_array, long_array): New.
+
 2011-05-20  Pedro Alves  <pedro@codesourcery.com>
 
 	Cope with async mode.
--- src/gdb/testsuite/gdb.base/charset.c	2011/01/01 15:33:41	1.16
+++ src/gdb/testsuite/gdb.base/charset.c	2011/05/23 20:27:23	1.17
@@ -73,6 +73,11 @@
 typedef wchar_t my_wchar_t;
 my_wchar_t myvar;
 
+/* Some arrays for simple assignment tests.  */
+short short_array[3];
+int int_array[3];
+long long_array[3];
+
 void
 init_string (char string[],
              char x,
--- src/gdb/testsuite/gdb.base/charset.exp	2011/05/13 18:31:01	1.28
+++ src/gdb/testsuite/gdb.base/charset.exp	2011/05/23 20:27:23	1.29
@@ -625,4 +625,13 @@
 }
 
 
+foreach name {short int long} {
+    # We're really just checking to make sure this doesn't give an
+    # error.
+    gdb_test "print ${name}_array = \"hi\"" \
+	" = {.*}" \
+	"assign string to $name array"
+}
+
+
 gdb_exit 
